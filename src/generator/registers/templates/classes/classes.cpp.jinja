#include "register/register_classes.h"
#include "qjspp/utils.h"
#include <godot_cpp/classes/{{clazz.name|camel_to_snake}}.hpp>
{% for file_path in classes%}
    {% set clz = file_path | get_file_name | snake_to_camel %}
    {% if file_path != 'godot_cpp/variant/array_helpers.hpp' %}
#include <{{file_path}}>
    {% endif %}
{% endfor %}

{%- macro method_parser(clazz, method) -%}
    {%- if method -%}
    {{-'static_cast<'-}}
    {%- if method.return_value -%}
        {%- if method.return_value.meta -%}
            {{-method.return_value.meta | convert_return_type-}}
        {%- else -%}
            {% if 'typedarray::' in method.return_value.type %}
            {{-method.return_value.type | typedarray_convert-}}
            {% else %}
            {{-method.return_value.type | convert_return_type-}}
            {% endif %}
        {%- endif -%}
    {%- else -%}
            {{-'void'-}}
    {%- endif -%}
        {{-'('-}}{{-clazz.name-}}{{-'::*)'-}}
        {%- if not method.arguments -%}
        ()
        {%- else -%}
        {{-'('-}}{{ method.arguments | convert_types(method.is_vararg) | join(',') }}{{-')'-}}
        {% endif %}
    {%- if method.is_const -%}const{%- endif -%}>(&{{clazz.name}}::{{method.name}})
    {%- endif -%}
{%- endmacro -%}

{%- macro static_method_parser(clazz, method) -%}
    {%- if method -%}
    {{-'static_cast<'-}}
    {%- if method.return_value -%}
        {%- if method.return_value.meta -%}
            {{-method.return_value.meta | convert_return_type-}}
        {%- else -%}
            {% if 'typedarray::' in method.return_value.type %}
            {{-method.return_value.type | typedarray_convert-}}
            {% else %}
            {{-method.return_value.type | convert_return_type-}}
            {% endif %}
        {%- endif -%}
    {%- else -%}
            {{-'void'-}}
    {%- endif -%}
        {{-'(*)'-}}
        {%- if not method.arguments -%}
        ()
        {%- else -%}
        {{-'('-}}{{ method.arguments | convert_types(method.is_vararg) | join(',') }}{{-')'-}}
        {% endif %}
    {%- if method.is_const -%}const{%- endif -%}>(&{{clazz.name}}::{{method.name}})
    {%- endif -%}
{%- endmacro -%}

using namespace godot;

{% set singletons_type = singletons | map(attribute='type') | list %}
void register_classes_{{clazz.name}}() {
    qjs::Context::Module &_module = get_{{clazz.module}}_module();
    _module.class_<{{clazz.name}}>("{{clazz.name}}")
            {% if clazz.name not in (singletons | map(attribute='type')) %}
            .constructor<>()
            {% endif %}
            {% if clazz.inherits %}
            .base<{{clazz.inherits}}>()
            {% endif %}
            {% if clazz.constants %}
                {% for constant in clazz.constants %}
            .static_fun<&{{clazz.name}}::{{constant.name}}>("{{constant.name}}")
                {% endfor %}
            {% endif %}
{% if 'properties' in clazz %}
{% for prop in clazz.properties %}
    {% set setter = (clazz.methods | selectattr('name', 'equalto', prop.setter) | list | first) %}
    {% set getter = (clazz.methods | selectattr('name', 'equalto', prop.getter) | list | first) %}
    {% if (prop.getter and getter and not prop.getter.startswith('_')) and (prop.setter and setter and not prop.setter.startswith('_')) %}
            .property<{{- method_parser(clazz, getter) -}}, {{- method_parser(clazz, setter) -}}>("{{prop.name}}")
    {% elif prop.getter and getter and not prop.getter.startswith('_') %}
            .property<{{- method_parser(clazz, getter) -}}>("{{prop.name}}")
    {% elif prop.setter and setter and not prop.setter.startswith('_')%}
            .property<{{- method_parser(clazz, setter) -}}>("{{setter}}")
    {% endif %}
{% endfor %}
{% endif %}
{% for method in clazz.methods %}
    {% set getter_names = clazz.properties | map(attribute='getter') %}
    {% set setter_names = clazz.properties | map(attribute='setter') %}
    {% if method.name not in getter_names and method.name not in setter_names %}
        {% if not method.is_static %}
            .fun<{{- method_parser(clazz, method) -}}>("{{method.name}}")
        {% else %}
            .static_fun<{{-static_method_parser(clazz, method)-}}>("{{method.name}}")
        {% endif %}
	{% endif %}
{% endfor %}
{{-';'-}}
{% if clazz.enums %}
{% for _enum in clazz.enums %}
    {% if clazz.name not in (singletons | map(attribute='type') | list) %}
    qjs::Value _{{_enum.name}} = context->newObject();
    {% for value in _enum['values'] %}
    _{{_enum.name}}["{{value.name}}"] = {{clazz.name}}::{{_enum.name}}::{{value.name}};
    {% endfor %}
    _module.add("{{_enum.name}}", std::move(_{{_enum.name}}));
    {% endif %}
{% endfor %}
{% endif %}
}