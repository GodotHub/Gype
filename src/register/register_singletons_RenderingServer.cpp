
#include <godot_cpp/classes/image.hpp>
#include <godot_cpp/classes/ref.hpp>
#include <godot_cpp/classes/rendering_device.hpp>
#include <godot_cpp/classes/rendering_server.hpp>
#include <godot_cpp/core/type_info.hpp>
#include <godot_cpp/variant/aabb.hpp>
#include <godot_cpp/variant/array.hpp>
#include <godot_cpp/variant/basis.hpp>
#include <godot_cpp/variant/callable.hpp>
#include <godot_cpp/variant/color.hpp>
#include <godot_cpp/variant/dictionary.hpp>
#include <godot_cpp/variant/packed_byte_array.hpp>
#include <godot_cpp/variant/packed_color_array.hpp>
#include <godot_cpp/variant/packed_float32_array.hpp>
#include <godot_cpp/variant/packed_int32_array.hpp>
#include <godot_cpp/variant/packed_int64_array.hpp>
#include <godot_cpp/variant/packed_vector2_array.hpp>
#include <godot_cpp/variant/packed_vector3_array.hpp>
#include <godot_cpp/variant/plane.hpp>
#include <godot_cpp/variant/rect2.hpp>
#include <godot_cpp/variant/rid.hpp>
#include <godot_cpp/variant/string.hpp>
#include <godot_cpp/variant/string_name.hpp>
#include <godot_cpp/variant/transform2d.hpp>
#include <godot_cpp/variant/transform3d.hpp>
#include <godot_cpp/variant/typed_array.hpp>
#include <godot_cpp/variant/variant.hpp>
#include <godot_cpp/variant/vector2.hpp>
#include <godot_cpp/variant/vector2i.hpp>
#include <godot_cpp/variant/vector3.hpp>
#include <godot_cpp/variant/vector3i.hpp>
#include <string>

#include "qjspp.hpp"
#include "qjspp/utils.h"
#include "register/register_classes.h"

using namespace godot;

void register_singletons_RenderingServer() {
	qjs::Value js_singleton = context->newObject();
	RenderingServer *singleton = RenderingServer::get_singleton();
	js_singleton.add((new std::string("texture_2d_create"))->c_str(), [singleton](const Ref<Image> &image) -> RID { return singleton->texture_2d_create(image); });
	js_singleton.add((new std::string("texture_2d_layered_create"))->c_str(), [singleton](const TypedArray<Image> &layers, RenderingServer::TextureLayeredType layered_type) -> RID { return singleton->texture_2d_layered_create(layers, layered_type); });
	js_singleton.add((new std::string("texture_3d_create"))->c_str(), [singleton](Image::Format format, int32_t width, int32_t height, int32_t depth, bool mipmaps, const TypedArray<Image> &data) -> RID { return singleton->texture_3d_create(format, width, height, depth, mipmaps, data); });
	js_singleton.add((new std::string("texture_proxy_create"))->c_str(), [singleton](const RID &base) -> RID { return singleton->texture_proxy_create(base); });
	js_singleton.add((new std::string("texture_2d_update"))->c_str(), [singleton](const RID &texture, const Ref<Image> &image, int32_t layer) -> void { singleton->texture_2d_update(texture, image, layer); });
	js_singleton.add((new std::string("texture_3d_update"))->c_str(), [singleton](const RID &texture, const TypedArray<Image> &data) -> void { singleton->texture_3d_update(texture, data); });
	js_singleton.add((new std::string("texture_proxy_update"))->c_str(), [singleton](const RID &texture, const RID &proxy_to) -> void { singleton->texture_proxy_update(texture, proxy_to); });
	js_singleton.add((new std::string("texture_2d_placeholder_create"))->c_str(), [singleton]() -> RID { return singleton->texture_2d_placeholder_create(); });
	js_singleton.add((new std::string("texture_2d_layered_placeholder_create"))->c_str(), [singleton](RenderingServer::TextureLayeredType layered_type) -> RID { return singleton->texture_2d_layered_placeholder_create(layered_type); });
	js_singleton.add((new std::string("texture_3d_placeholder_create"))->c_str(), [singleton]() -> RID { return singleton->texture_3d_placeholder_create(); });
	js_singleton.add((new std::string("texture_2d_get"))->c_str(), [singleton](const RID &texture) -> Ref<Image> { return singleton->texture_2d_get(texture); });
	js_singleton.add((new std::string("texture_2d_layer_get"))->c_str(), [singleton](const RID &texture, int32_t layer) -> Ref<Image> { return singleton->texture_2d_layer_get(texture, layer); });
	js_singleton.add((new std::string("texture_3d_get"))->c_str(), [singleton](const RID &texture) -> TypedArray<Image> { return singleton->texture_3d_get(texture); });
	js_singleton.add((new std::string("texture_replace"))->c_str(), [singleton](const RID &texture, const RID &by_texture) -> void { singleton->texture_replace(texture, by_texture); });
	js_singleton.add((new std::string("texture_set_size_override"))->c_str(), [singleton](const RID &texture, int32_t width, int32_t height) -> void { singleton->texture_set_size_override(texture, width, height); });
	js_singleton.add((new std::string("texture_set_path"))->c_str(), [singleton](const RID &texture, const String &path) -> void { singleton->texture_set_path(texture, path); });
	js_singleton.add((new std::string("texture_get_path"))->c_str(), [singleton](const RID &texture) -> String { return singleton->texture_get_path(texture); });
	js_singleton.add((new std::string("texture_get_format"))->c_str(), [singleton](const RID &texture) -> Image::Format { return singleton->texture_get_format(texture); });
	js_singleton.add((new std::string("texture_set_force_redraw_if_visible"))->c_str(), [singleton](const RID &texture, bool enable) -> void { singleton->texture_set_force_redraw_if_visible(texture, enable); });
	js_singleton.add((new std::string("texture_rd_create"))->c_str(), [singleton](const RID &rd_texture, RenderingServer::TextureLayeredType layer_type) -> RID { return singleton->texture_rd_create(rd_texture, layer_type); });
	js_singleton.add((new std::string("texture_get_rd_texture"))->c_str(), [singleton](const RID &texture, bool srgb) -> RID { return singleton->texture_get_rd_texture(texture, srgb); });
	js_singleton.add((new std::string("texture_get_native_handle"))->c_str(), [singleton](const RID &texture, bool srgb) -> int64_t { return singleton->texture_get_native_handle(texture, srgb); });
	js_singleton.add((new std::string("shader_create"))->c_str(), [singleton]() -> RID { return singleton->shader_create(); });
	js_singleton.add((new std::string("shader_set_code"))->c_str(), [singleton](const RID &shader, const String &code) -> void { singleton->shader_set_code(shader, code); });
	js_singleton.add((new std::string("shader_set_path_hint"))->c_str(), [singleton](const RID &shader, const String &path) -> void { singleton->shader_set_path_hint(shader, path); });
	js_singleton.add((new std::string("shader_get_code"))->c_str(), [singleton](const RID &shader) -> String { return singleton->shader_get_code(shader); });
	js_singleton.add((new std::string("get_shader_parameter_list"))->c_str(), [singleton](const RID &shader) -> TypedArray<Dictionary> { return singleton->get_shader_parameter_list(shader); });
	js_singleton.add((new std::string("shader_get_parameter_default"))->c_str(), [singleton](const RID &shader, const StringName &name) -> Variant { return singleton->shader_get_parameter_default(shader, name); });
	js_singleton.add((new std::string("shader_set_default_texture_parameter"))->c_str(), [singleton](const RID &shader, const StringName &name, const RID &texture, int32_t index) -> void { singleton->shader_set_default_texture_parameter(shader, name, texture, index); });
	js_singleton.add((new std::string("shader_get_default_texture_parameter"))->c_str(), [singleton](const RID &shader, const StringName &name, int32_t index) -> RID { return singleton->shader_get_default_texture_parameter(shader, name, index); });
	js_singleton.add((new std::string("material_create"))->c_str(), [singleton]() -> RID { return singleton->material_create(); });
	js_singleton.add((new std::string("material_set_shader"))->c_str(), [singleton](const RID &shader_material, const RID &shader) -> void { singleton->material_set_shader(shader_material, shader); });
	js_singleton.add((new std::string("material_set_param"))->c_str(), [singleton](const RID &material, const StringName &parameter, const Variant &value) -> void { singleton->material_set_param(material, parameter, value); });
	js_singleton.add((new std::string("material_get_param"))->c_str(), [singleton](const RID &material, const StringName &parameter) -> Variant { return singleton->material_get_param(material, parameter); });
	js_singleton.add((new std::string("material_set_render_priority"))->c_str(), [singleton](const RID &material, int32_t priority) -> void { singleton->material_set_render_priority(material, priority); });
	js_singleton.add((new std::string("material_set_next_pass"))->c_str(), [singleton](const RID &material, const RID &next_material) -> void { singleton->material_set_next_pass(material, next_material); });
	js_singleton.add((new std::string("mesh_create_from_surfaces"))->c_str(), [singleton](const TypedArray<Dictionary> &surfaces, int32_t blend_shape_count) -> RID { return singleton->mesh_create_from_surfaces(surfaces, blend_shape_count); });
	js_singleton.add((new std::string("mesh_create"))->c_str(), [singleton]() -> RID { return singleton->mesh_create(); });
	js_singleton.add((new std::string("mesh_surface_get_format_offset"))->c_str(), [singleton](BitField<RenderingServer::ArrayFormat> format, int32_t vertex_count, int32_t array_index) -> int64_t { return singleton->mesh_surface_get_format_offset(format, vertex_count, array_index); });
	js_singleton.add((new std::string("mesh_surface_get_format_vertex_stride"))->c_str(), [singleton](BitField<RenderingServer::ArrayFormat> format, int32_t vertex_count) -> int64_t { return singleton->mesh_surface_get_format_vertex_stride(format, vertex_count); });
	js_singleton.add((new std::string("mesh_surface_get_format_normal_tangent_stride"))->c_str(), [singleton](BitField<RenderingServer::ArrayFormat> format, int32_t vertex_count) -> int64_t { return singleton->mesh_surface_get_format_normal_tangent_stride(format, vertex_count); });
	js_singleton.add((new std::string("mesh_surface_get_format_attribute_stride"))->c_str(), [singleton](BitField<RenderingServer::ArrayFormat> format, int32_t vertex_count) -> int64_t { return singleton->mesh_surface_get_format_attribute_stride(format, vertex_count); });
	js_singleton.add((new std::string("mesh_surface_get_format_skin_stride"))->c_str(), [singleton](BitField<RenderingServer::ArrayFormat> format, int32_t vertex_count) -> int64_t { return singleton->mesh_surface_get_format_skin_stride(format, vertex_count); });
	js_singleton.add((new std::string("mesh_add_surface"))->c_str(), [singleton](const RID &mesh, const Dictionary &surface) -> void { singleton->mesh_add_surface(mesh, surface); });
	js_singleton.add((new std::string("mesh_add_surface_from_arrays"))->c_str(), [singleton](const RID &mesh, RenderingServer::PrimitiveType primitive, const Array &arrays, const Array &blend_shapes, const Dictionary &lods, BitField<RenderingServer::ArrayFormat> compress_format) -> void { singleton->mesh_add_surface_from_arrays(mesh, primitive, arrays, blend_shapes, lods, compress_format); });
	js_singleton.add((new std::string("mesh_get_blend_shape_count"))->c_str(), [singleton](const RID &mesh) -> int64_t { return singleton->mesh_get_blend_shape_count(mesh); });
	js_singleton.add((new std::string("mesh_set_blend_shape_mode"))->c_str(), [singleton](const RID &mesh, RenderingServer::BlendShapeMode mode) -> void { singleton->mesh_set_blend_shape_mode(mesh, mode); });
	js_singleton.add((new std::string("mesh_get_blend_shape_mode"))->c_str(), [singleton](const RID &mesh) -> RenderingServer::BlendShapeMode { return singleton->mesh_get_blend_shape_mode(mesh); });
	js_singleton.add((new std::string("mesh_surface_set_material"))->c_str(), [singleton](const RID &mesh, int32_t surface, const RID &material) -> void { singleton->mesh_surface_set_material(mesh, surface, material); });
	js_singleton.add((new std::string("mesh_surface_get_material"))->c_str(), [singleton](const RID &mesh, int32_t surface) -> RID { return singleton->mesh_surface_get_material(mesh, surface); });
	js_singleton.add((new std::string("mesh_get_surface"))->c_str(), [singleton](const RID &mesh, int32_t surface) -> Dictionary { return singleton->mesh_get_surface(mesh, surface); });
	js_singleton.add((new std::string("mesh_surface_get_arrays"))->c_str(), [singleton](const RID &mesh, int32_t surface) -> Array { return singleton->mesh_surface_get_arrays(mesh, surface); });
	js_singleton.add((new std::string("mesh_surface_get_blend_shape_arrays"))->c_str(), [singleton](const RID &mesh, int32_t surface) -> TypedArray<Array> { return singleton->mesh_surface_get_blend_shape_arrays(mesh, surface); });
	js_singleton.add((new std::string("mesh_get_surface_count"))->c_str(), [singleton](const RID &mesh) -> int64_t { return singleton->mesh_get_surface_count(mesh); });
	js_singleton.add((new std::string("mesh_set_custom_aabb"))->c_str(), [singleton](const RID &mesh, const AABB &aabb) -> void { singleton->mesh_set_custom_aabb(mesh, aabb); });
	js_singleton.add((new std::string("mesh_get_custom_aabb"))->c_str(), [singleton](const RID &mesh) -> AABB { return singleton->mesh_get_custom_aabb(mesh); });
	js_singleton.add((new std::string("mesh_clear"))->c_str(), [singleton](const RID &mesh) -> void { singleton->mesh_clear(mesh); });
	js_singleton.add((new std::string("mesh_surface_update_vertex_region"))->c_str(), [singleton](const RID &mesh, int32_t surface, int32_t offset, const PackedByteArray &data) -> void { singleton->mesh_surface_update_vertex_region(mesh, surface, offset, data); });
	js_singleton.add((new std::string("mesh_surface_update_attribute_region"))->c_str(), [singleton](const RID &mesh, int32_t surface, int32_t offset, const PackedByteArray &data) -> void { singleton->mesh_surface_update_attribute_region(mesh, surface, offset, data); });
	js_singleton.add((new std::string("mesh_surface_update_skin_region"))->c_str(), [singleton](const RID &mesh, int32_t surface, int32_t offset, const PackedByteArray &data) -> void { singleton->mesh_surface_update_skin_region(mesh, surface, offset, data); });
	js_singleton.add((new std::string("mesh_set_shadow_mesh"))->c_str(), [singleton](const RID &mesh, const RID &shadow_mesh) -> void { singleton->mesh_set_shadow_mesh(mesh, shadow_mesh); });
	js_singleton.add((new std::string("multimesh_create"))->c_str(), [singleton]() -> RID { return singleton->multimesh_create(); });
	js_singleton.add((new std::string("multimesh_allocate_data"))->c_str(), [singleton](const RID &multimesh, int32_t instances, RenderingServer::MultimeshTransformFormat transform_format, bool color_format, bool custom_data_format) -> void { singleton->multimesh_allocate_data(multimesh, instances, transform_format, color_format, custom_data_format); });
	js_singleton.add((new std::string("multimesh_get_instance_count"))->c_str(), [singleton](const RID &multimesh) -> int64_t { return singleton->multimesh_get_instance_count(multimesh); });
	js_singleton.add((new std::string("multimesh_set_mesh"))->c_str(), [singleton](const RID &multimesh, const RID &mesh) -> void { singleton->multimesh_set_mesh(multimesh, mesh); });
	js_singleton.add((new std::string("multimesh_instance_set_transform"))->c_str(), [singleton](const RID &multimesh, int32_t index, const Transform3D &transform) -> void { singleton->multimesh_instance_set_transform(multimesh, index, transform); });
	js_singleton.add((new std::string("multimesh_instance_set_transform_2d"))->c_str(), [singleton](const RID &multimesh, int32_t index, const Transform2D &transform) -> void { singleton->multimesh_instance_set_transform_2d(multimesh, index, transform); });
	js_singleton.add((new std::string("multimesh_instance_set_color"))->c_str(), [singleton](const RID &multimesh, int32_t index, const Color &color) -> void { singleton->multimesh_instance_set_color(multimesh, index, color); });
	js_singleton.add((new std::string("multimesh_instance_set_custom_data"))->c_str(), [singleton](const RID &multimesh, int32_t index, const Color &custom_data) -> void { singleton->multimesh_instance_set_custom_data(multimesh, index, custom_data); });
	js_singleton.add((new std::string("multimesh_get_mesh"))->c_str(), [singleton](const RID &multimesh) -> RID { return singleton->multimesh_get_mesh(multimesh); });
	js_singleton.add((new std::string("multimesh_get_aabb"))->c_str(), [singleton](const RID &multimesh) -> AABB { return singleton->multimesh_get_aabb(multimesh); });
	js_singleton.add((new std::string("multimesh_set_custom_aabb"))->c_str(), [singleton](const RID &multimesh, const AABB &aabb) -> void { singleton->multimesh_set_custom_aabb(multimesh, aabb); });
	js_singleton.add((new std::string("multimesh_get_custom_aabb"))->c_str(), [singleton](const RID &multimesh) -> AABB { return singleton->multimesh_get_custom_aabb(multimesh); });
	js_singleton.add((new std::string("multimesh_instance_get_transform"))->c_str(), [singleton](const RID &multimesh, int32_t index) -> Transform3D { return singleton->multimesh_instance_get_transform(multimesh, index); });
	js_singleton.add((new std::string("multimesh_instance_get_transform_2d"))->c_str(), [singleton](const RID &multimesh, int32_t index) -> Transform2D { return singleton->multimesh_instance_get_transform_2d(multimesh, index); });
	js_singleton.add((new std::string("multimesh_instance_get_color"))->c_str(), [singleton](const RID &multimesh, int32_t index) -> Color { return singleton->multimesh_instance_get_color(multimesh, index); });
	js_singleton.add((new std::string("multimesh_instance_get_custom_data"))->c_str(), [singleton](const RID &multimesh, int32_t index) -> Color { return singleton->multimesh_instance_get_custom_data(multimesh, index); });
	js_singleton.add((new std::string("multimesh_set_visible_instances"))->c_str(), [singleton](const RID &multimesh, int32_t visible) -> void { singleton->multimesh_set_visible_instances(multimesh, visible); });
	js_singleton.add((new std::string("multimesh_get_visible_instances"))->c_str(), [singleton](const RID &multimesh) -> int64_t { return singleton->multimesh_get_visible_instances(multimesh); });
	js_singleton.add((new std::string("multimesh_set_buffer"))->c_str(), [singleton](const RID &multimesh, const PackedFloat32Array &buffer) -> void { singleton->multimesh_set_buffer(multimesh, buffer); });
	js_singleton.add((new std::string("multimesh_get_buffer"))->c_str(), [singleton](const RID &multimesh) -> PackedFloat32Array { return singleton->multimesh_get_buffer(multimesh); });
	js_singleton.add((new std::string("skeleton_create"))->c_str(), [singleton]() -> RID { return singleton->skeleton_create(); });
	js_singleton.add((new std::string("skeleton_allocate_data"))->c_str(), [singleton](const RID &skeleton, int32_t bones, bool is_2d_skeleton) -> void { singleton->skeleton_allocate_data(skeleton, bones, is_2d_skeleton); });
	js_singleton.add((new std::string("skeleton_get_bone_count"))->c_str(), [singleton](const RID &skeleton) -> int64_t { return singleton->skeleton_get_bone_count(skeleton); });
	js_singleton.add((new std::string("skeleton_bone_set_transform"))->c_str(), [singleton](const RID &skeleton, int32_t bone, const Transform3D &transform) -> void { singleton->skeleton_bone_set_transform(skeleton, bone, transform); });
	js_singleton.add((new std::string("skeleton_bone_get_transform"))->c_str(), [singleton](const RID &skeleton, int32_t bone) -> Transform3D { return singleton->skeleton_bone_get_transform(skeleton, bone); });
	js_singleton.add((new std::string("skeleton_bone_set_transform_2d"))->c_str(), [singleton](const RID &skeleton, int32_t bone, const Transform2D &transform) -> void { singleton->skeleton_bone_set_transform_2d(skeleton, bone, transform); });
	js_singleton.add((new std::string("skeleton_bone_get_transform_2d"))->c_str(), [singleton](const RID &skeleton, int32_t bone) -> Transform2D { return singleton->skeleton_bone_get_transform_2d(skeleton, bone); });
	js_singleton.add((new std::string("skeleton_set_base_transform_2d"))->c_str(), [singleton](const RID &skeleton, const Transform2D &base_transform) -> void { singleton->skeleton_set_base_transform_2d(skeleton, base_transform); });
	js_singleton.add((new std::string("directional_light_create"))->c_str(), [singleton]() -> RID { return singleton->directional_light_create(); });
	js_singleton.add((new std::string("omni_light_create"))->c_str(), [singleton]() -> RID { return singleton->omni_light_create(); });
	js_singleton.add((new std::string("spot_light_create"))->c_str(), [singleton]() -> RID { return singleton->spot_light_create(); });
	js_singleton.add((new std::string("light_set_color"))->c_str(), [singleton](const RID &light, const Color &color) -> void { singleton->light_set_color(light, color); });
	js_singleton.add((new std::string("light_set_param"))->c_str(), [singleton](const RID &light, RenderingServer::LightParam param, double value) -> void { singleton->light_set_param(light, param, value); });
	js_singleton.add((new std::string("light_set_shadow"))->c_str(), [singleton](const RID &light, bool enabled) -> void { singleton->light_set_shadow(light, enabled); });
	js_singleton.add((new std::string("light_set_projector"))->c_str(), [singleton](const RID &light, const RID &texture) -> void { singleton->light_set_projector(light, texture); });
	js_singleton.add((new std::string("light_set_negative"))->c_str(), [singleton](const RID &light, bool enable) -> void { singleton->light_set_negative(light, enable); });
	js_singleton.add((new std::string("light_set_cull_mask"))->c_str(), [singleton](const RID &light, uint32_t mask) -> void { singleton->light_set_cull_mask(light, mask); });
	js_singleton.add((new std::string("light_set_distance_fade"))->c_str(), [singleton](const RID &decal, bool enabled, double begin, double shadow, double length) -> void { singleton->light_set_distance_fade(decal, enabled, begin, shadow, length); });
	js_singleton.add((new std::string("light_set_reverse_cull_face_mode"))->c_str(), [singleton](const RID &light, bool enabled) -> void { singleton->light_set_reverse_cull_face_mode(light, enabled); });
	js_singleton.add((new std::string("light_set_bake_mode"))->c_str(), [singleton](const RID &light, RenderingServer::LightBakeMode bake_mode) -> void { singleton->light_set_bake_mode(light, bake_mode); });
	js_singleton.add((new std::string("light_set_max_sdfgi_cascade"))->c_str(), [singleton](const RID &light, uint32_t cascade) -> void { singleton->light_set_max_sdfgi_cascade(light, cascade); });
	js_singleton.add((new std::string("light_omni_set_shadow_mode"))->c_str(), [singleton](const RID &light, RenderingServer::LightOmniShadowMode mode) -> void { singleton->light_omni_set_shadow_mode(light, mode); });
	js_singleton.add((new std::string("light_directional_set_shadow_mode"))->c_str(), [singleton](const RID &light, RenderingServer::LightDirectionalShadowMode mode) -> void { singleton->light_directional_set_shadow_mode(light, mode); });
	js_singleton.add((new std::string("light_directional_set_blend_splits"))->c_str(), [singleton](const RID &light, bool enable) -> void { singleton->light_directional_set_blend_splits(light, enable); });
	js_singleton.add((new std::string("light_directional_set_sky_mode"))->c_str(), [singleton](const RID &light, RenderingServer::LightDirectionalSkyMode mode) -> void { singleton->light_directional_set_sky_mode(light, mode); });
	js_singleton.add((new std::string("light_projectors_set_filter"))->c_str(), [singleton](RenderingServer::LightProjectorFilter filter) -> void { singleton->light_projectors_set_filter(filter); });
	js_singleton.add((new std::string("positional_soft_shadow_filter_set_quality"))->c_str(), [singleton](RenderingServer::ShadowQuality quality) -> void { singleton->positional_soft_shadow_filter_set_quality(quality); });
	js_singleton.add((new std::string("directional_soft_shadow_filter_set_quality"))->c_str(), [singleton](RenderingServer::ShadowQuality quality) -> void { singleton->directional_soft_shadow_filter_set_quality(quality); });
	js_singleton.add((new std::string("directional_shadow_atlas_set_size"))->c_str(), [singleton](int32_t size, bool is_16bits) -> void { singleton->directional_shadow_atlas_set_size(size, is_16bits); });
	js_singleton.add((new std::string("reflection_probe_create"))->c_str(), [singleton]() -> RID { return singleton->reflection_probe_create(); });
	js_singleton.add((new std::string("reflection_probe_set_update_mode"))->c_str(), [singleton](const RID &probe, RenderingServer::ReflectionProbeUpdateMode mode) -> void { singleton->reflection_probe_set_update_mode(probe, mode); });
	js_singleton.add((new std::string("reflection_probe_set_intensity"))->c_str(), [singleton](const RID &probe, double intensity) -> void { singleton->reflection_probe_set_intensity(probe, intensity); });
	js_singleton.add((new std::string("reflection_probe_set_ambient_mode"))->c_str(), [singleton](const RID &probe, RenderingServer::ReflectionProbeAmbientMode mode) -> void { singleton->reflection_probe_set_ambient_mode(probe, mode); });
	js_singleton.add((new std::string("reflection_probe_set_ambient_color"))->c_str(), [singleton](const RID &probe, const Color &color) -> void { singleton->reflection_probe_set_ambient_color(probe, color); });
	js_singleton.add((new std::string("reflection_probe_set_ambient_energy"))->c_str(), [singleton](const RID &probe, double energy) -> void { singleton->reflection_probe_set_ambient_energy(probe, energy); });
	js_singleton.add((new std::string("reflection_probe_set_max_distance"))->c_str(), [singleton](const RID &probe, double distance) -> void { singleton->reflection_probe_set_max_distance(probe, distance); });
	js_singleton.add((new std::string("reflection_probe_set_size"))->c_str(), [singleton](const RID &probe, const Vector3 &size) -> void { singleton->reflection_probe_set_size(probe, size); });
	js_singleton.add((new std::string("reflection_probe_set_origin_offset"))->c_str(), [singleton](const RID &probe, const Vector3 &offset) -> void { singleton->reflection_probe_set_origin_offset(probe, offset); });
	js_singleton.add((new std::string("reflection_probe_set_as_interior"))->c_str(), [singleton](const RID &probe, bool enable) -> void { singleton->reflection_probe_set_as_interior(probe, enable); });
	js_singleton.add((new std::string("reflection_probe_set_enable_box_projection"))->c_str(), [singleton](const RID &probe, bool enable) -> void { singleton->reflection_probe_set_enable_box_projection(probe, enable); });
	js_singleton.add((new std::string("reflection_probe_set_enable_shadows"))->c_str(), [singleton](const RID &probe, bool enable) -> void { singleton->reflection_probe_set_enable_shadows(probe, enable); });
	js_singleton.add((new std::string("reflection_probe_set_cull_mask"))->c_str(), [singleton](const RID &probe, uint32_t layers) -> void { singleton->reflection_probe_set_cull_mask(probe, layers); });
	js_singleton.add((new std::string("reflection_probe_set_reflection_mask"))->c_str(), [singleton](const RID &probe, uint32_t layers) -> void { singleton->reflection_probe_set_reflection_mask(probe, layers); });
	js_singleton.add((new std::string("reflection_probe_set_resolution"))->c_str(), [singleton](const RID &probe, int32_t resolution) -> void { singleton->reflection_probe_set_resolution(probe, resolution); });
	js_singleton.add((new std::string("reflection_probe_set_mesh_lod_threshold"))->c_str(), [singleton](const RID &probe, double pixels) -> void { singleton->reflection_probe_set_mesh_lod_threshold(probe, pixels); });
	js_singleton.add((new std::string("decal_create"))->c_str(), [singleton]() -> RID { return singleton->decal_create(); });
	js_singleton.add((new std::string("decal_set_size"))->c_str(), [singleton](const RID &decal, const Vector3 &size) -> void { singleton->decal_set_size(decal, size); });
	js_singleton.add((new std::string("decal_set_texture"))->c_str(), [singleton](const RID &decal, RenderingServer::DecalTexture type, const RID &texture) -> void { singleton->decal_set_texture(decal, type, texture); });
	js_singleton.add((new std::string("decal_set_emission_energy"))->c_str(), [singleton](const RID &decal, double energy) -> void { singleton->decal_set_emission_energy(decal, energy); });
	js_singleton.add((new std::string("decal_set_albedo_mix"))->c_str(), [singleton](const RID &decal, double albedo_mix) -> void { singleton->decal_set_albedo_mix(decal, albedo_mix); });
	js_singleton.add((new std::string("decal_set_modulate"))->c_str(), [singleton](const RID &decal, const Color &color) -> void { singleton->decal_set_modulate(decal, color); });
	js_singleton.add((new std::string("decal_set_cull_mask"))->c_str(), [singleton](const RID &decal, uint32_t mask) -> void { singleton->decal_set_cull_mask(decal, mask); });
	js_singleton.add((new std::string("decal_set_distance_fade"))->c_str(), [singleton](const RID &decal, bool enabled, double begin, double length) -> void { singleton->decal_set_distance_fade(decal, enabled, begin, length); });
	js_singleton.add((new std::string("decal_set_fade"))->c_str(), [singleton](const RID &decal, double above, double below) -> void { singleton->decal_set_fade(decal, above, below); });
	js_singleton.add((new std::string("decal_set_normal_fade"))->c_str(), [singleton](const RID &decal, double fade) -> void { singleton->decal_set_normal_fade(decal, fade); });
	js_singleton.add((new std::string("decals_set_filter"))->c_str(), [singleton](RenderingServer::DecalFilter filter) -> void { singleton->decals_set_filter(filter); });
	js_singleton.add((new std::string("gi_set_use_half_resolution"))->c_str(), [singleton](bool half_resolution) -> void { singleton->gi_set_use_half_resolution(half_resolution); });
	js_singleton.add((new std::string("voxel_gi_create"))->c_str(), [singleton]() -> RID { return singleton->voxel_gi_create(); });
	js_singleton.add((new std::string("voxel_gi_allocate_data"))->c_str(), [singleton](const RID &voxel_gi, const Transform3D &to_cell_xform, const AABB &aabb, const Vector3i &octree_size, const PackedByteArray &octree_cells, const PackedByteArray &data_cells, const PackedByteArray &distance_field, const PackedInt32Array &level_counts) -> void { singleton->voxel_gi_allocate_data(voxel_gi, to_cell_xform, aabb, octree_size, octree_cells, data_cells, distance_field, level_counts); });
	js_singleton.add((new std::string("voxel_gi_get_octree_size"))->c_str(), [singleton](const RID &voxel_gi) -> Vector3i { return singleton->voxel_gi_get_octree_size(voxel_gi); });
	js_singleton.add((new std::string("voxel_gi_get_octree_cells"))->c_str(), [singleton](const RID &voxel_gi) -> PackedByteArray { return singleton->voxel_gi_get_octree_cells(voxel_gi); });
	js_singleton.add((new std::string("voxel_gi_get_data_cells"))->c_str(), [singleton](const RID &voxel_gi) -> PackedByteArray { return singleton->voxel_gi_get_data_cells(voxel_gi); });
	js_singleton.add((new std::string("voxel_gi_get_distance_field"))->c_str(), [singleton](const RID &voxel_gi) -> PackedByteArray { return singleton->voxel_gi_get_distance_field(voxel_gi); });
	js_singleton.add((new std::string("voxel_gi_get_level_counts"))->c_str(), [singleton](const RID &voxel_gi) -> PackedInt32Array { return singleton->voxel_gi_get_level_counts(voxel_gi); });
	js_singleton.add((new std::string("voxel_gi_get_to_cell_xform"))->c_str(), [singleton](const RID &voxel_gi) -> Transform3D { return singleton->voxel_gi_get_to_cell_xform(voxel_gi); });
	js_singleton.add((new std::string("voxel_gi_set_dynamic_range"))->c_str(), [singleton](const RID &voxel_gi, double range) -> void { singleton->voxel_gi_set_dynamic_range(voxel_gi, range); });
	js_singleton.add((new std::string("voxel_gi_set_propagation"))->c_str(), [singleton](const RID &voxel_gi, double amount) -> void { singleton->voxel_gi_set_propagation(voxel_gi, amount); });
	js_singleton.add((new std::string("voxel_gi_set_energy"))->c_str(), [singleton](const RID &voxel_gi, double energy) -> void { singleton->voxel_gi_set_energy(voxel_gi, energy); });
	js_singleton.add((new std::string("voxel_gi_set_baked_exposure_normalization"))->c_str(), [singleton](const RID &voxel_gi, double baked_exposure) -> void { singleton->voxel_gi_set_baked_exposure_normalization(voxel_gi, baked_exposure); });
	js_singleton.add((new std::string("voxel_gi_set_bias"))->c_str(), [singleton](const RID &voxel_gi, double bias) -> void { singleton->voxel_gi_set_bias(voxel_gi, bias); });
	js_singleton.add((new std::string("voxel_gi_set_normal_bias"))->c_str(), [singleton](const RID &voxel_gi, double bias) -> void { singleton->voxel_gi_set_normal_bias(voxel_gi, bias); });
	js_singleton.add((new std::string("voxel_gi_set_interior"))->c_str(), [singleton](const RID &voxel_gi, bool enable) -> void { singleton->voxel_gi_set_interior(voxel_gi, enable); });
	js_singleton.add((new std::string("voxel_gi_set_use_two_bounces"))->c_str(), [singleton](const RID &voxel_gi, bool enable) -> void { singleton->voxel_gi_set_use_two_bounces(voxel_gi, enable); });
	js_singleton.add((new std::string("voxel_gi_set_quality"))->c_str(), [singleton](RenderingServer::VoxelGIQuality quality) -> void { singleton->voxel_gi_set_quality(quality); });
	js_singleton.add((new std::string("lightmap_create"))->c_str(), [singleton]() -> RID { return singleton->lightmap_create(); });
	js_singleton.add((new std::string("lightmap_set_textures"))->c_str(), [singleton](const RID &lightmap, const RID &light, bool uses_sh) -> void { singleton->lightmap_set_textures(lightmap, light, uses_sh); });
	js_singleton.add((new std::string("lightmap_set_probe_bounds"))->c_str(), [singleton](const RID &lightmap, const AABB &bounds) -> void { singleton->lightmap_set_probe_bounds(lightmap, bounds); });
	js_singleton.add((new std::string("lightmap_set_probe_interior"))->c_str(), [singleton](const RID &lightmap, bool interior) -> void { singleton->lightmap_set_probe_interior(lightmap, interior); });
	js_singleton.add((new std::string("lightmap_set_probe_capture_data"))->c_str(), [singleton](const RID &lightmap, const PackedVector3Array &points, const PackedColorArray &point_sh, const PackedInt32Array &tetrahedra, const PackedInt32Array &bsp_tree) -> void { singleton->lightmap_set_probe_capture_data(lightmap, points, point_sh, tetrahedra, bsp_tree); });
	js_singleton.add((new std::string("lightmap_get_probe_capture_points"))->c_str(), [singleton](const RID &lightmap) -> PackedVector3Array { return singleton->lightmap_get_probe_capture_points(lightmap); });
	js_singleton.add((new std::string("lightmap_get_probe_capture_sh"))->c_str(), [singleton](const RID &lightmap) -> PackedColorArray { return singleton->lightmap_get_probe_capture_sh(lightmap); });
	js_singleton.add((new std::string("lightmap_get_probe_capture_tetrahedra"))->c_str(), [singleton](const RID &lightmap) -> PackedInt32Array { return singleton->lightmap_get_probe_capture_tetrahedra(lightmap); });
	js_singleton.add((new std::string("lightmap_get_probe_capture_bsp_tree"))->c_str(), [singleton](const RID &lightmap) -> PackedInt32Array { return singleton->lightmap_get_probe_capture_bsp_tree(lightmap); });
	js_singleton.add((new std::string("lightmap_set_baked_exposure_normalization"))->c_str(), [singleton](const RID &lightmap, double baked_exposure) -> void { singleton->lightmap_set_baked_exposure_normalization(lightmap, baked_exposure); });
	js_singleton.add((new std::string("lightmap_set_probe_capture_update_speed"))->c_str(), [singleton](double speed) -> void { singleton->lightmap_set_probe_capture_update_speed(speed); });
	js_singleton.add((new std::string("particles_create"))->c_str(), [singleton]() -> RID { return singleton->particles_create(); });
	js_singleton.add((new std::string("particles_set_mode"))->c_str(), [singleton](const RID &particles, RenderingServer::ParticlesMode mode) -> void { singleton->particles_set_mode(particles, mode); });
	js_singleton.add((new std::string("particles_set_emitting"))->c_str(), [singleton](const RID &particles, bool emitting) -> void { singleton->particles_set_emitting(particles, emitting); });
	js_singleton.add((new std::string("particles_get_emitting"))->c_str(), [singleton](const RID &particles) -> bool { return singleton->particles_get_emitting(particles); });
	js_singleton.add((new std::string("particles_set_amount"))->c_str(), [singleton](const RID &particles, int32_t amount) -> void { singleton->particles_set_amount(particles, amount); });
	js_singleton.add((new std::string("particles_set_amount_ratio"))->c_str(), [singleton](const RID &particles, double ratio) -> void { singleton->particles_set_amount_ratio(particles, ratio); });
	js_singleton.add((new std::string("particles_set_lifetime"))->c_str(), [singleton](const RID &particles, double lifetime) -> void { singleton->particles_set_lifetime(particles, lifetime); });
	js_singleton.add((new std::string("particles_set_one_shot"))->c_str(), [singleton](const RID &particles, bool one_shot) -> void { singleton->particles_set_one_shot(particles, one_shot); });
	js_singleton.add((new std::string("particles_set_pre_process_time"))->c_str(), [singleton](const RID &particles, double time) -> void { singleton->particles_set_pre_process_time(particles, time); });
	js_singleton.add((new std::string("particles_set_explosiveness_ratio"))->c_str(), [singleton](const RID &particles, double ratio) -> void { singleton->particles_set_explosiveness_ratio(particles, ratio); });
	js_singleton.add((new std::string("particles_set_randomness_ratio"))->c_str(), [singleton](const RID &particles, double ratio) -> void { singleton->particles_set_randomness_ratio(particles, ratio); });
	js_singleton.add((new std::string("particles_set_interp_to_end"))->c_str(), [singleton](const RID &particles, double factor) -> void { singleton->particles_set_interp_to_end(particles, factor); });
	js_singleton.add((new std::string("particles_set_emitter_velocity"))->c_str(), [singleton](const RID &particles, const Vector3 &velocity) -> void { singleton->particles_set_emitter_velocity(particles, velocity); });
	js_singleton.add((new std::string("particles_set_custom_aabb"))->c_str(), [singleton](const RID &particles, const AABB &aabb) -> void { singleton->particles_set_custom_aabb(particles, aabb); });
	js_singleton.add((new std::string("particles_set_speed_scale"))->c_str(), [singleton](const RID &particles, double scale) -> void { singleton->particles_set_speed_scale(particles, scale); });
	js_singleton.add((new std::string("particles_set_use_local_coordinates"))->c_str(), [singleton](const RID &particles, bool enable) -> void { singleton->particles_set_use_local_coordinates(particles, enable); });
	js_singleton.add((new std::string("particles_set_process_material"))->c_str(), [singleton](const RID &particles, const RID &material) -> void { singleton->particles_set_process_material(particles, material); });
	js_singleton.add((new std::string("particles_set_fixed_fps"))->c_str(), [singleton](const RID &particles, int32_t fps) -> void { singleton->particles_set_fixed_fps(particles, fps); });
	js_singleton.add((new std::string("particles_set_interpolate"))->c_str(), [singleton](const RID &particles, bool enable) -> void { singleton->particles_set_interpolate(particles, enable); });
	js_singleton.add((new std::string("particles_set_fractional_delta"))->c_str(), [singleton](const RID &particles, bool enable) -> void { singleton->particles_set_fractional_delta(particles, enable); });
	js_singleton.add((new std::string("particles_set_collision_base_size"))->c_str(), [singleton](const RID &particles, double size) -> void { singleton->particles_set_collision_base_size(particles, size); });
	js_singleton.add((new std::string("particles_set_transform_align"))->c_str(), [singleton](const RID &particles, RenderingServer::ParticlesTransformAlign align) -> void { singleton->particles_set_transform_align(particles, align); });
	js_singleton.add((new std::string("particles_set_trails"))->c_str(), [singleton](const RID &particles, bool enable, double length_sec) -> void { singleton->particles_set_trails(particles, enable, length_sec); });
	js_singleton.add((new std::string("particles_set_trail_bind_poses"))->c_str(), [singleton](const RID &particles, const TypedArray<Transform3D> &bind_poses) -> void { singleton->particles_set_trail_bind_poses(particles, bind_poses); });
	js_singleton.add((new std::string("particles_is_inactive"))->c_str(), [singleton](const RID &particles) -> bool { return singleton->particles_is_inactive(particles); });
	js_singleton.add((new std::string("particles_request_process"))->c_str(), [singleton](const RID &particles) -> void { singleton->particles_request_process(particles); });
	js_singleton.add((new std::string("particles_restart"))->c_str(), [singleton](const RID &particles) -> void { singleton->particles_restart(particles); });
	js_singleton.add((new std::string("particles_set_subemitter"))->c_str(), [singleton](const RID &particles, const RID &subemitter_particles) -> void { singleton->particles_set_subemitter(particles, subemitter_particles); });
	js_singleton.add((new std::string("particles_emit"))->c_str(), [singleton](const RID &particles, const Transform3D &transform, const Vector3 &velocity, const Color &color, const Color &custom, uint32_t emit_flags) -> void { singleton->particles_emit(particles, transform, velocity, color, custom, emit_flags); });
	js_singleton.add((new std::string("particles_set_draw_order"))->c_str(), [singleton](const RID &particles, RenderingServer::ParticlesDrawOrder order) -> void { singleton->particles_set_draw_order(particles, order); });
	js_singleton.add((new std::string("particles_set_draw_passes"))->c_str(), [singleton](const RID &particles, int32_t count) -> void { singleton->particles_set_draw_passes(particles, count); });
	js_singleton.add((new std::string("particles_set_draw_pass_mesh"))->c_str(), [singleton](const RID &particles, int32_t pass, const RID &mesh) -> void { singleton->particles_set_draw_pass_mesh(particles, pass, mesh); });
	js_singleton.add((new std::string("particles_get_current_aabb"))->c_str(), [singleton](const RID &particles) -> AABB { return singleton->particles_get_current_aabb(particles); });
	js_singleton.add((new std::string("particles_set_emission_transform"))->c_str(), [singleton](const RID &particles, const Transform3D &transform) -> void { singleton->particles_set_emission_transform(particles, transform); });
	js_singleton.add((new std::string("particles_collision_create"))->c_str(), [singleton]() -> RID { return singleton->particles_collision_create(); });
	js_singleton.add((new std::string("particles_collision_set_collision_type"))->c_str(), [singleton](const RID &particles_collision, RenderingServer::ParticlesCollisionType type) -> void { singleton->particles_collision_set_collision_type(particles_collision, type); });
	js_singleton.add((new std::string("particles_collision_set_cull_mask"))->c_str(), [singleton](const RID &particles_collision, uint32_t mask) -> void { singleton->particles_collision_set_cull_mask(particles_collision, mask); });
	js_singleton.add((new std::string("particles_collision_set_sphere_radius"))->c_str(), [singleton](const RID &particles_collision, double radius) -> void { singleton->particles_collision_set_sphere_radius(particles_collision, radius); });
	js_singleton.add((new std::string("particles_collision_set_box_extents"))->c_str(), [singleton](const RID &particles_collision, const Vector3 &extents) -> void { singleton->particles_collision_set_box_extents(particles_collision, extents); });
	js_singleton.add((new std::string("particles_collision_set_attractor_strength"))->c_str(), [singleton](const RID &particles_collision, double strength) -> void { singleton->particles_collision_set_attractor_strength(particles_collision, strength); });
	js_singleton.add((new std::string("particles_collision_set_attractor_directionality"))->c_str(), [singleton](const RID &particles_collision, double amount) -> void { singleton->particles_collision_set_attractor_directionality(particles_collision, amount); });
	js_singleton.add((new std::string("particles_collision_set_attractor_attenuation"))->c_str(), [singleton](const RID &particles_collision, double curve) -> void { singleton->particles_collision_set_attractor_attenuation(particles_collision, curve); });
	js_singleton.add((new std::string("particles_collision_set_field_texture"))->c_str(), [singleton](const RID &particles_collision, const RID &texture) -> void { singleton->particles_collision_set_field_texture(particles_collision, texture); });
	js_singleton.add((new std::string("particles_collision_height_field_update"))->c_str(), [singleton](const RID &particles_collision) -> void { singleton->particles_collision_height_field_update(particles_collision); });
	js_singleton.add((new std::string("particles_collision_set_height_field_resolution"))->c_str(), [singleton](const RID &particles_collision, RenderingServer::ParticlesCollisionHeightfieldResolution resolution) -> void { singleton->particles_collision_set_height_field_resolution(particles_collision, resolution); });
	js_singleton.add((new std::string("fog_volume_create"))->c_str(), [singleton]() -> RID { return singleton->fog_volume_create(); });
	js_singleton.add((new std::string("fog_volume_set_shape"))->c_str(), [singleton](const RID &fog_volume, RenderingServer::FogVolumeShape shape) -> void { singleton->fog_volume_set_shape(fog_volume, shape); });
	js_singleton.add((new std::string("fog_volume_set_size"))->c_str(), [singleton](const RID &fog_volume, const Vector3 &size) -> void { singleton->fog_volume_set_size(fog_volume, size); });
	js_singleton.add((new std::string("fog_volume_set_material"))->c_str(), [singleton](const RID &fog_volume, const RID &material) -> void { singleton->fog_volume_set_material(fog_volume, material); });
	js_singleton.add((new std::string("visibility_notifier_create"))->c_str(), [singleton]() -> RID { return singleton->visibility_notifier_create(); });
	js_singleton.add((new std::string("visibility_notifier_set_aabb"))->c_str(), [singleton](const RID &notifier, const AABB &aabb) -> void { singleton->visibility_notifier_set_aabb(notifier, aabb); });
	js_singleton.add((new std::string("visibility_notifier_set_callbacks"))->c_str(), [singleton](const RID &notifier, const Callable &enter_callable, const Callable &exit_callable) -> void { singleton->visibility_notifier_set_callbacks(notifier, enter_callable, exit_callable); });
	js_singleton.add((new std::string("occluder_create"))->c_str(), [singleton]() -> RID { return singleton->occluder_create(); });
	js_singleton.add((new std::string("occluder_set_mesh"))->c_str(), [singleton](const RID &occluder, const PackedVector3Array &vertices, const PackedInt32Array &indices) -> void { singleton->occluder_set_mesh(occluder, vertices, indices); });
	js_singleton.add((new std::string("camera_create"))->c_str(), [singleton]() -> RID { return singleton->camera_create(); });
	js_singleton.add((new std::string("camera_set_perspective"))->c_str(), [singleton](const RID &camera, double fovy_degrees, double z_near, double z_far) -> void { singleton->camera_set_perspective(camera, fovy_degrees, z_near, z_far); });
	js_singleton.add((new std::string("camera_set_orthogonal"))->c_str(), [singleton](const RID &camera, double size, double z_near, double z_far) -> void { singleton->camera_set_orthogonal(camera, size, z_near, z_far); });
	js_singleton.add((new std::string("camera_set_frustum"))->c_str(), [singleton](const RID &camera, double size, const Vector2 &offset, double z_near, double z_far) -> void { singleton->camera_set_frustum(camera, size, offset, z_near, z_far); });
	js_singleton.add((new std::string("camera_set_transform"))->c_str(), [singleton](const RID &camera, const Transform3D &transform) -> void { singleton->camera_set_transform(camera, transform); });
	js_singleton.add((new std::string("camera_set_cull_mask"))->c_str(), [singleton](const RID &camera, uint32_t layers) -> void { singleton->camera_set_cull_mask(camera, layers); });
	js_singleton.add((new std::string("camera_set_environment"))->c_str(), [singleton](const RID &camera, const RID &env) -> void { singleton->camera_set_environment(camera, env); });
	js_singleton.add((new std::string("camera_set_camera_attributes"))->c_str(), [singleton](const RID &camera, const RID &effects) -> void { singleton->camera_set_camera_attributes(camera, effects); });
	js_singleton.add((new std::string("camera_set_compositor"))->c_str(), [singleton](const RID &camera, const RID &compositor) -> void { singleton->camera_set_compositor(camera, compositor); });
	js_singleton.add((new std::string("camera_set_use_vertical_aspect"))->c_str(), [singleton](const RID &camera, bool enable) -> void { singleton->camera_set_use_vertical_aspect(camera, enable); });
	js_singleton.add((new std::string("viewport_create"))->c_str(), [singleton]() -> RID { return singleton->viewport_create(); });
	js_singleton.add((new std::string("viewport_set_use_xr"))->c_str(), [singleton](const RID &viewport, bool use_xr) -> void { singleton->viewport_set_use_xr(viewport, use_xr); });
	js_singleton.add((new std::string("viewport_set_size"))->c_str(), [singleton](const RID &viewport, int32_t width, int32_t height) -> void { singleton->viewport_set_size(viewport, width, height); });
	js_singleton.add((new std::string("viewport_set_active"))->c_str(), [singleton](const RID &viewport, bool active) -> void { singleton->viewport_set_active(viewport, active); });
	js_singleton.add((new std::string("viewport_set_parent_viewport"))->c_str(), [singleton](const RID &viewport, const RID &parent_viewport) -> void { singleton->viewport_set_parent_viewport(viewport, parent_viewport); });
	js_singleton.add((new std::string("viewport_attach_to_screen"))->c_str(), [singleton](const RID &viewport, const Rect2 &rect, int32_t screen) -> void { singleton->viewport_attach_to_screen(viewport, rect, screen); });
	js_singleton.add((new std::string("viewport_set_render_direct_to_screen"))->c_str(), [singleton](const RID &viewport, bool enabled) -> void { singleton->viewport_set_render_direct_to_screen(viewport, enabled); });
	js_singleton.add((new std::string("viewport_set_canvas_cull_mask"))->c_str(), [singleton](const RID &viewport, uint32_t canvas_cull_mask) -> void { singleton->viewport_set_canvas_cull_mask(viewport, canvas_cull_mask); });
	js_singleton.add((new std::string("viewport_set_scaling_3d_mode"))->c_str(), [singleton](const RID &viewport, RenderingServer::ViewportScaling3DMode scaling_3d_mode) -> void { singleton->viewport_set_scaling_3d_mode(viewport, scaling_3d_mode); });
	js_singleton.add((new std::string("viewport_set_scaling_3d_scale"))->c_str(), [singleton](const RID &viewport, double scale) -> void { singleton->viewport_set_scaling_3d_scale(viewport, scale); });
	js_singleton.add((new std::string("viewport_set_fsr_sharpness"))->c_str(), [singleton](const RID &viewport, double sharpness) -> void { singleton->viewport_set_fsr_sharpness(viewport, sharpness); });
	js_singleton.add((new std::string("viewport_set_texture_mipmap_bias"))->c_str(), [singleton](const RID &viewport, double mipmap_bias) -> void { singleton->viewport_set_texture_mipmap_bias(viewport, mipmap_bias); });
	js_singleton.add((new std::string("viewport_set_update_mode"))->c_str(), [singleton](const RID &viewport, RenderingServer::ViewportUpdateMode update_mode) -> void { singleton->viewport_set_update_mode(viewport, update_mode); });
	js_singleton.add((new std::string("viewport_get_update_mode"))->c_str(), [singleton](const RID &viewport) -> RenderingServer::ViewportUpdateMode { return singleton->viewport_get_update_mode(viewport); });
	js_singleton.add((new std::string("viewport_set_clear_mode"))->c_str(), [singleton](const RID &viewport, RenderingServer::ViewportClearMode clear_mode) -> void { singleton->viewport_set_clear_mode(viewport, clear_mode); });
	js_singleton.add((new std::string("viewport_get_render_target"))->c_str(), [singleton](const RID &viewport) -> RID { return singleton->viewport_get_render_target(viewport); });
	js_singleton.add((new std::string("viewport_get_texture"))->c_str(), [singleton](const RID &viewport) -> RID { return singleton->viewport_get_texture(viewport); });
	js_singleton.add((new std::string("viewport_set_disable_3d"))->c_str(), [singleton](const RID &viewport, bool disable) -> void { singleton->viewport_set_disable_3d(viewport, disable); });
	js_singleton.add((new std::string("viewport_set_disable_2d"))->c_str(), [singleton](const RID &viewport, bool disable) -> void { singleton->viewport_set_disable_2d(viewport, disable); });
	js_singleton.add((new std::string("viewport_set_environment_mode"))->c_str(), [singleton](const RID &viewport, RenderingServer::ViewportEnvironmentMode mode) -> void { singleton->viewport_set_environment_mode(viewport, mode); });
	js_singleton.add((new std::string("viewport_attach_camera"))->c_str(), [singleton](const RID &viewport, const RID &camera) -> void { singleton->viewport_attach_camera(viewport, camera); });
	js_singleton.add((new std::string("viewport_set_scenario"))->c_str(), [singleton](const RID &viewport, const RID &scenario) -> void { singleton->viewport_set_scenario(viewport, scenario); });
	js_singleton.add((new std::string("viewport_attach_canvas"))->c_str(), [singleton](const RID &viewport, const RID &canvas) -> void { singleton->viewport_attach_canvas(viewport, canvas); });
	js_singleton.add((new std::string("viewport_remove_canvas"))->c_str(), [singleton](const RID &viewport, const RID &canvas) -> void { singleton->viewport_remove_canvas(viewport, canvas); });
	js_singleton.add((new std::string("viewport_set_snap_2d_transforms_to_pixel"))->c_str(), [singleton](const RID &viewport, bool enabled) -> void { singleton->viewport_set_snap_2d_transforms_to_pixel(viewport, enabled); });
	js_singleton.add((new std::string("viewport_set_snap_2d_vertices_to_pixel"))->c_str(), [singleton](const RID &viewport, bool enabled) -> void { singleton->viewport_set_snap_2d_vertices_to_pixel(viewport, enabled); });
	js_singleton.add((new std::string("viewport_set_default_canvas_item_texture_filter"))->c_str(), [singleton](const RID &viewport, RenderingServer::CanvasItemTextureFilter filter) -> void { singleton->viewport_set_default_canvas_item_texture_filter(viewport, filter); });
	js_singleton.add((new std::string("viewport_set_default_canvas_item_texture_repeat"))->c_str(), [singleton](const RID &viewport, RenderingServer::CanvasItemTextureRepeat repeat) -> void { singleton->viewport_set_default_canvas_item_texture_repeat(viewport, repeat); });
	js_singleton.add((new std::string("viewport_set_canvas_transform"))->c_str(), [singleton](const RID &viewport, const RID &canvas, const Transform2D &offset) -> void { singleton->viewport_set_canvas_transform(viewport, canvas, offset); });
	js_singleton.add((new std::string("viewport_set_canvas_stacking"))->c_str(), [singleton](const RID &viewport, const RID &canvas, int32_t layer, int32_t sublayer) -> void { singleton->viewport_set_canvas_stacking(viewport, canvas, layer, sublayer); });
	js_singleton.add((new std::string("viewport_set_transparent_background"))->c_str(), [singleton](const RID &viewport, bool enabled) -> void { singleton->viewport_set_transparent_background(viewport, enabled); });
	js_singleton.add((new std::string("viewport_set_global_canvas_transform"))->c_str(), [singleton](const RID &viewport, const Transform2D &transform) -> void { singleton->viewport_set_global_canvas_transform(viewport, transform); });
	js_singleton.add((new std::string("viewport_set_sdf_oversize_and_scale"))->c_str(), [singleton](const RID &viewport, RenderingServer::ViewportSDFOversize oversize, RenderingServer::ViewportSDFScale scale) -> void { singleton->viewport_set_sdf_oversize_and_scale(viewport, oversize, scale); });
	js_singleton.add((new std::string("viewport_set_positional_shadow_atlas_size"))->c_str(), [singleton](const RID &viewport, int32_t size, bool use_16_bits) -> void { singleton->viewport_set_positional_shadow_atlas_size(viewport, size, use_16_bits); });
	js_singleton.add((new std::string("viewport_set_positional_shadow_atlas_quadrant_subdivision"))->c_str(), [singleton](const RID &viewport, int32_t quadrant, int32_t subdivision) -> void { singleton->viewport_set_positional_shadow_atlas_quadrant_subdivision(viewport, quadrant, subdivision); });
	js_singleton.add((new std::string("viewport_set_msaa_3d"))->c_str(), [singleton](const RID &viewport, RenderingServer::ViewportMSAA msaa) -> void { singleton->viewport_set_msaa_3d(viewport, msaa); });
	js_singleton.add((new std::string("viewport_set_msaa_2d"))->c_str(), [singleton](const RID &viewport, RenderingServer::ViewportMSAA msaa) -> void { singleton->viewport_set_msaa_2d(viewport, msaa); });
	js_singleton.add((new std::string("viewport_set_use_hdr_2d"))->c_str(), [singleton](const RID &viewport, bool enabled) -> void { singleton->viewport_set_use_hdr_2d(viewport, enabled); });
	js_singleton.add((new std::string("viewport_set_screen_space_aa"))->c_str(), [singleton](const RID &viewport, RenderingServer::ViewportScreenSpaceAA mode) -> void { singleton->viewport_set_screen_space_aa(viewport, mode); });
	js_singleton.add((new std::string("viewport_set_use_taa"))->c_str(), [singleton](const RID &viewport, bool enable) -> void { singleton->viewport_set_use_taa(viewport, enable); });
	js_singleton.add((new std::string("viewport_set_use_debanding"))->c_str(), [singleton](const RID &viewport, bool enable) -> void { singleton->viewport_set_use_debanding(viewport, enable); });
	js_singleton.add((new std::string("viewport_set_use_occlusion_culling"))->c_str(), [singleton](const RID &viewport, bool enable) -> void { singleton->viewport_set_use_occlusion_culling(viewport, enable); });
	js_singleton.add((new std::string("viewport_set_occlusion_rays_per_thread"))->c_str(), [singleton](int32_t rays_per_thread) -> void { singleton->viewport_set_occlusion_rays_per_thread(rays_per_thread); });
	js_singleton.add((new std::string("viewport_set_occlusion_culling_build_quality"))->c_str(), [singleton](RenderingServer::ViewportOcclusionCullingBuildQuality quality) -> void { singleton->viewport_set_occlusion_culling_build_quality(quality); });
	js_singleton.add((new std::string("viewport_get_render_info"))->c_str(), [singleton](const RID &viewport, RenderingServer::ViewportRenderInfoType type, RenderingServer::ViewportRenderInfo info) -> int64_t { return singleton->viewport_get_render_info(viewport, type, info); });
	js_singleton.add((new std::string("viewport_set_debug_draw"))->c_str(), [singleton](const RID &viewport, RenderingServer::ViewportDebugDraw draw) -> void { singleton->viewport_set_debug_draw(viewport, draw); });
	js_singleton.add((new std::string("viewport_set_measure_render_time"))->c_str(), [singleton](const RID &viewport, bool enable) -> void { singleton->viewport_set_measure_render_time(viewport, enable); });
	js_singleton.add((new std::string("viewport_get_measured_render_time_cpu"))->c_str(), [singleton](const RID &viewport) -> double { return singleton->viewport_get_measured_render_time_cpu(viewport); });
	js_singleton.add((new std::string("viewport_get_measured_render_time_gpu"))->c_str(), [singleton](const RID &viewport) -> double { return singleton->viewport_get_measured_render_time_gpu(viewport); });
	js_singleton.add((new std::string("viewport_set_vrs_mode"))->c_str(), [singleton](const RID &viewport, RenderingServer::ViewportVRSMode mode) -> void { singleton->viewport_set_vrs_mode(viewport, mode); });
	js_singleton.add((new std::string("viewport_set_vrs_update_mode"))->c_str(), [singleton](const RID &viewport, RenderingServer::ViewportVRSUpdateMode mode) -> void { singleton->viewport_set_vrs_update_mode(viewport, mode); });
	js_singleton.add((new std::string("viewport_set_vrs_texture"))->c_str(), [singleton](const RID &viewport, const RID &texture) -> void { singleton->viewport_set_vrs_texture(viewport, texture); });
	js_singleton.add((new std::string("sky_create"))->c_str(), [singleton]() -> RID { return singleton->sky_create(); });
	js_singleton.add((new std::string("sky_set_radiance_size"))->c_str(), [singleton](const RID &sky, int32_t radiance_size) -> void { singleton->sky_set_radiance_size(sky, radiance_size); });
	js_singleton.add((new std::string("sky_set_mode"))->c_str(), [singleton](const RID &sky, RenderingServer::SkyMode mode) -> void { singleton->sky_set_mode(sky, mode); });
	js_singleton.add((new std::string("sky_set_material"))->c_str(), [singleton](const RID &sky, const RID &material) -> void { singleton->sky_set_material(sky, material); });
	js_singleton.add((new std::string("sky_bake_panorama"))->c_str(), [singleton](const RID &sky, double energy, bool bake_irradiance, const Vector2i &size) -> Ref<Image> { return singleton->sky_bake_panorama(sky, energy, bake_irradiance, size); });
	js_singleton.add((new std::string("compositor_effect_create"))->c_str(), [singleton]() -> RID { return singleton->compositor_effect_create(); });
	js_singleton.add((new std::string("compositor_effect_set_enabled"))->c_str(), [singleton](const RID &effect, bool enabled) -> void { singleton->compositor_effect_set_enabled(effect, enabled); });
	js_singleton.add((new std::string("compositor_effect_set_callback"))->c_str(), [singleton](const RID &effect, RenderingServer::CompositorEffectCallbackType callback_type, const Callable &callback) -> void { singleton->compositor_effect_set_callback(effect, callback_type, callback); });
	js_singleton.add((new std::string("compositor_effect_set_flag"))->c_str(), [singleton](const RID &effect, RenderingServer::CompositorEffectFlags flag, bool set) -> void { singleton->compositor_effect_set_flag(effect, flag, set); });
	js_singleton.add((new std::string("compositor_create"))->c_str(), [singleton]() -> RID { return singleton->compositor_create(); });
	js_singleton.add((new std::string("compositor_set_compositor_effects"))->c_str(), [singleton](const RID &compositor, const TypedArray<RID> &effects) -> void { singleton->compositor_set_compositor_effects(compositor, effects); });
	js_singleton.add((new std::string("environment_create"))->c_str(), [singleton]() -> RID { return singleton->environment_create(); });
	js_singleton.add((new std::string("environment_set_background"))->c_str(), [singleton](const RID &env, RenderingServer::EnvironmentBG bg) -> void { singleton->environment_set_background(env, bg); });
	js_singleton.add((new std::string("environment_set_sky"))->c_str(), [singleton](const RID &env, const RID &sky) -> void { singleton->environment_set_sky(env, sky); });
	js_singleton.add((new std::string("environment_set_sky_custom_fov"))->c_str(), [singleton](const RID &env, double scale) -> void { singleton->environment_set_sky_custom_fov(env, scale); });
	js_singleton.add((new std::string("environment_set_sky_orientation"))->c_str(), [singleton](const RID &env, const Basis &orientation) -> void { singleton->environment_set_sky_orientation(env, orientation); });
	js_singleton.add((new std::string("environment_set_bg_color"))->c_str(), [singleton](const RID &env, const Color &color) -> void { singleton->environment_set_bg_color(env, color); });
	js_singleton.add((new std::string("environment_set_bg_energy"))->c_str(), [singleton](const RID &env, double multiplier, double exposure_value) -> void { singleton->environment_set_bg_energy(env, multiplier, exposure_value); });
	js_singleton.add((new std::string("environment_set_canvas_max_layer"))->c_str(), [singleton](const RID &env, int32_t max_layer) -> void { singleton->environment_set_canvas_max_layer(env, max_layer); });
	js_singleton.add((new std::string("environment_set_ambient_light"))->c_str(), [singleton](const RID &env, const Color &color, RenderingServer::EnvironmentAmbientSource ambient, double energy, double sky_contibution, RenderingServer::EnvironmentReflectionSource reflection_source) -> void { singleton->environment_set_ambient_light(env, color, ambient, energy, sky_contibution, reflection_source); });
	js_singleton.add((new std::string("environment_set_glow"))->c_str(), [singleton](const RID &env, bool enable, const PackedFloat32Array &levels, double intensity, double strength, double mix, double bloom_threshold, RenderingServer::EnvironmentGlowBlendMode blend_mode, double hdr_bleed_threshold, double hdr_bleed_scale, double hdr_luminance_cap, double glow_map_strength, const RID &glow_map) -> void { singleton->environment_set_glow(env, enable, levels, intensity, strength, mix, bloom_threshold, blend_mode, hdr_bleed_threshold, hdr_bleed_scale, hdr_luminance_cap, glow_map_strength, glow_map); });
	js_singleton.add((new std::string("environment_set_tonemap"))->c_str(), [singleton](const RID &env, RenderingServer::EnvironmentToneMapper tone_mapper, double exposure, double white) -> void { singleton->environment_set_tonemap(env, tone_mapper, exposure, white); });
	js_singleton.add((new std::string("environment_set_adjustment"))->c_str(), [singleton](const RID &env, bool enable, double brightness, double contrast, double saturation, bool use_1d_color_correction, const RID &color_correction) -> void { singleton->environment_set_adjustment(env, enable, brightness, contrast, saturation, use_1d_color_correction, color_correction); });
	js_singleton.add((new std::string("environment_set_ssr"))->c_str(), [singleton](const RID &env, bool enable, int32_t max_steps, double fade_in, double fade_out, double depth_tolerance) -> void { singleton->environment_set_ssr(env, enable, max_steps, fade_in, fade_out, depth_tolerance); });
	js_singleton.add((new std::string("environment_set_ssao"))->c_str(), [singleton](const RID &env, bool enable, double radius, double intensity, double power, double detail, double horizon, double sharpness, double light_affect, double ao_channel_affect) -> void { singleton->environment_set_ssao(env, enable, radius, intensity, power, detail, horizon, sharpness, light_affect, ao_channel_affect); });
	js_singleton.add((new std::string("environment_set_fog"))->c_str(), [singleton](const RID &env, bool enable, const Color &light_color, double light_energy, double sun_scatter, double density, double height, double height_density, double aerial_perspective, double sky_affect, RenderingServer::EnvironmentFogMode fog_mode) -> void { singleton->environment_set_fog(env, enable, light_color, light_energy, sun_scatter, density, height, height_density, aerial_perspective, sky_affect, fog_mode); });
	js_singleton.add((new std::string("environment_set_sdfgi"))->c_str(), [singleton](const RID &env, bool enable, int32_t cascades, double min_cell_size, RenderingServer::EnvironmentSDFGIYScale y_scale, bool use_occlusion, double bounce_feedback, bool read_sky, double energy, double normal_bias, double probe_bias) -> void { singleton->environment_set_sdfgi(env, enable, cascades, min_cell_size, y_scale, use_occlusion, bounce_feedback, read_sky, energy, normal_bias, probe_bias); });
	js_singleton.add((new std::string("environment_set_volumetric_fog"))->c_str(), [singleton](const RID &env, bool enable, double density, const Color &albedo, const Color &emission, double emission_energy, double anisotropy, double length, double p_detail_spread, double gi_inject, bool temporal_reprojection, double temporal_reprojection_amount, double ambient_inject, double sky_affect) -> void { singleton->environment_set_volumetric_fog(env, enable, density, albedo, emission, emission_energy, anisotropy, length, p_detail_spread, gi_inject, temporal_reprojection, temporal_reprojection_amount, ambient_inject, sky_affect); });
	js_singleton.add((new std::string("environment_glow_set_use_bicubic_upscale"))->c_str(), [singleton](bool enable) -> void { singleton->environment_glow_set_use_bicubic_upscale(enable); });
	js_singleton.add((new std::string("environment_set_ssr_roughness_quality"))->c_str(), [singleton](RenderingServer::EnvironmentSSRRoughnessQuality quality) -> void { singleton->environment_set_ssr_roughness_quality(quality); });
	js_singleton.add((new std::string("environment_set_ssao_quality"))->c_str(), [singleton](RenderingServer::EnvironmentSSAOQuality quality, bool half_size, double adaptive_target, int32_t blur_passes, double fadeout_from, double fadeout_to) -> void { singleton->environment_set_ssao_quality(quality, half_size, adaptive_target, blur_passes, fadeout_from, fadeout_to); });
	js_singleton.add((new std::string("environment_set_ssil_quality"))->c_str(), [singleton](RenderingServer::EnvironmentSSILQuality quality, bool half_size, double adaptive_target, int32_t blur_passes, double fadeout_from, double fadeout_to) -> void { singleton->environment_set_ssil_quality(quality, half_size, adaptive_target, blur_passes, fadeout_from, fadeout_to); });
	js_singleton.add((new std::string("environment_set_sdfgi_ray_count"))->c_str(), [singleton](RenderingServer::EnvironmentSDFGIRayCount ray_count) -> void { singleton->environment_set_sdfgi_ray_count(ray_count); });
	js_singleton.add((new std::string("environment_set_sdfgi_frames_to_converge"))->c_str(), [singleton](RenderingServer::EnvironmentSDFGIFramesToConverge frames) -> void { singleton->environment_set_sdfgi_frames_to_converge(frames); });
	js_singleton.add((new std::string("environment_set_sdfgi_frames_to_update_light"))->c_str(), [singleton](RenderingServer::EnvironmentSDFGIFramesToUpdateLight frames) -> void { singleton->environment_set_sdfgi_frames_to_update_light(frames); });
	js_singleton.add((new std::string("environment_set_volumetric_fog_volume_size"))->c_str(), [singleton](int32_t size, int32_t depth) -> void { singleton->environment_set_volumetric_fog_volume_size(size, depth); });
	js_singleton.add((new std::string("environment_set_volumetric_fog_filter_active"))->c_str(), [singleton](bool active) -> void { singleton->environment_set_volumetric_fog_filter_active(active); });
	js_singleton.add((new std::string("environment_bake_panorama"))->c_str(), [singleton](const RID &environment, bool bake_irradiance, const Vector2i &size) -> Ref<Image> { return singleton->environment_bake_panorama(environment, bake_irradiance, size); });
	js_singleton.add((new std::string("screen_space_roughness_limiter_set_active"))->c_str(), [singleton](bool enable, double amount, double limit) -> void { singleton->screen_space_roughness_limiter_set_active(enable, amount, limit); });
	js_singleton.add((new std::string("sub_surface_scattering_set_quality"))->c_str(), [singleton](RenderingServer::SubSurfaceScatteringQuality quality) -> void { singleton->sub_surface_scattering_set_quality(quality); });
	js_singleton.add((new std::string("sub_surface_scattering_set_scale"))->c_str(), [singleton](double scale, double depth_scale) -> void { singleton->sub_surface_scattering_set_scale(scale, depth_scale); });
	js_singleton.add((new std::string("camera_attributes_create"))->c_str(), [singleton]() -> RID { return singleton->camera_attributes_create(); });
	js_singleton.add((new std::string("camera_attributes_set_dof_blur_quality"))->c_str(), [singleton](RenderingServer::DOFBlurQuality quality, bool use_jitter) -> void { singleton->camera_attributes_set_dof_blur_quality(quality, use_jitter); });
	js_singleton.add((new std::string("camera_attributes_set_dof_blur_bokeh_shape"))->c_str(), [singleton](RenderingServer::DOFBokehShape shape) -> void { singleton->camera_attributes_set_dof_blur_bokeh_shape(shape); });
	js_singleton.add((new std::string("camera_attributes_set_dof_blur"))->c_str(), [singleton](const RID &camera_attributes, bool far_enable, double far_distance, double far_transition, bool near_enable, double near_distance, double near_transition, double amount) -> void { singleton->camera_attributes_set_dof_blur(camera_attributes, far_enable, far_distance, far_transition, near_enable, near_distance, near_transition, amount); });
	js_singleton.add((new std::string("camera_attributes_set_exposure"))->c_str(), [singleton](const RID &camera_attributes, double multiplier, double normalization) -> void { singleton->camera_attributes_set_exposure(camera_attributes, multiplier, normalization); });
	js_singleton.add((new std::string("camera_attributes_set_auto_exposure"))->c_str(), [singleton](const RID &camera_attributes, bool enable, double min_sensitivity, double max_sensitivity, double speed, double scale) -> void { singleton->camera_attributes_set_auto_exposure(camera_attributes, enable, min_sensitivity, max_sensitivity, speed, scale); });
	js_singleton.add((new std::string("scenario_create"))->c_str(), [singleton]() -> RID { return singleton->scenario_create(); });
	js_singleton.add((new std::string("scenario_set_environment"))->c_str(), [singleton](const RID &scenario, const RID &environment) -> void { singleton->scenario_set_environment(scenario, environment); });
	js_singleton.add((new std::string("scenario_set_fallback_environment"))->c_str(), [singleton](const RID &scenario, const RID &environment) -> void { singleton->scenario_set_fallback_environment(scenario, environment); });
	js_singleton.add((new std::string("scenario_set_camera_attributes"))->c_str(), [singleton](const RID &scenario, const RID &effects) -> void { singleton->scenario_set_camera_attributes(scenario, effects); });
	js_singleton.add((new std::string("scenario_set_compositor"))->c_str(), [singleton](const RID &scenario, const RID &compositor) -> void { singleton->scenario_set_compositor(scenario, compositor); });
	js_singleton.add((new std::string("instance_create2"))->c_str(), [singleton](const RID &base, const RID &scenario) -> RID { return singleton->instance_create2(base, scenario); });
	js_singleton.add((new std::string("instance_create"))->c_str(), [singleton]() -> RID { return singleton->instance_create(); });
	js_singleton.add((new std::string("instance_set_base"))->c_str(), [singleton](const RID &instance, const RID &base) -> void { singleton->instance_set_base(instance, base); });
	js_singleton.add((new std::string("instance_set_scenario"))->c_str(), [singleton](const RID &instance, const RID &scenario) -> void { singleton->instance_set_scenario(instance, scenario); });
	js_singleton.add((new std::string("instance_set_layer_mask"))->c_str(), [singleton](const RID &instance, uint32_t mask) -> void { singleton->instance_set_layer_mask(instance, mask); });
	js_singleton.add((new std::string("instance_set_pivot_data"))->c_str(), [singleton](const RID &instance, double sorting_offset, bool use_aabb_center) -> void { singleton->instance_set_pivot_data(instance, sorting_offset, use_aabb_center); });
	js_singleton.add((new std::string("instance_set_transform"))->c_str(), [singleton](const RID &instance, const Transform3D &transform) -> void { singleton->instance_set_transform(instance, transform); });
	js_singleton.add((new std::string("instance_attach_object_instance_id"))->c_str(), [singleton](const RID &instance, uint64_t id) -> void { singleton->instance_attach_object_instance_id(instance, id); });
	js_singleton.add((new std::string("instance_set_blend_shape_weight"))->c_str(), [singleton](const RID &instance, int32_t shape, double weight) -> void { singleton->instance_set_blend_shape_weight(instance, shape, weight); });
	js_singleton.add((new std::string("instance_set_surface_override_material"))->c_str(), [singleton](const RID &instance, int32_t surface, const RID &material) -> void { singleton->instance_set_surface_override_material(instance, surface, material); });
	js_singleton.add((new std::string("instance_set_visible"))->c_str(), [singleton](const RID &instance, bool visible) -> void { singleton->instance_set_visible(instance, visible); });
	js_singleton.add((new std::string("instance_geometry_set_transparency"))->c_str(), [singleton](const RID &instance, double transparency) -> void { singleton->instance_geometry_set_transparency(instance, transparency); });
	js_singleton.add((new std::string("instance_set_custom_aabb"))->c_str(), [singleton](const RID &instance, const AABB &aabb) -> void { singleton->instance_set_custom_aabb(instance, aabb); });
	js_singleton.add((new std::string("instance_attach_skeleton"))->c_str(), [singleton](const RID &instance, const RID &skeleton) -> void { singleton->instance_attach_skeleton(instance, skeleton); });
	js_singleton.add((new std::string("instance_set_extra_visibility_margin"))->c_str(), [singleton](const RID &instance, double margin) -> void { singleton->instance_set_extra_visibility_margin(instance, margin); });
	js_singleton.add((new std::string("instance_set_visibility_parent"))->c_str(), [singleton](const RID &instance, const RID &parent) -> void { singleton->instance_set_visibility_parent(instance, parent); });
	js_singleton.add((new std::string("instance_set_ignore_culling"))->c_str(), [singleton](const RID &instance, bool enabled) -> void { singleton->instance_set_ignore_culling(instance, enabled); });
	js_singleton.add((new std::string("instance_geometry_set_flag"))->c_str(), [singleton](const RID &instance, RenderingServer::InstanceFlags flag, bool enabled) -> void { singleton->instance_geometry_set_flag(instance, flag, enabled); });
	js_singleton.add((new std::string("instance_geometry_set_cast_shadows_setting"))->c_str(), [singleton](const RID &instance, RenderingServer::ShadowCastingSetting shadow_casting_setting) -> void { singleton->instance_geometry_set_cast_shadows_setting(instance, shadow_casting_setting); });
	js_singleton.add((new std::string("instance_geometry_set_material_override"))->c_str(), [singleton](const RID &instance, const RID &material) -> void { singleton->instance_geometry_set_material_override(instance, material); });
	js_singleton.add((new std::string("instance_geometry_set_material_overlay"))->c_str(), [singleton](const RID &instance, const RID &material) -> void { singleton->instance_geometry_set_material_overlay(instance, material); });
	js_singleton.add((new std::string("instance_geometry_set_visibility_range"))->c_str(), [singleton](const RID &instance, double min, double max, double min_margin, double max_margin, RenderingServer::VisibilityRangeFadeMode fade_mode) -> void { singleton->instance_geometry_set_visibility_range(instance, min, max, min_margin, max_margin, fade_mode); });
	js_singleton.add((new std::string("instance_geometry_set_lightmap"))->c_str(), [singleton](const RID &instance, const RID &lightmap, const Rect2 &lightmap_uv_scale, int32_t lightmap_slice) -> void { singleton->instance_geometry_set_lightmap(instance, lightmap, lightmap_uv_scale, lightmap_slice); });
	js_singleton.add((new std::string("instance_geometry_set_lod_bias"))->c_str(), [singleton](const RID &instance, double lod_bias) -> void { singleton->instance_geometry_set_lod_bias(instance, lod_bias); });
	js_singleton.add((new std::string("instance_geometry_set_shader_parameter"))->c_str(), [singleton](const RID &instance, const StringName &parameter, const Variant &value) -> void { singleton->instance_geometry_set_shader_parameter(instance, parameter, value); });
	js_singleton.add((new std::string("instance_geometry_get_shader_parameter"))->c_str(), [singleton](const RID &instance, const StringName &parameter) -> Variant { return singleton->instance_geometry_get_shader_parameter(instance, parameter); });
	js_singleton.add((new std::string("instance_geometry_get_shader_parameter_default_value"))->c_str(), [singleton](const RID &instance, const StringName &parameter) -> Variant { return singleton->instance_geometry_get_shader_parameter_default_value(instance, parameter); });
	js_singleton.add((new std::string("instance_geometry_get_shader_parameter_list"))->c_str(), [singleton](const RID &instance) -> TypedArray<Dictionary> { return singleton->instance_geometry_get_shader_parameter_list(instance); });
	js_singleton.add((new std::string("instances_cull_aabb"))->c_str(), [singleton](const AABB &aabb, const RID &scenario) -> PackedInt64Array { return singleton->instances_cull_aabb(aabb, scenario); });
	js_singleton.add((new std::string("instances_cull_ray"))->c_str(), [singleton](const Vector3 &from, const Vector3 &to, const RID &scenario) -> PackedInt64Array { return singleton->instances_cull_ray(from, to, scenario); });
	js_singleton.add((new std::string("instances_cull_convex"))->c_str(), [singleton](const TypedArray<Plane> &convex, const RID &scenario) -> PackedInt64Array { return singleton->instances_cull_convex(convex, scenario); });
	js_singleton.add((new std::string("bake_render_uv2"))->c_str(), [singleton](const RID &base, const TypedArray<RID> &material_overrides, const Vector2i &image_size) -> TypedArray<Image> { return singleton->bake_render_uv2(base, material_overrides, image_size); });
	js_singleton.add((new std::string("canvas_create"))->c_str(), [singleton]() -> RID { return singleton->canvas_create(); });
	js_singleton.add((new std::string("canvas_set_item_mirroring"))->c_str(), [singleton](const RID &canvas, const RID &item, const Vector2 &mirroring) -> void { singleton->canvas_set_item_mirroring(canvas, item, mirroring); });
	js_singleton.add((new std::string("canvas_set_item_repeat"))->c_str(), [singleton](const RID &item, const Vector2 &repeat_size, int32_t repeat_times) -> void { singleton->canvas_set_item_repeat(item, repeat_size, repeat_times); });
	js_singleton.add((new std::string("canvas_set_modulate"))->c_str(), [singleton](const RID &canvas, const Color &color) -> void { singleton->canvas_set_modulate(canvas, color); });
	js_singleton.add((new std::string("canvas_set_disable_scale"))->c_str(), [singleton](bool disable) -> void { singleton->canvas_set_disable_scale(disable); });
	js_singleton.add((new std::string("canvas_texture_create"))->c_str(), [singleton]() -> RID { return singleton->canvas_texture_create(); });
	js_singleton.add((new std::string("canvas_texture_set_channel"))->c_str(), [singleton](const RID &canvas_texture, RenderingServer::CanvasTextureChannel channel, const RID &texture) -> void { singleton->canvas_texture_set_channel(canvas_texture, channel, texture); });
	js_singleton.add((new std::string("canvas_texture_set_shading_parameters"))->c_str(), [singleton](const RID &canvas_texture, const Color &base_color, double shininess) -> void { singleton->canvas_texture_set_shading_parameters(canvas_texture, base_color, shininess); });
	js_singleton.add((new std::string("canvas_texture_set_texture_filter"))->c_str(), [singleton](const RID &canvas_texture, RenderingServer::CanvasItemTextureFilter filter) -> void { singleton->canvas_texture_set_texture_filter(canvas_texture, filter); });
	js_singleton.add((new std::string("canvas_texture_set_texture_repeat"))->c_str(), [singleton](const RID &canvas_texture, RenderingServer::CanvasItemTextureRepeat repeat) -> void { singleton->canvas_texture_set_texture_repeat(canvas_texture, repeat); });
	js_singleton.add((new std::string("canvas_item_create"))->c_str(), [singleton]() -> RID { return singleton->canvas_item_create(); });
	js_singleton.add((new std::string("canvas_item_set_parent"))->c_str(), [singleton](const RID &item, const RID &parent) -> void { singleton->canvas_item_set_parent(item, parent); });
	js_singleton.add((new std::string("canvas_item_set_default_texture_filter"))->c_str(), [singleton](const RID &item, RenderingServer::CanvasItemTextureFilter filter) -> void { singleton->canvas_item_set_default_texture_filter(item, filter); });
	js_singleton.add((new std::string("canvas_item_set_default_texture_repeat"))->c_str(), [singleton](const RID &item, RenderingServer::CanvasItemTextureRepeat repeat) -> void { singleton->canvas_item_set_default_texture_repeat(item, repeat); });
	js_singleton.add((new std::string("canvas_item_set_visible"))->c_str(), [singleton](const RID &item, bool visible) -> void { singleton->canvas_item_set_visible(item, visible); });
	js_singleton.add((new std::string("canvas_item_set_light_mask"))->c_str(), [singleton](const RID &item, int32_t mask) -> void { singleton->canvas_item_set_light_mask(item, mask); });
	js_singleton.add((new std::string("canvas_item_set_visibility_layer"))->c_str(), [singleton](const RID &item, uint32_t visibility_layer) -> void { singleton->canvas_item_set_visibility_layer(item, visibility_layer); });
	js_singleton.add((new std::string("canvas_item_set_transform"))->c_str(), [singleton](const RID &item, const Transform2D &transform) -> void { singleton->canvas_item_set_transform(item, transform); });
	js_singleton.add((new std::string("canvas_item_set_clip"))->c_str(), [singleton](const RID &item, bool clip) -> void { singleton->canvas_item_set_clip(item, clip); });
	js_singleton.add((new std::string("canvas_item_set_distance_field_mode"))->c_str(), [singleton](const RID &item, bool enabled) -> void { singleton->canvas_item_set_distance_field_mode(item, enabled); });
	js_singleton.add((new std::string("canvas_item_set_custom_rect"))->c_str(), [singleton](const RID &item, bool use_custom_rect, const Rect2 &rect) -> void { singleton->canvas_item_set_custom_rect(item, use_custom_rect, rect); });
	js_singleton.add((new std::string("canvas_item_set_modulate"))->c_str(), [singleton](const RID &item, const Color &color) -> void { singleton->canvas_item_set_modulate(item, color); });
	js_singleton.add((new std::string("canvas_item_set_self_modulate"))->c_str(), [singleton](const RID &item, const Color &color) -> void { singleton->canvas_item_set_self_modulate(item, color); });
	js_singleton.add((new std::string("canvas_item_set_draw_behind_parent"))->c_str(), [singleton](const RID &item, bool enabled) -> void { singleton->canvas_item_set_draw_behind_parent(item, enabled); });
	js_singleton.add((new std::string("canvas_item_set_interpolated"))->c_str(), [singleton](const RID &item, bool interpolated) -> void { singleton->canvas_item_set_interpolated(item, interpolated); });
	js_singleton.add((new std::string("canvas_item_reset_physics_interpolation"))->c_str(), [singleton](const RID &item) -> void { singleton->canvas_item_reset_physics_interpolation(item); });
	js_singleton.add((new std::string("canvas_item_transform_physics_interpolation"))->c_str(), [singleton](const RID &item, const Transform2D &transform) -> void { singleton->canvas_item_transform_physics_interpolation(item, transform); });
	js_singleton.add((new std::string("canvas_item_add_line"))->c_str(), [singleton](const RID &item, const Vector2 &from, const Vector2 &to, const Color &color, double width, bool antialiased) -> void { singleton->canvas_item_add_line(item, from, to, color, width, antialiased); });
	js_singleton.add((new std::string("canvas_item_add_polyline"))->c_str(), [singleton](const RID &item, const PackedVector2Array &points, const PackedColorArray &colors, double width, bool antialiased) -> void { singleton->canvas_item_add_polyline(item, points, colors, width, antialiased); });
	js_singleton.add((new std::string("canvas_item_add_multiline"))->c_str(), [singleton](const RID &item, const PackedVector2Array &points, const PackedColorArray &colors, double width, bool antialiased) -> void { singleton->canvas_item_add_multiline(item, points, colors, width, antialiased); });
	js_singleton.add((new std::string("canvas_item_add_rect"))->c_str(), [singleton](const RID &item, const Rect2 &rect, const Color &color, bool antialiased) -> void { singleton->canvas_item_add_rect(item, rect, color, antialiased); });
	js_singleton.add((new std::string("canvas_item_add_circle"))->c_str(), [singleton](const RID &item, const Vector2 &pos, double radius, const Color &color, bool antialiased) -> void { singleton->canvas_item_add_circle(item, pos, radius, color, antialiased); });
	js_singleton.add((new std::string("canvas_item_add_texture_rect"))->c_str(), [singleton](const RID &item, const Rect2 &rect, const RID &texture, bool tile, const Color &modulate, bool transpose) -> void { singleton->canvas_item_add_texture_rect(item, rect, texture, tile, modulate, transpose); });
	js_singleton.add((new std::string("canvas_item_add_msdf_texture_rect_region"))->c_str(), [singleton](const RID &item, const Rect2 &rect, const RID &texture, const Rect2 &src_rect, const Color &modulate, int32_t outline_size, double px_range, double scale) -> void { singleton->canvas_item_add_msdf_texture_rect_region(item, rect, texture, src_rect, modulate, outline_size, px_range, scale); });
	js_singleton.add((new std::string("canvas_item_add_lcd_texture_rect_region"))->c_str(), [singleton](const RID &item, const Rect2 &rect, const RID &texture, const Rect2 &src_rect, const Color &modulate) -> void { singleton->canvas_item_add_lcd_texture_rect_region(item, rect, texture, src_rect, modulate); });
	js_singleton.add((new std::string("canvas_item_add_texture_rect_region"))->c_str(), [singleton](const RID &item, const Rect2 &rect, const RID &texture, const Rect2 &src_rect, const Color &modulate, bool transpose, bool clip_uv) -> void { singleton->canvas_item_add_texture_rect_region(item, rect, texture, src_rect, modulate, transpose, clip_uv); });
	js_singleton.add((new std::string("canvas_item_add_nine_patch"))->c_str(), [singleton](const RID &item, const Rect2 &rect, const Rect2 &source, const RID &texture, const Vector2 &topleft, const Vector2 &bottomright, RenderingServer::NinePatchAxisMode x_axis_mode, RenderingServer::NinePatchAxisMode y_axis_mode, bool draw_center, const Color &modulate) -> void { singleton->canvas_item_add_nine_patch(item, rect, source, texture, topleft, bottomright, x_axis_mode, y_axis_mode, draw_center, modulate); });
	js_singleton.add((new std::string("canvas_item_add_primitive"))->c_str(), [singleton](const RID &item, const PackedVector2Array &points, const PackedColorArray &colors, const PackedVector2Array &uvs, const RID &texture) -> void { singleton->canvas_item_add_primitive(item, points, colors, uvs, texture); });
	js_singleton.add((new std::string("canvas_item_add_polygon"))->c_str(), [singleton](const RID &item, const PackedVector2Array &points, const PackedColorArray &colors, const PackedVector2Array &uvs, const RID &texture) -> void { singleton->canvas_item_add_polygon(item, points, colors, uvs, texture); });
	js_singleton.add((new std::string("canvas_item_add_triangle_array"))->c_str(), [singleton](const RID &item, const PackedInt32Array &indices, const PackedVector2Array &points, const PackedColorArray &colors, const PackedVector2Array &uvs, const PackedInt32Array &bones, const PackedFloat32Array &weights, const RID &texture, int32_t count) -> void { singleton->canvas_item_add_triangle_array(item, indices, points, colors, uvs, bones, weights, texture, count); });
	js_singleton.add((new std::string("canvas_item_add_mesh"))->c_str(), [singleton](const RID &item, const RID &mesh, const Transform2D &transform, const Color &modulate, const RID &texture) -> void { singleton->canvas_item_add_mesh(item, mesh, transform, modulate, texture); });
	js_singleton.add((new std::string("canvas_item_add_multimesh"))->c_str(), [singleton](const RID &item, const RID &mesh, const RID &texture) -> void { singleton->canvas_item_add_multimesh(item, mesh, texture); });
	js_singleton.add((new std::string("canvas_item_add_particles"))->c_str(), [singleton](const RID &item, const RID &particles, const RID &texture) -> void { singleton->canvas_item_add_particles(item, particles, texture); });
	js_singleton.add((new std::string("canvas_item_add_set_transform"))->c_str(), [singleton](const RID &item, const Transform2D &transform) -> void { singleton->canvas_item_add_set_transform(item, transform); });
	js_singleton.add((new std::string("canvas_item_add_clip_ignore"))->c_str(), [singleton](const RID &item, bool ignore) -> void { singleton->canvas_item_add_clip_ignore(item, ignore); });
	js_singleton.add((new std::string("canvas_item_add_animation_slice"))->c_str(), [singleton](const RID &item, double animation_length, double slice_begin, double slice_end, double offset) -> void { singleton->canvas_item_add_animation_slice(item, animation_length, slice_begin, slice_end, offset); });
	js_singleton.add((new std::string("canvas_item_set_sort_children_by_y"))->c_str(), [singleton](const RID &item, bool enabled) -> void { singleton->canvas_item_set_sort_children_by_y(item, enabled); });
	js_singleton.add((new std::string("canvas_item_set_z_index"))->c_str(), [singleton](const RID &item, int32_t z_index) -> void { singleton->canvas_item_set_z_index(item, z_index); });
	js_singleton.add((new std::string("canvas_item_set_z_as_relative_to_parent"))->c_str(), [singleton](const RID &item, bool enabled) -> void { singleton->canvas_item_set_z_as_relative_to_parent(item, enabled); });
	js_singleton.add((new std::string("canvas_item_set_copy_to_backbuffer"))->c_str(), [singleton](const RID &item, bool enabled, const Rect2 &rect) -> void { singleton->canvas_item_set_copy_to_backbuffer(item, enabled, rect); });
	js_singleton.add((new std::string("canvas_item_clear"))->c_str(), [singleton](const RID &item) -> void { singleton->canvas_item_clear(item); });
	js_singleton.add((new std::string("canvas_item_set_draw_index"))->c_str(), [singleton](const RID &item, int32_t index) -> void { singleton->canvas_item_set_draw_index(item, index); });
	js_singleton.add((new std::string("canvas_item_set_material"))->c_str(), [singleton](const RID &item, const RID &material) -> void { singleton->canvas_item_set_material(item, material); });
	js_singleton.add((new std::string("canvas_item_set_use_parent_material"))->c_str(), [singleton](const RID &item, bool enabled) -> void { singleton->canvas_item_set_use_parent_material(item, enabled); });
	js_singleton.add((new std::string("canvas_item_set_visibility_notifier"))->c_str(), [singleton](const RID &item, bool enable, const Rect2 &area, const Callable &enter_callable, const Callable &exit_callable) -> void { singleton->canvas_item_set_visibility_notifier(item, enable, area, enter_callable, exit_callable); });
	js_singleton.add((new std::string("canvas_item_set_canvas_group_mode"))->c_str(), [singleton](const RID &item, RenderingServer::CanvasGroupMode mode, double clear_margin, bool fit_empty, double fit_margin, bool blur_mipmaps) -> void { singleton->canvas_item_set_canvas_group_mode(item, mode, clear_margin, fit_empty, fit_margin, blur_mipmaps); });
	js_singleton.add((new std::string("debug_canvas_item_get_rect"))->c_str(), [singleton](const RID &item) -> Rect2 { return singleton->debug_canvas_item_get_rect(item); });
	js_singleton.add((new std::string("canvas_light_create"))->c_str(), [singleton]() -> RID { return singleton->canvas_light_create(); });
	js_singleton.add((new std::string("canvas_light_attach_to_canvas"))->c_str(), [singleton](const RID &light, const RID &canvas) -> void { singleton->canvas_light_attach_to_canvas(light, canvas); });
	js_singleton.add((new std::string("canvas_light_set_enabled"))->c_str(), [singleton](const RID &light, bool enabled) -> void { singleton->canvas_light_set_enabled(light, enabled); });
	js_singleton.add((new std::string("canvas_light_set_texture_scale"))->c_str(), [singleton](const RID &light, double scale) -> void { singleton->canvas_light_set_texture_scale(light, scale); });
	js_singleton.add((new std::string("canvas_light_set_transform"))->c_str(), [singleton](const RID &light, const Transform2D &transform) -> void { singleton->canvas_light_set_transform(light, transform); });
	js_singleton.add((new std::string("canvas_light_set_texture"))->c_str(), [singleton](const RID &light, const RID &texture) -> void { singleton->canvas_light_set_texture(light, texture); });
	js_singleton.add((new std::string("canvas_light_set_texture_offset"))->c_str(), [singleton](const RID &light, const Vector2 &offset) -> void { singleton->canvas_light_set_texture_offset(light, offset); });
	js_singleton.add((new std::string("canvas_light_set_color"))->c_str(), [singleton](const RID &light, const Color &color) -> void { singleton->canvas_light_set_color(light, color); });
	js_singleton.add((new std::string("canvas_light_set_height"))->c_str(), [singleton](const RID &light, double height) -> void { singleton->canvas_light_set_height(light, height); });
	js_singleton.add((new std::string("canvas_light_set_energy"))->c_str(), [singleton](const RID &light, double energy) -> void { singleton->canvas_light_set_energy(light, energy); });
	js_singleton.add((new std::string("canvas_light_set_z_range"))->c_str(), [singleton](const RID &light, int32_t min_z, int32_t max_z) -> void { singleton->canvas_light_set_z_range(light, min_z, max_z); });
	js_singleton.add((new std::string("canvas_light_set_layer_range"))->c_str(), [singleton](const RID &light, int32_t min_layer, int32_t max_layer) -> void { singleton->canvas_light_set_layer_range(light, min_layer, max_layer); });
	js_singleton.add((new std::string("canvas_light_set_item_cull_mask"))->c_str(), [singleton](const RID &light, int32_t mask) -> void { singleton->canvas_light_set_item_cull_mask(light, mask); });
	js_singleton.add((new std::string("canvas_light_set_item_shadow_cull_mask"))->c_str(), [singleton](const RID &light, int32_t mask) -> void { singleton->canvas_light_set_item_shadow_cull_mask(light, mask); });
	js_singleton.add((new std::string("canvas_light_set_mode"))->c_str(), [singleton](const RID &light, RenderingServer::CanvasLightMode mode) -> void { singleton->canvas_light_set_mode(light, mode); });
	js_singleton.add((new std::string("canvas_light_set_shadow_enabled"))->c_str(), [singleton](const RID &light, bool enabled) -> void { singleton->canvas_light_set_shadow_enabled(light, enabled); });
	js_singleton.add((new std::string("canvas_light_set_shadow_filter"))->c_str(), [singleton](const RID &light, RenderingServer::CanvasLightShadowFilter filter) -> void { singleton->canvas_light_set_shadow_filter(light, filter); });
	js_singleton.add((new std::string("canvas_light_set_shadow_color"))->c_str(), [singleton](const RID &light, const Color &color) -> void { singleton->canvas_light_set_shadow_color(light, color); });
	js_singleton.add((new std::string("canvas_light_set_shadow_smooth"))->c_str(), [singleton](const RID &light, double smooth) -> void { singleton->canvas_light_set_shadow_smooth(light, smooth); });
	js_singleton.add((new std::string("canvas_light_set_blend_mode"))->c_str(), [singleton](const RID &light, RenderingServer::CanvasLightBlendMode mode) -> void { singleton->canvas_light_set_blend_mode(light, mode); });
	js_singleton.add((new std::string("canvas_light_set_interpolated"))->c_str(), [singleton](const RID &light, bool interpolated) -> void { singleton->canvas_light_set_interpolated(light, interpolated); });
	js_singleton.add((new std::string("canvas_light_reset_physics_interpolation"))->c_str(), [singleton](const RID &light) -> void { singleton->canvas_light_reset_physics_interpolation(light); });
	js_singleton.add((new std::string("canvas_light_transform_physics_interpolation"))->c_str(), [singleton](const RID &light, const Transform2D &transform) -> void { singleton->canvas_light_transform_physics_interpolation(light, transform); });
	js_singleton.add((new std::string("canvas_light_occluder_create"))->c_str(), [singleton]() -> RID { return singleton->canvas_light_occluder_create(); });
	js_singleton.add((new std::string("canvas_light_occluder_attach_to_canvas"))->c_str(), [singleton](const RID &occluder, const RID &canvas) -> void { singleton->canvas_light_occluder_attach_to_canvas(occluder, canvas); });
	js_singleton.add((new std::string("canvas_light_occluder_set_enabled"))->c_str(), [singleton](const RID &occluder, bool enabled) -> void { singleton->canvas_light_occluder_set_enabled(occluder, enabled); });
	js_singleton.add((new std::string("canvas_light_occluder_set_polygon"))->c_str(), [singleton](const RID &occluder, const RID &polygon) -> void { singleton->canvas_light_occluder_set_polygon(occluder, polygon); });
	js_singleton.add((new std::string("canvas_light_occluder_set_as_sdf_collision"))->c_str(), [singleton](const RID &occluder, bool enable) -> void { singleton->canvas_light_occluder_set_as_sdf_collision(occluder, enable); });
	js_singleton.add((new std::string("canvas_light_occluder_set_transform"))->c_str(), [singleton](const RID &occluder, const Transform2D &transform) -> void { singleton->canvas_light_occluder_set_transform(occluder, transform); });
	js_singleton.add((new std::string("canvas_light_occluder_set_light_mask"))->c_str(), [singleton](const RID &occluder, int32_t mask) -> void { singleton->canvas_light_occluder_set_light_mask(occluder, mask); });
	js_singleton.add((new std::string("canvas_light_occluder_set_interpolated"))->c_str(), [singleton](const RID &occluder, bool interpolated) -> void { singleton->canvas_light_occluder_set_interpolated(occluder, interpolated); });
	js_singleton.add((new std::string("canvas_light_occluder_reset_physics_interpolation"))->c_str(), [singleton](const RID &occluder) -> void { singleton->canvas_light_occluder_reset_physics_interpolation(occluder); });
	js_singleton.add((new std::string("canvas_light_occluder_transform_physics_interpolation"))->c_str(), [singleton](const RID &occluder, const Transform2D &transform) -> void { singleton->canvas_light_occluder_transform_physics_interpolation(occluder, transform); });
	js_singleton.add((new std::string("canvas_occluder_polygon_create"))->c_str(), [singleton]() -> RID { return singleton->canvas_occluder_polygon_create(); });
	js_singleton.add((new std::string("canvas_occluder_polygon_set_shape"))->c_str(), [singleton](const RID &occluder_polygon, const PackedVector2Array &shape, bool closed) -> void { singleton->canvas_occluder_polygon_set_shape(occluder_polygon, shape, closed); });
	js_singleton.add((new std::string("canvas_occluder_polygon_set_cull_mode"))->c_str(), [singleton](const RID &occluder_polygon, RenderingServer::CanvasOccluderPolygonCullMode mode) -> void { singleton->canvas_occluder_polygon_set_cull_mode(occluder_polygon, mode); });
	js_singleton.add((new std::string("canvas_set_shadow_texture_size"))->c_str(), [singleton](int32_t size) -> void { singleton->canvas_set_shadow_texture_size(size); });
	js_singleton.add((new std::string("global_shader_parameter_add"))->c_str(), [singleton](const StringName &name, RenderingServer::GlobalShaderParameterType type, const Variant &default_value) -> void { singleton->global_shader_parameter_add(name, type, default_value); });
	js_singleton.add((new std::string("global_shader_parameter_remove"))->c_str(), [singleton](const StringName &name) -> void { singleton->global_shader_parameter_remove(name); });
	js_singleton.add((new std::string("global_shader_parameter_get_list"))->c_str(), [singleton]() -> TypedArray<StringName> { return singleton->global_shader_parameter_get_list(); });
	js_singleton.add((new std::string("global_shader_parameter_set"))->c_str(), [singleton](const StringName &name, const Variant &value) -> void { singleton->global_shader_parameter_set(name, value); });
	js_singleton.add((new std::string("global_shader_parameter_set_override"))->c_str(), [singleton](const StringName &name, const Variant &value) -> void { singleton->global_shader_parameter_set_override(name, value); });
	js_singleton.add((new std::string("global_shader_parameter_get"))->c_str(), [singleton](const StringName &name) -> Variant { return singleton->global_shader_parameter_get(name); });
	js_singleton.add((new std::string("global_shader_parameter_get_type"))->c_str(), [singleton](const StringName &name) -> RenderingServer::GlobalShaderParameterType { return singleton->global_shader_parameter_get_type(name); });
	js_singleton.add((new std::string("free_rid"))->c_str(), [singleton](const RID &rid) -> void { singleton->free_rid(rid); });
	js_singleton.add((new std::string("request_frame_drawn_callback"))->c_str(), [singleton](const Callable &callable) -> void { singleton->request_frame_drawn_callback(callable); });
	js_singleton.add((new std::string("has_changed"))->c_str(), [singleton]() -> bool { return singleton->has_changed(); });
	js_singleton.add((new std::string("get_rendering_info"))->c_str(), [singleton](RenderingServer::RenderingInfo info) -> int64_t { return singleton->get_rendering_info(info); });
	js_singleton.add((new std::string("get_video_adapter_name"))->c_str(), [singleton]() -> String { return singleton->get_video_adapter_name(); });
	js_singleton.add((new std::string("get_video_adapter_vendor"))->c_str(), [singleton]() -> String { return singleton->get_video_adapter_vendor(); });
	js_singleton.add((new std::string("get_video_adapter_type"))->c_str(), [singleton]() -> RenderingDevice::DeviceType { return singleton->get_video_adapter_type(); });
	js_singleton.add((new std::string("get_video_adapter_api_version"))->c_str(), [singleton]() -> String { return singleton->get_video_adapter_api_version(); });
	js_singleton.add((new std::string("make_sphere_mesh"))->c_str(), [singleton](int32_t latitudes, int32_t longitudes, double radius) -> RID { return singleton->make_sphere_mesh(latitudes, longitudes, radius); });
	js_singleton.add((new std::string("get_test_cube"))->c_str(), [singleton]() -> RID { return singleton->get_test_cube(); });
	js_singleton.add((new std::string("get_test_texture"))->c_str(), [singleton]() -> RID { return singleton->get_test_texture(); });
	js_singleton.add((new std::string("get_white_texture"))->c_str(), [singleton]() -> RID { return singleton->get_white_texture(); });
	js_singleton.add((new std::string("set_boot_image"))->c_str(), [singleton](const Ref<Image> &image, const Color &color, bool scale, bool use_filter) -> void { singleton->set_boot_image(image, color, scale, use_filter); });
	js_singleton.add((new std::string("get_default_clear_color"))->c_str(), [singleton]() -> Color { return singleton->get_default_clear_color(); });
	js_singleton.add((new std::string("set_default_clear_color"))->c_str(), [singleton](const Color &color) -> void { singleton->set_default_clear_color(color); });
	js_singleton.add((new std::string("has_os_feature"))->c_str(), [singleton](const String &feature) -> bool { return singleton->has_os_feature(feature); });
	js_singleton.add((new std::string("set_debug_generate_wireframes"))->c_str(), [singleton](bool generate) -> void { singleton->set_debug_generate_wireframes(generate); });
	js_singleton.add((new std::string("is_render_loop_enabled"))->c_str(), [singleton]() -> bool { return singleton->is_render_loop_enabled(); });
	js_singleton.add((new std::string("set_render_loop_enabled"))->c_str(), [singleton](bool enabled) -> void { singleton->set_render_loop_enabled(enabled); });
	js_singleton.add((new std::string("get_frame_setup_time_cpu"))->c_str(), [singleton]() -> double { return singleton->get_frame_setup_time_cpu(); });
	js_singleton.add((new std::string("force_sync"))->c_str(), [singleton]() -> void { singleton->force_sync(); });
	js_singleton.add((new std::string("force_draw"))->c_str(), [singleton](bool swap_buffers, double frame_step) -> void { singleton->force_draw(swap_buffers, frame_step); });
	js_singleton.add((new std::string("get_rendering_device"))->c_str(), [singleton]() -> RenderingDevice * { return singleton->get_rendering_device(); });
	js_singleton.add((new std::string("create_local_rendering_device"))->c_str(), [singleton]() -> RenderingDevice * { return singleton->create_local_rendering_device(); });
	js_singleton.add((new std::string("is_on_render_thread"))->c_str(), [singleton]() -> bool { return singleton->is_on_render_thread(); });
	js_singleton.add((new std::string("call_on_render_thread"))->c_str(), [singleton](const Callable &callable) -> void { singleton->call_on_render_thread(callable); });
	js_singleton.add((new std::string("has_feature"))->c_str(), [singleton](RenderingServer::Features feature) -> bool { return singleton->has_feature(feature); });
	context->global()[(new std::string("RenderingServer"))->c_str()] = js_singleton;

	qjs::Value _TextureLayeredType = context->newObject();
	_TextureLayeredType[(new std::string("TEXTURE_LAYERED_2D_ARRAY"))->c_str()] = RenderingServer::TextureLayeredType::TEXTURE_LAYERED_2D_ARRAY;
	_TextureLayeredType[(new std::string("TEXTURE_LAYERED_CUBEMAP"))->c_str()] = RenderingServer::TextureLayeredType::TEXTURE_LAYERED_CUBEMAP;
	_TextureLayeredType[(new std::string("TEXTURE_LAYERED_CUBEMAP_ARRAY"))->c_str()] = RenderingServer::TextureLayeredType::TEXTURE_LAYERED_CUBEMAP_ARRAY;
	js_singleton[(new std::string("TextureLayeredType"))->c_str()] = _TextureLayeredType;
	qjs::Value _CubeMapLayer = context->newObject();
	_CubeMapLayer[(new std::string("CUBEMAP_LAYER_LEFT"))->c_str()] = RenderingServer::CubeMapLayer::CUBEMAP_LAYER_LEFT;
	_CubeMapLayer[(new std::string("CUBEMAP_LAYER_RIGHT"))->c_str()] = RenderingServer::CubeMapLayer::CUBEMAP_LAYER_RIGHT;
	_CubeMapLayer[(new std::string("CUBEMAP_LAYER_BOTTOM"))->c_str()] = RenderingServer::CubeMapLayer::CUBEMAP_LAYER_BOTTOM;
	_CubeMapLayer[(new std::string("CUBEMAP_LAYER_TOP"))->c_str()] = RenderingServer::CubeMapLayer::CUBEMAP_LAYER_TOP;
	_CubeMapLayer[(new std::string("CUBEMAP_LAYER_FRONT"))->c_str()] = RenderingServer::CubeMapLayer::CUBEMAP_LAYER_FRONT;
	_CubeMapLayer[(new std::string("CUBEMAP_LAYER_BACK"))->c_str()] = RenderingServer::CubeMapLayer::CUBEMAP_LAYER_BACK;
	js_singleton[(new std::string("CubeMapLayer"))->c_str()] = _CubeMapLayer;
	qjs::Value _ShaderMode = context->newObject();
	_ShaderMode[(new std::string("SHADER_SPATIAL"))->c_str()] = RenderingServer::ShaderMode::SHADER_SPATIAL;
	_ShaderMode[(new std::string("SHADER_CANVAS_ITEM"))->c_str()] = RenderingServer::ShaderMode::SHADER_CANVAS_ITEM;
	_ShaderMode[(new std::string("SHADER_PARTICLES"))->c_str()] = RenderingServer::ShaderMode::SHADER_PARTICLES;
	_ShaderMode[(new std::string("SHADER_SKY"))->c_str()] = RenderingServer::ShaderMode::SHADER_SKY;
	_ShaderMode[(new std::string("SHADER_FOG"))->c_str()] = RenderingServer::ShaderMode::SHADER_FOG;
	_ShaderMode[(new std::string("SHADER_MAX"))->c_str()] = RenderingServer::ShaderMode::SHADER_MAX;
	js_singleton[(new std::string("ShaderMode"))->c_str()] = _ShaderMode;
	qjs::Value _ArrayType = context->newObject();
	_ArrayType[(new std::string("ARRAY_VERTEX"))->c_str()] = RenderingServer::ArrayType::ARRAY_VERTEX;
	_ArrayType[(new std::string("ARRAY_NORMAL"))->c_str()] = RenderingServer::ArrayType::ARRAY_NORMAL;
	_ArrayType[(new std::string("ARRAY_TANGENT"))->c_str()] = RenderingServer::ArrayType::ARRAY_TANGENT;
	_ArrayType[(new std::string("ARRAY_COLOR"))->c_str()] = RenderingServer::ArrayType::ARRAY_COLOR;
	_ArrayType[(new std::string("ARRAY_TEX_UV"))->c_str()] = RenderingServer::ArrayType::ARRAY_TEX_UV;
	_ArrayType[(new std::string("ARRAY_TEX_UV2"))->c_str()] = RenderingServer::ArrayType::ARRAY_TEX_UV2;
	_ArrayType[(new std::string("ARRAY_CUSTOM0"))->c_str()] = RenderingServer::ArrayType::ARRAY_CUSTOM0;
	_ArrayType[(new std::string("ARRAY_CUSTOM1"))->c_str()] = RenderingServer::ArrayType::ARRAY_CUSTOM1;
	_ArrayType[(new std::string("ARRAY_CUSTOM2"))->c_str()] = RenderingServer::ArrayType::ARRAY_CUSTOM2;
	_ArrayType[(new std::string("ARRAY_CUSTOM3"))->c_str()] = RenderingServer::ArrayType::ARRAY_CUSTOM3;
	_ArrayType[(new std::string("ARRAY_BONES"))->c_str()] = RenderingServer::ArrayType::ARRAY_BONES;
	_ArrayType[(new std::string("ARRAY_WEIGHTS"))->c_str()] = RenderingServer::ArrayType::ARRAY_WEIGHTS;
	_ArrayType[(new std::string("ARRAY_INDEX"))->c_str()] = RenderingServer::ArrayType::ARRAY_INDEX;
	_ArrayType[(new std::string("ARRAY_MAX"))->c_str()] = RenderingServer::ArrayType::ARRAY_MAX;
	js_singleton[(new std::string("ArrayType"))->c_str()] = _ArrayType;
	qjs::Value _ArrayCustomFormat = context->newObject();
	_ArrayCustomFormat[(new std::string("ARRAY_CUSTOM_RGBA8_UNORM"))->c_str()] = RenderingServer::ArrayCustomFormat::ARRAY_CUSTOM_RGBA8_UNORM;
	_ArrayCustomFormat[(new std::string("ARRAY_CUSTOM_RGBA8_SNORM"))->c_str()] = RenderingServer::ArrayCustomFormat::ARRAY_CUSTOM_RGBA8_SNORM;
	_ArrayCustomFormat[(new std::string("ARRAY_CUSTOM_RG_HALF"))->c_str()] = RenderingServer::ArrayCustomFormat::ARRAY_CUSTOM_RG_HALF;
	_ArrayCustomFormat[(new std::string("ARRAY_CUSTOM_RGBA_HALF"))->c_str()] = RenderingServer::ArrayCustomFormat::ARRAY_CUSTOM_RGBA_HALF;
	_ArrayCustomFormat[(new std::string("ARRAY_CUSTOM_R_FLOAT"))->c_str()] = RenderingServer::ArrayCustomFormat::ARRAY_CUSTOM_R_FLOAT;
	_ArrayCustomFormat[(new std::string("ARRAY_CUSTOM_RG_FLOAT"))->c_str()] = RenderingServer::ArrayCustomFormat::ARRAY_CUSTOM_RG_FLOAT;
	_ArrayCustomFormat[(new std::string("ARRAY_CUSTOM_RGB_FLOAT"))->c_str()] = RenderingServer::ArrayCustomFormat::ARRAY_CUSTOM_RGB_FLOAT;
	_ArrayCustomFormat[(new std::string("ARRAY_CUSTOM_RGBA_FLOAT"))->c_str()] = RenderingServer::ArrayCustomFormat::ARRAY_CUSTOM_RGBA_FLOAT;
	_ArrayCustomFormat[(new std::string("ARRAY_CUSTOM_MAX"))->c_str()] = RenderingServer::ArrayCustomFormat::ARRAY_CUSTOM_MAX;
	js_singleton[(new std::string("ArrayCustomFormat"))->c_str()] = _ArrayCustomFormat;
	qjs::Value _ArrayFormat = context->newObject();
	_ArrayFormat[(new std::string("ARRAY_FORMAT_VERTEX"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_FORMAT_VERTEX;
	_ArrayFormat[(new std::string("ARRAY_FORMAT_NORMAL"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_FORMAT_NORMAL;
	_ArrayFormat[(new std::string("ARRAY_FORMAT_TANGENT"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_FORMAT_TANGENT;
	_ArrayFormat[(new std::string("ARRAY_FORMAT_COLOR"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_FORMAT_COLOR;
	_ArrayFormat[(new std::string("ARRAY_FORMAT_TEX_UV"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_FORMAT_TEX_UV;
	_ArrayFormat[(new std::string("ARRAY_FORMAT_TEX_UV2"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_FORMAT_TEX_UV2;
	_ArrayFormat[(new std::string("ARRAY_FORMAT_CUSTOM0"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_FORMAT_CUSTOM0;
	_ArrayFormat[(new std::string("ARRAY_FORMAT_CUSTOM1"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_FORMAT_CUSTOM1;
	_ArrayFormat[(new std::string("ARRAY_FORMAT_CUSTOM2"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_FORMAT_CUSTOM2;
	_ArrayFormat[(new std::string("ARRAY_FORMAT_CUSTOM3"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_FORMAT_CUSTOM3;
	_ArrayFormat[(new std::string("ARRAY_FORMAT_BONES"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_FORMAT_BONES;
	_ArrayFormat[(new std::string("ARRAY_FORMAT_WEIGHTS"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_FORMAT_WEIGHTS;
	_ArrayFormat[(new std::string("ARRAY_FORMAT_INDEX"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_FORMAT_INDEX;
	_ArrayFormat[(new std::string("ARRAY_FORMAT_BLEND_SHAPE_MASK"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_FORMAT_BLEND_SHAPE_MASK;
	_ArrayFormat[(new std::string("ARRAY_FORMAT_CUSTOM_BASE"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_FORMAT_CUSTOM_BASE;
	_ArrayFormat[(new std::string("ARRAY_FORMAT_CUSTOM_BITS"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_FORMAT_CUSTOM_BITS;
	_ArrayFormat[(new std::string("ARRAY_FORMAT_CUSTOM0_SHIFT"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_FORMAT_CUSTOM0_SHIFT;
	_ArrayFormat[(new std::string("ARRAY_FORMAT_CUSTOM1_SHIFT"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_FORMAT_CUSTOM1_SHIFT;
	_ArrayFormat[(new std::string("ARRAY_FORMAT_CUSTOM2_SHIFT"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_FORMAT_CUSTOM2_SHIFT;
	_ArrayFormat[(new std::string("ARRAY_FORMAT_CUSTOM3_SHIFT"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_FORMAT_CUSTOM3_SHIFT;
	_ArrayFormat[(new std::string("ARRAY_FORMAT_CUSTOM_MASK"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_FORMAT_CUSTOM_MASK;
	_ArrayFormat[(new std::string("ARRAY_COMPRESS_FLAGS_BASE"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_COMPRESS_FLAGS_BASE;
	_ArrayFormat[(new std::string("ARRAY_FLAG_USE_2D_VERTICES"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_FLAG_USE_2D_VERTICES;
	_ArrayFormat[(new std::string("ARRAY_FLAG_USE_DYNAMIC_UPDATE"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_FLAG_USE_DYNAMIC_UPDATE;
	_ArrayFormat[(new std::string("ARRAY_FLAG_USE_8_BONE_WEIGHTS"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_FLAG_USE_8_BONE_WEIGHTS;
	_ArrayFormat[(new std::string("ARRAY_FLAG_USES_EMPTY_VERTEX_ARRAY"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_FLAG_USES_EMPTY_VERTEX_ARRAY;
	_ArrayFormat[(new std::string("ARRAY_FLAG_COMPRESS_ATTRIBUTES"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_FLAG_COMPRESS_ATTRIBUTES;
	_ArrayFormat[(new std::string("ARRAY_FLAG_FORMAT_VERSION_BASE"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_FLAG_FORMAT_VERSION_BASE;
	_ArrayFormat[(new std::string("ARRAY_FLAG_FORMAT_VERSION_SHIFT"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_FLAG_FORMAT_VERSION_SHIFT;
	_ArrayFormat[(new std::string("ARRAY_FLAG_FORMAT_VERSION_1"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_FLAG_FORMAT_VERSION_1;
	_ArrayFormat[(new std::string("ARRAY_FLAG_FORMAT_VERSION_2"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_FLAG_FORMAT_VERSION_2;
	_ArrayFormat[(new std::string("ARRAY_FLAG_FORMAT_CURRENT_VERSION"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_FLAG_FORMAT_CURRENT_VERSION;
	_ArrayFormat[(new std::string("ARRAY_FLAG_FORMAT_VERSION_MASK"))->c_str()] = RenderingServer::ArrayFormat::ARRAY_FLAG_FORMAT_VERSION_MASK;
	js_singleton[(new std::string("ArrayFormat"))->c_str()] = _ArrayFormat;
	qjs::Value _PrimitiveType = context->newObject();
	_PrimitiveType[(new std::string("PRIMITIVE_POINTS"))->c_str()] = RenderingServer::PrimitiveType::PRIMITIVE_POINTS;
	_PrimitiveType[(new std::string("PRIMITIVE_LINES"))->c_str()] = RenderingServer::PrimitiveType::PRIMITIVE_LINES;
	_PrimitiveType[(new std::string("PRIMITIVE_LINE_STRIP"))->c_str()] = RenderingServer::PrimitiveType::PRIMITIVE_LINE_STRIP;
	_PrimitiveType[(new std::string("PRIMITIVE_TRIANGLES"))->c_str()] = RenderingServer::PrimitiveType::PRIMITIVE_TRIANGLES;
	_PrimitiveType[(new std::string("PRIMITIVE_TRIANGLE_STRIP"))->c_str()] = RenderingServer::PrimitiveType::PRIMITIVE_TRIANGLE_STRIP;
	_PrimitiveType[(new std::string("PRIMITIVE_MAX"))->c_str()] = RenderingServer::PrimitiveType::PRIMITIVE_MAX;
	js_singleton[(new std::string("PrimitiveType"))->c_str()] = _PrimitiveType;
	qjs::Value _BlendShapeMode = context->newObject();
	_BlendShapeMode[(new std::string("BLEND_SHAPE_MODE_NORMALIZED"))->c_str()] = RenderingServer::BlendShapeMode::BLEND_SHAPE_MODE_NORMALIZED;
	_BlendShapeMode[(new std::string("BLEND_SHAPE_MODE_RELATIVE"))->c_str()] = RenderingServer::BlendShapeMode::BLEND_SHAPE_MODE_RELATIVE;
	js_singleton[(new std::string("BlendShapeMode"))->c_str()] = _BlendShapeMode;
	qjs::Value _MultimeshTransformFormat = context->newObject();
	_MultimeshTransformFormat[(new std::string("MULTIMESH_TRANSFORM_2D"))->c_str()] = RenderingServer::MultimeshTransformFormat::MULTIMESH_TRANSFORM_2D;
	_MultimeshTransformFormat[(new std::string("MULTIMESH_TRANSFORM_3D"))->c_str()] = RenderingServer::MultimeshTransformFormat::MULTIMESH_TRANSFORM_3D;
	js_singleton[(new std::string("MultimeshTransformFormat"))->c_str()] = _MultimeshTransformFormat;
	qjs::Value _LightProjectorFilter = context->newObject();
	_LightProjectorFilter[(new std::string("LIGHT_PROJECTOR_FILTER_NEAREST"))->c_str()] = RenderingServer::LightProjectorFilter::LIGHT_PROJECTOR_FILTER_NEAREST;
	_LightProjectorFilter[(new std::string("LIGHT_PROJECTOR_FILTER_LINEAR"))->c_str()] = RenderingServer::LightProjectorFilter::LIGHT_PROJECTOR_FILTER_LINEAR;
	_LightProjectorFilter[(new std::string("LIGHT_PROJECTOR_FILTER_NEAREST_MIPMAPS"))->c_str()] = RenderingServer::LightProjectorFilter::LIGHT_PROJECTOR_FILTER_NEAREST_MIPMAPS;
	_LightProjectorFilter[(new std::string("LIGHT_PROJECTOR_FILTER_LINEAR_MIPMAPS"))->c_str()] = RenderingServer::LightProjectorFilter::LIGHT_PROJECTOR_FILTER_LINEAR_MIPMAPS;
	_LightProjectorFilter[(new std::string("LIGHT_PROJECTOR_FILTER_NEAREST_MIPMAPS_ANISOTROPIC"))->c_str()] = RenderingServer::LightProjectorFilter::LIGHT_PROJECTOR_FILTER_NEAREST_MIPMAPS_ANISOTROPIC;
	_LightProjectorFilter[(new std::string("LIGHT_PROJECTOR_FILTER_LINEAR_MIPMAPS_ANISOTROPIC"))->c_str()] = RenderingServer::LightProjectorFilter::LIGHT_PROJECTOR_FILTER_LINEAR_MIPMAPS_ANISOTROPIC;
	js_singleton[(new std::string("LightProjectorFilter"))->c_str()] = _LightProjectorFilter;
	qjs::Value _LightType = context->newObject();
	_LightType[(new std::string("LIGHT_DIRECTIONAL"))->c_str()] = RenderingServer::LightType::LIGHT_DIRECTIONAL;
	_LightType[(new std::string("LIGHT_OMNI"))->c_str()] = RenderingServer::LightType::LIGHT_OMNI;
	_LightType[(new std::string("LIGHT_SPOT"))->c_str()] = RenderingServer::LightType::LIGHT_SPOT;
	js_singleton[(new std::string("LightType"))->c_str()] = _LightType;
	qjs::Value _LightParam = context->newObject();
	_LightParam[(new std::string("LIGHT_PARAM_ENERGY"))->c_str()] = RenderingServer::LightParam::LIGHT_PARAM_ENERGY;
	_LightParam[(new std::string("LIGHT_PARAM_INDIRECT_ENERGY"))->c_str()] = RenderingServer::LightParam::LIGHT_PARAM_INDIRECT_ENERGY;
	_LightParam[(new std::string("LIGHT_PARAM_VOLUMETRIC_FOG_ENERGY"))->c_str()] = RenderingServer::LightParam::LIGHT_PARAM_VOLUMETRIC_FOG_ENERGY;
	_LightParam[(new std::string("LIGHT_PARAM_SPECULAR"))->c_str()] = RenderingServer::LightParam::LIGHT_PARAM_SPECULAR;
	_LightParam[(new std::string("LIGHT_PARAM_RANGE"))->c_str()] = RenderingServer::LightParam::LIGHT_PARAM_RANGE;
	_LightParam[(new std::string("LIGHT_PARAM_SIZE"))->c_str()] = RenderingServer::LightParam::LIGHT_PARAM_SIZE;
	_LightParam[(new std::string("LIGHT_PARAM_ATTENUATION"))->c_str()] = RenderingServer::LightParam::LIGHT_PARAM_ATTENUATION;
	_LightParam[(new std::string("LIGHT_PARAM_SPOT_ANGLE"))->c_str()] = RenderingServer::LightParam::LIGHT_PARAM_SPOT_ANGLE;
	_LightParam[(new std::string("LIGHT_PARAM_SPOT_ATTENUATION"))->c_str()] = RenderingServer::LightParam::LIGHT_PARAM_SPOT_ATTENUATION;
	_LightParam[(new std::string("LIGHT_PARAM_SHADOW_MAX_DISTANCE"))->c_str()] = RenderingServer::LightParam::LIGHT_PARAM_SHADOW_MAX_DISTANCE;
	_LightParam[(new std::string("LIGHT_PARAM_SHADOW_SPLIT_1_OFFSET"))->c_str()] = RenderingServer::LightParam::LIGHT_PARAM_SHADOW_SPLIT_1_OFFSET;
	_LightParam[(new std::string("LIGHT_PARAM_SHADOW_SPLIT_2_OFFSET"))->c_str()] = RenderingServer::LightParam::LIGHT_PARAM_SHADOW_SPLIT_2_OFFSET;
	_LightParam[(new std::string("LIGHT_PARAM_SHADOW_SPLIT_3_OFFSET"))->c_str()] = RenderingServer::LightParam::LIGHT_PARAM_SHADOW_SPLIT_3_OFFSET;
	_LightParam[(new std::string("LIGHT_PARAM_SHADOW_FADE_START"))->c_str()] = RenderingServer::LightParam::LIGHT_PARAM_SHADOW_FADE_START;
	_LightParam[(new std::string("LIGHT_PARAM_SHADOW_NORMAL_BIAS"))->c_str()] = RenderingServer::LightParam::LIGHT_PARAM_SHADOW_NORMAL_BIAS;
	_LightParam[(new std::string("LIGHT_PARAM_SHADOW_BIAS"))->c_str()] = RenderingServer::LightParam::LIGHT_PARAM_SHADOW_BIAS;
	_LightParam[(new std::string("LIGHT_PARAM_SHADOW_PANCAKE_SIZE"))->c_str()] = RenderingServer::LightParam::LIGHT_PARAM_SHADOW_PANCAKE_SIZE;
	_LightParam[(new std::string("LIGHT_PARAM_SHADOW_OPACITY"))->c_str()] = RenderingServer::LightParam::LIGHT_PARAM_SHADOW_OPACITY;
	_LightParam[(new std::string("LIGHT_PARAM_SHADOW_BLUR"))->c_str()] = RenderingServer::LightParam::LIGHT_PARAM_SHADOW_BLUR;
	_LightParam[(new std::string("LIGHT_PARAM_TRANSMITTANCE_BIAS"))->c_str()] = RenderingServer::LightParam::LIGHT_PARAM_TRANSMITTANCE_BIAS;
	_LightParam[(new std::string("LIGHT_PARAM_INTENSITY"))->c_str()] = RenderingServer::LightParam::LIGHT_PARAM_INTENSITY;
	_LightParam[(new std::string("LIGHT_PARAM_MAX"))->c_str()] = RenderingServer::LightParam::LIGHT_PARAM_MAX;
	js_singleton[(new std::string("LightParam"))->c_str()] = _LightParam;
	qjs::Value _LightBakeMode = context->newObject();
	_LightBakeMode[(new std::string("LIGHT_BAKE_DISABLED"))->c_str()] = RenderingServer::LightBakeMode::LIGHT_BAKE_DISABLED;
	_LightBakeMode[(new std::string("LIGHT_BAKE_STATIC"))->c_str()] = RenderingServer::LightBakeMode::LIGHT_BAKE_STATIC;
	_LightBakeMode[(new std::string("LIGHT_BAKE_DYNAMIC"))->c_str()] = RenderingServer::LightBakeMode::LIGHT_BAKE_DYNAMIC;
	js_singleton[(new std::string("LightBakeMode"))->c_str()] = _LightBakeMode;
	qjs::Value _LightOmniShadowMode = context->newObject();
	_LightOmniShadowMode[(new std::string("LIGHT_OMNI_SHADOW_DUAL_PARABOLOID"))->c_str()] = RenderingServer::LightOmniShadowMode::LIGHT_OMNI_SHADOW_DUAL_PARABOLOID;
	_LightOmniShadowMode[(new std::string("LIGHT_OMNI_SHADOW_CUBE"))->c_str()] = RenderingServer::LightOmniShadowMode::LIGHT_OMNI_SHADOW_CUBE;
	js_singleton[(new std::string("LightOmniShadowMode"))->c_str()] = _LightOmniShadowMode;
	qjs::Value _LightDirectionalShadowMode = context->newObject();
	_LightDirectionalShadowMode[(new std::string("LIGHT_DIRECTIONAL_SHADOW_ORTHOGONAL"))->c_str()] = RenderingServer::LightDirectionalShadowMode::LIGHT_DIRECTIONAL_SHADOW_ORTHOGONAL;
	_LightDirectionalShadowMode[(new std::string("LIGHT_DIRECTIONAL_SHADOW_PARALLEL_2_SPLITS"))->c_str()] = RenderingServer::LightDirectionalShadowMode::LIGHT_DIRECTIONAL_SHADOW_PARALLEL_2_SPLITS;
	_LightDirectionalShadowMode[(new std::string("LIGHT_DIRECTIONAL_SHADOW_PARALLEL_4_SPLITS"))->c_str()] = RenderingServer::LightDirectionalShadowMode::LIGHT_DIRECTIONAL_SHADOW_PARALLEL_4_SPLITS;
	js_singleton[(new std::string("LightDirectionalShadowMode"))->c_str()] = _LightDirectionalShadowMode;
	qjs::Value _LightDirectionalSkyMode = context->newObject();
	_LightDirectionalSkyMode[(new std::string("LIGHT_DIRECTIONAL_SKY_MODE_LIGHT_AND_SKY"))->c_str()] = RenderingServer::LightDirectionalSkyMode::LIGHT_DIRECTIONAL_SKY_MODE_LIGHT_AND_SKY;
	_LightDirectionalSkyMode[(new std::string("LIGHT_DIRECTIONAL_SKY_MODE_LIGHT_ONLY"))->c_str()] = RenderingServer::LightDirectionalSkyMode::LIGHT_DIRECTIONAL_SKY_MODE_LIGHT_ONLY;
	_LightDirectionalSkyMode[(new std::string("LIGHT_DIRECTIONAL_SKY_MODE_SKY_ONLY"))->c_str()] = RenderingServer::LightDirectionalSkyMode::LIGHT_DIRECTIONAL_SKY_MODE_SKY_ONLY;
	js_singleton[(new std::string("LightDirectionalSkyMode"))->c_str()] = _LightDirectionalSkyMode;
	qjs::Value _ShadowQuality = context->newObject();
	_ShadowQuality[(new std::string("SHADOW_QUALITY_HARD"))->c_str()] = RenderingServer::ShadowQuality::SHADOW_QUALITY_HARD;
	_ShadowQuality[(new std::string("SHADOW_QUALITY_SOFT_VERY_LOW"))->c_str()] = RenderingServer::ShadowQuality::SHADOW_QUALITY_SOFT_VERY_LOW;
	_ShadowQuality[(new std::string("SHADOW_QUALITY_SOFT_LOW"))->c_str()] = RenderingServer::ShadowQuality::SHADOW_QUALITY_SOFT_LOW;
	_ShadowQuality[(new std::string("SHADOW_QUALITY_SOFT_MEDIUM"))->c_str()] = RenderingServer::ShadowQuality::SHADOW_QUALITY_SOFT_MEDIUM;
	_ShadowQuality[(new std::string("SHADOW_QUALITY_SOFT_HIGH"))->c_str()] = RenderingServer::ShadowQuality::SHADOW_QUALITY_SOFT_HIGH;
	_ShadowQuality[(new std::string("SHADOW_QUALITY_SOFT_ULTRA"))->c_str()] = RenderingServer::ShadowQuality::SHADOW_QUALITY_SOFT_ULTRA;
	_ShadowQuality[(new std::string("SHADOW_QUALITY_MAX"))->c_str()] = RenderingServer::ShadowQuality::SHADOW_QUALITY_MAX;
	js_singleton[(new std::string("ShadowQuality"))->c_str()] = _ShadowQuality;
	qjs::Value _ReflectionProbeUpdateMode = context->newObject();
	_ReflectionProbeUpdateMode[(new std::string("REFLECTION_PROBE_UPDATE_ONCE"))->c_str()] = RenderingServer::ReflectionProbeUpdateMode::REFLECTION_PROBE_UPDATE_ONCE;
	_ReflectionProbeUpdateMode[(new std::string("REFLECTION_PROBE_UPDATE_ALWAYS"))->c_str()] = RenderingServer::ReflectionProbeUpdateMode::REFLECTION_PROBE_UPDATE_ALWAYS;
	js_singleton[(new std::string("ReflectionProbeUpdateMode"))->c_str()] = _ReflectionProbeUpdateMode;
	qjs::Value _ReflectionProbeAmbientMode = context->newObject();
	_ReflectionProbeAmbientMode[(new std::string("REFLECTION_PROBE_AMBIENT_DISABLED"))->c_str()] = RenderingServer::ReflectionProbeAmbientMode::REFLECTION_PROBE_AMBIENT_DISABLED;
	_ReflectionProbeAmbientMode[(new std::string("REFLECTION_PROBE_AMBIENT_ENVIRONMENT"))->c_str()] = RenderingServer::ReflectionProbeAmbientMode::REFLECTION_PROBE_AMBIENT_ENVIRONMENT;
	_ReflectionProbeAmbientMode[(new std::string("REFLECTION_PROBE_AMBIENT_COLOR"))->c_str()] = RenderingServer::ReflectionProbeAmbientMode::REFLECTION_PROBE_AMBIENT_COLOR;
	js_singleton[(new std::string("ReflectionProbeAmbientMode"))->c_str()] = _ReflectionProbeAmbientMode;
	qjs::Value _DecalTexture = context->newObject();
	_DecalTexture[(new std::string("DECAL_TEXTURE_ALBEDO"))->c_str()] = RenderingServer::DecalTexture::DECAL_TEXTURE_ALBEDO;
	_DecalTexture[(new std::string("DECAL_TEXTURE_NORMAL"))->c_str()] = RenderingServer::DecalTexture::DECAL_TEXTURE_NORMAL;
	_DecalTexture[(new std::string("DECAL_TEXTURE_ORM"))->c_str()] = RenderingServer::DecalTexture::DECAL_TEXTURE_ORM;
	_DecalTexture[(new std::string("DECAL_TEXTURE_EMISSION"))->c_str()] = RenderingServer::DecalTexture::DECAL_TEXTURE_EMISSION;
	_DecalTexture[(new std::string("DECAL_TEXTURE_MAX"))->c_str()] = RenderingServer::DecalTexture::DECAL_TEXTURE_MAX;
	js_singleton[(new std::string("DecalTexture"))->c_str()] = _DecalTexture;
	qjs::Value _DecalFilter = context->newObject();
	_DecalFilter[(new std::string("DECAL_FILTER_NEAREST"))->c_str()] = RenderingServer::DecalFilter::DECAL_FILTER_NEAREST;
	_DecalFilter[(new std::string("DECAL_FILTER_LINEAR"))->c_str()] = RenderingServer::DecalFilter::DECAL_FILTER_LINEAR;
	_DecalFilter[(new std::string("DECAL_FILTER_NEAREST_MIPMAPS"))->c_str()] = RenderingServer::DecalFilter::DECAL_FILTER_NEAREST_MIPMAPS;
	_DecalFilter[(new std::string("DECAL_FILTER_LINEAR_MIPMAPS"))->c_str()] = RenderingServer::DecalFilter::DECAL_FILTER_LINEAR_MIPMAPS;
	_DecalFilter[(new std::string("DECAL_FILTER_NEAREST_MIPMAPS_ANISOTROPIC"))->c_str()] = RenderingServer::DecalFilter::DECAL_FILTER_NEAREST_MIPMAPS_ANISOTROPIC;
	_DecalFilter[(new std::string("DECAL_FILTER_LINEAR_MIPMAPS_ANISOTROPIC"))->c_str()] = RenderingServer::DecalFilter::DECAL_FILTER_LINEAR_MIPMAPS_ANISOTROPIC;
	js_singleton[(new std::string("DecalFilter"))->c_str()] = _DecalFilter;
	qjs::Value _VoxelGIQuality = context->newObject();
	_VoxelGIQuality[(new std::string("VOXEL_GI_QUALITY_LOW"))->c_str()] = RenderingServer::VoxelGIQuality::VOXEL_GI_QUALITY_LOW;
	_VoxelGIQuality[(new std::string("VOXEL_GI_QUALITY_HIGH"))->c_str()] = RenderingServer::VoxelGIQuality::VOXEL_GI_QUALITY_HIGH;
	js_singleton[(new std::string("VoxelGIQuality"))->c_str()] = _VoxelGIQuality;
	qjs::Value _ParticlesMode = context->newObject();
	_ParticlesMode[(new std::string("PARTICLES_MODE_2D"))->c_str()] = RenderingServer::ParticlesMode::PARTICLES_MODE_2D;
	_ParticlesMode[(new std::string("PARTICLES_MODE_3D"))->c_str()] = RenderingServer::ParticlesMode::PARTICLES_MODE_3D;
	js_singleton[(new std::string("ParticlesMode"))->c_str()] = _ParticlesMode;
	qjs::Value _ParticlesTransformAlign = context->newObject();
	_ParticlesTransformAlign[(new std::string("PARTICLES_TRANSFORM_ALIGN_DISABLED"))->c_str()] = RenderingServer::ParticlesTransformAlign::PARTICLES_TRANSFORM_ALIGN_DISABLED;
	_ParticlesTransformAlign[(new std::string("PARTICLES_TRANSFORM_ALIGN_Z_BILLBOARD"))->c_str()] = RenderingServer::ParticlesTransformAlign::PARTICLES_TRANSFORM_ALIGN_Z_BILLBOARD;
	_ParticlesTransformAlign[(new std::string("PARTICLES_TRANSFORM_ALIGN_Y_TO_VELOCITY"))->c_str()] = RenderingServer::ParticlesTransformAlign::PARTICLES_TRANSFORM_ALIGN_Y_TO_VELOCITY;
	_ParticlesTransformAlign[(new std::string("PARTICLES_TRANSFORM_ALIGN_Z_BILLBOARD_Y_TO_VELOCITY"))->c_str()] = RenderingServer::ParticlesTransformAlign::PARTICLES_TRANSFORM_ALIGN_Z_BILLBOARD_Y_TO_VELOCITY;
	js_singleton[(new std::string("ParticlesTransformAlign"))->c_str()] = _ParticlesTransformAlign;
	qjs::Value _ParticlesDrawOrder = context->newObject();
	_ParticlesDrawOrder[(new std::string("PARTICLES_DRAW_ORDER_INDEX"))->c_str()] = RenderingServer::ParticlesDrawOrder::PARTICLES_DRAW_ORDER_INDEX;
	_ParticlesDrawOrder[(new std::string("PARTICLES_DRAW_ORDER_LIFETIME"))->c_str()] = RenderingServer::ParticlesDrawOrder::PARTICLES_DRAW_ORDER_LIFETIME;
	_ParticlesDrawOrder[(new std::string("PARTICLES_DRAW_ORDER_REVERSE_LIFETIME"))->c_str()] = RenderingServer::ParticlesDrawOrder::PARTICLES_DRAW_ORDER_REVERSE_LIFETIME;
	_ParticlesDrawOrder[(new std::string("PARTICLES_DRAW_ORDER_VIEW_DEPTH"))->c_str()] = RenderingServer::ParticlesDrawOrder::PARTICLES_DRAW_ORDER_VIEW_DEPTH;
	js_singleton[(new std::string("ParticlesDrawOrder"))->c_str()] = _ParticlesDrawOrder;
	qjs::Value _ParticlesCollisionType = context->newObject();
	_ParticlesCollisionType[(new std::string("PARTICLES_COLLISION_TYPE_SPHERE_ATTRACT"))->c_str()] = RenderingServer::ParticlesCollisionType::PARTICLES_COLLISION_TYPE_SPHERE_ATTRACT;
	_ParticlesCollisionType[(new std::string("PARTICLES_COLLISION_TYPE_BOX_ATTRACT"))->c_str()] = RenderingServer::ParticlesCollisionType::PARTICLES_COLLISION_TYPE_BOX_ATTRACT;
	_ParticlesCollisionType[(new std::string("PARTICLES_COLLISION_TYPE_VECTOR_FIELD_ATTRACT"))->c_str()] = RenderingServer::ParticlesCollisionType::PARTICLES_COLLISION_TYPE_VECTOR_FIELD_ATTRACT;
	_ParticlesCollisionType[(new std::string("PARTICLES_COLLISION_TYPE_SPHERE_COLLIDE"))->c_str()] = RenderingServer::ParticlesCollisionType::PARTICLES_COLLISION_TYPE_SPHERE_COLLIDE;
	_ParticlesCollisionType[(new std::string("PARTICLES_COLLISION_TYPE_BOX_COLLIDE"))->c_str()] = RenderingServer::ParticlesCollisionType::PARTICLES_COLLISION_TYPE_BOX_COLLIDE;
	_ParticlesCollisionType[(new std::string("PARTICLES_COLLISION_TYPE_SDF_COLLIDE"))->c_str()] = RenderingServer::ParticlesCollisionType::PARTICLES_COLLISION_TYPE_SDF_COLLIDE;
	_ParticlesCollisionType[(new std::string("PARTICLES_COLLISION_TYPE_HEIGHTFIELD_COLLIDE"))->c_str()] = RenderingServer::ParticlesCollisionType::PARTICLES_COLLISION_TYPE_HEIGHTFIELD_COLLIDE;
	js_singleton[(new std::string("ParticlesCollisionType"))->c_str()] = _ParticlesCollisionType;
	qjs::Value _ParticlesCollisionHeightfieldResolution = context->newObject();
	_ParticlesCollisionHeightfieldResolution[(new std::string("PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_256"))->c_str()] = RenderingServer::ParticlesCollisionHeightfieldResolution::PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_256;
	_ParticlesCollisionHeightfieldResolution[(new std::string("PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_512"))->c_str()] = RenderingServer::ParticlesCollisionHeightfieldResolution::PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_512;
	_ParticlesCollisionHeightfieldResolution[(new std::string("PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_1024"))->c_str()] = RenderingServer::ParticlesCollisionHeightfieldResolution::PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_1024;
	_ParticlesCollisionHeightfieldResolution[(new std::string("PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_2048"))->c_str()] = RenderingServer::ParticlesCollisionHeightfieldResolution::PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_2048;
	_ParticlesCollisionHeightfieldResolution[(new std::string("PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_4096"))->c_str()] = RenderingServer::ParticlesCollisionHeightfieldResolution::PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_4096;
	_ParticlesCollisionHeightfieldResolution[(new std::string("PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_8192"))->c_str()] = RenderingServer::ParticlesCollisionHeightfieldResolution::PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_8192;
	_ParticlesCollisionHeightfieldResolution[(new std::string("PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_MAX"))->c_str()] = RenderingServer::ParticlesCollisionHeightfieldResolution::PARTICLES_COLLISION_HEIGHTFIELD_RESOLUTION_MAX;
	js_singleton[(new std::string("ParticlesCollisionHeightfieldResolution"))->c_str()] = _ParticlesCollisionHeightfieldResolution;
	qjs::Value _FogVolumeShape = context->newObject();
	_FogVolumeShape[(new std::string("FOG_VOLUME_SHAPE_ELLIPSOID"))->c_str()] = RenderingServer::FogVolumeShape::FOG_VOLUME_SHAPE_ELLIPSOID;
	_FogVolumeShape[(new std::string("FOG_VOLUME_SHAPE_CONE"))->c_str()] = RenderingServer::FogVolumeShape::FOG_VOLUME_SHAPE_CONE;
	_FogVolumeShape[(new std::string("FOG_VOLUME_SHAPE_CYLINDER"))->c_str()] = RenderingServer::FogVolumeShape::FOG_VOLUME_SHAPE_CYLINDER;
	_FogVolumeShape[(new std::string("FOG_VOLUME_SHAPE_BOX"))->c_str()] = RenderingServer::FogVolumeShape::FOG_VOLUME_SHAPE_BOX;
	_FogVolumeShape[(new std::string("FOG_VOLUME_SHAPE_WORLD"))->c_str()] = RenderingServer::FogVolumeShape::FOG_VOLUME_SHAPE_WORLD;
	_FogVolumeShape[(new std::string("FOG_VOLUME_SHAPE_MAX"))->c_str()] = RenderingServer::FogVolumeShape::FOG_VOLUME_SHAPE_MAX;
	js_singleton[(new std::string("FogVolumeShape"))->c_str()] = _FogVolumeShape;
	qjs::Value _ViewportScaling3DMode = context->newObject();
	_ViewportScaling3DMode[(new std::string("VIEWPORT_SCALING_3D_MODE_BILINEAR"))->c_str()] = RenderingServer::ViewportScaling3DMode::VIEWPORT_SCALING_3D_MODE_BILINEAR;
	_ViewportScaling3DMode[(new std::string("VIEWPORT_SCALING_3D_MODE_FSR"))->c_str()] = RenderingServer::ViewportScaling3DMode::VIEWPORT_SCALING_3D_MODE_FSR;
	_ViewportScaling3DMode[(new std::string("VIEWPORT_SCALING_3D_MODE_FSR2"))->c_str()] = RenderingServer::ViewportScaling3DMode::VIEWPORT_SCALING_3D_MODE_FSR2;
	_ViewportScaling3DMode[(new std::string("VIEWPORT_SCALING_3D_MODE_MAX"))->c_str()] = RenderingServer::ViewportScaling3DMode::VIEWPORT_SCALING_3D_MODE_MAX;
	js_singleton[(new std::string("ViewportScaling3DMode"))->c_str()] = _ViewportScaling3DMode;
	qjs::Value _ViewportUpdateMode = context->newObject();
	_ViewportUpdateMode[(new std::string("VIEWPORT_UPDATE_DISABLED"))->c_str()] = RenderingServer::ViewportUpdateMode::VIEWPORT_UPDATE_DISABLED;
	_ViewportUpdateMode[(new std::string("VIEWPORT_UPDATE_ONCE"))->c_str()] = RenderingServer::ViewportUpdateMode::VIEWPORT_UPDATE_ONCE;
	_ViewportUpdateMode[(new std::string("VIEWPORT_UPDATE_WHEN_VISIBLE"))->c_str()] = RenderingServer::ViewportUpdateMode::VIEWPORT_UPDATE_WHEN_VISIBLE;
	_ViewportUpdateMode[(new std::string("VIEWPORT_UPDATE_WHEN_PARENT_VISIBLE"))->c_str()] = RenderingServer::ViewportUpdateMode::VIEWPORT_UPDATE_WHEN_PARENT_VISIBLE;
	_ViewportUpdateMode[(new std::string("VIEWPORT_UPDATE_ALWAYS"))->c_str()] = RenderingServer::ViewportUpdateMode::VIEWPORT_UPDATE_ALWAYS;
	js_singleton[(new std::string("ViewportUpdateMode"))->c_str()] = _ViewportUpdateMode;
	qjs::Value _ViewportClearMode = context->newObject();
	_ViewportClearMode[(new std::string("VIEWPORT_CLEAR_ALWAYS"))->c_str()] = RenderingServer::ViewportClearMode::VIEWPORT_CLEAR_ALWAYS;
	_ViewportClearMode[(new std::string("VIEWPORT_CLEAR_NEVER"))->c_str()] = RenderingServer::ViewportClearMode::VIEWPORT_CLEAR_NEVER;
	_ViewportClearMode[(new std::string("VIEWPORT_CLEAR_ONLY_NEXT_FRAME"))->c_str()] = RenderingServer::ViewportClearMode::VIEWPORT_CLEAR_ONLY_NEXT_FRAME;
	js_singleton[(new std::string("ViewportClearMode"))->c_str()] = _ViewportClearMode;
	qjs::Value _ViewportEnvironmentMode = context->newObject();
	_ViewportEnvironmentMode[(new std::string("VIEWPORT_ENVIRONMENT_DISABLED"))->c_str()] = RenderingServer::ViewportEnvironmentMode::VIEWPORT_ENVIRONMENT_DISABLED;
	_ViewportEnvironmentMode[(new std::string("VIEWPORT_ENVIRONMENT_ENABLED"))->c_str()] = RenderingServer::ViewportEnvironmentMode::VIEWPORT_ENVIRONMENT_ENABLED;
	_ViewportEnvironmentMode[(new std::string("VIEWPORT_ENVIRONMENT_INHERIT"))->c_str()] = RenderingServer::ViewportEnvironmentMode::VIEWPORT_ENVIRONMENT_INHERIT;
	_ViewportEnvironmentMode[(new std::string("VIEWPORT_ENVIRONMENT_MAX"))->c_str()] = RenderingServer::ViewportEnvironmentMode::VIEWPORT_ENVIRONMENT_MAX;
	js_singleton[(new std::string("ViewportEnvironmentMode"))->c_str()] = _ViewportEnvironmentMode;
	qjs::Value _ViewportSDFOversize = context->newObject();
	_ViewportSDFOversize[(new std::string("VIEWPORT_SDF_OVERSIZE_100_PERCENT"))->c_str()] = RenderingServer::ViewportSDFOversize::VIEWPORT_SDF_OVERSIZE_100_PERCENT;
	_ViewportSDFOversize[(new std::string("VIEWPORT_SDF_OVERSIZE_120_PERCENT"))->c_str()] = RenderingServer::ViewportSDFOversize::VIEWPORT_SDF_OVERSIZE_120_PERCENT;
	_ViewportSDFOversize[(new std::string("VIEWPORT_SDF_OVERSIZE_150_PERCENT"))->c_str()] = RenderingServer::ViewportSDFOversize::VIEWPORT_SDF_OVERSIZE_150_PERCENT;
	_ViewportSDFOversize[(new std::string("VIEWPORT_SDF_OVERSIZE_200_PERCENT"))->c_str()] = RenderingServer::ViewportSDFOversize::VIEWPORT_SDF_OVERSIZE_200_PERCENT;
	_ViewportSDFOversize[(new std::string("VIEWPORT_SDF_OVERSIZE_MAX"))->c_str()] = RenderingServer::ViewportSDFOversize::VIEWPORT_SDF_OVERSIZE_MAX;
	js_singleton[(new std::string("ViewportSDFOversize"))->c_str()] = _ViewportSDFOversize;
	qjs::Value _ViewportSDFScale = context->newObject();
	_ViewportSDFScale[(new std::string("VIEWPORT_SDF_SCALE_100_PERCENT"))->c_str()] = RenderingServer::ViewportSDFScale::VIEWPORT_SDF_SCALE_100_PERCENT;
	_ViewportSDFScale[(new std::string("VIEWPORT_SDF_SCALE_50_PERCENT"))->c_str()] = RenderingServer::ViewportSDFScale::VIEWPORT_SDF_SCALE_50_PERCENT;
	_ViewportSDFScale[(new std::string("VIEWPORT_SDF_SCALE_25_PERCENT"))->c_str()] = RenderingServer::ViewportSDFScale::VIEWPORT_SDF_SCALE_25_PERCENT;
	_ViewportSDFScale[(new std::string("VIEWPORT_SDF_SCALE_MAX"))->c_str()] = RenderingServer::ViewportSDFScale::VIEWPORT_SDF_SCALE_MAX;
	js_singleton[(new std::string("ViewportSDFScale"))->c_str()] = _ViewportSDFScale;
	qjs::Value _ViewportMSAA = context->newObject();
	_ViewportMSAA[(new std::string("VIEWPORT_MSAA_DISABLED"))->c_str()] = RenderingServer::ViewportMSAA::VIEWPORT_MSAA_DISABLED;
	_ViewportMSAA[(new std::string("VIEWPORT_MSAA_2X"))->c_str()] = RenderingServer::ViewportMSAA::VIEWPORT_MSAA_2X;
	_ViewportMSAA[(new std::string("VIEWPORT_MSAA_4X"))->c_str()] = RenderingServer::ViewportMSAA::VIEWPORT_MSAA_4X;
	_ViewportMSAA[(new std::string("VIEWPORT_MSAA_8X"))->c_str()] = RenderingServer::ViewportMSAA::VIEWPORT_MSAA_8X;
	_ViewportMSAA[(new std::string("VIEWPORT_MSAA_MAX"))->c_str()] = RenderingServer::ViewportMSAA::VIEWPORT_MSAA_MAX;
	js_singleton[(new std::string("ViewportMSAA"))->c_str()] = _ViewportMSAA;
	qjs::Value _ViewportScreenSpaceAA = context->newObject();
	_ViewportScreenSpaceAA[(new std::string("VIEWPORT_SCREEN_SPACE_AA_DISABLED"))->c_str()] = RenderingServer::ViewportScreenSpaceAA::VIEWPORT_SCREEN_SPACE_AA_DISABLED;
	_ViewportScreenSpaceAA[(new std::string("VIEWPORT_SCREEN_SPACE_AA_FXAA"))->c_str()] = RenderingServer::ViewportScreenSpaceAA::VIEWPORT_SCREEN_SPACE_AA_FXAA;
	_ViewportScreenSpaceAA[(new std::string("VIEWPORT_SCREEN_SPACE_AA_MAX"))->c_str()] = RenderingServer::ViewportScreenSpaceAA::VIEWPORT_SCREEN_SPACE_AA_MAX;
	js_singleton[(new std::string("ViewportScreenSpaceAA"))->c_str()] = _ViewportScreenSpaceAA;
	qjs::Value _ViewportOcclusionCullingBuildQuality = context->newObject();
	_ViewportOcclusionCullingBuildQuality[(new std::string("VIEWPORT_OCCLUSION_BUILD_QUALITY_LOW"))->c_str()] = RenderingServer::ViewportOcclusionCullingBuildQuality::VIEWPORT_OCCLUSION_BUILD_QUALITY_LOW;
	_ViewportOcclusionCullingBuildQuality[(new std::string("VIEWPORT_OCCLUSION_BUILD_QUALITY_MEDIUM"))->c_str()] = RenderingServer::ViewportOcclusionCullingBuildQuality::VIEWPORT_OCCLUSION_BUILD_QUALITY_MEDIUM;
	_ViewportOcclusionCullingBuildQuality[(new std::string("VIEWPORT_OCCLUSION_BUILD_QUALITY_HIGH"))->c_str()] = RenderingServer::ViewportOcclusionCullingBuildQuality::VIEWPORT_OCCLUSION_BUILD_QUALITY_HIGH;
	js_singleton[(new std::string("ViewportOcclusionCullingBuildQuality"))->c_str()] = _ViewportOcclusionCullingBuildQuality;
	qjs::Value _ViewportRenderInfo = context->newObject();
	_ViewportRenderInfo[(new std::string("VIEWPORT_RENDER_INFO_OBJECTS_IN_FRAME"))->c_str()] = RenderingServer::ViewportRenderInfo::VIEWPORT_RENDER_INFO_OBJECTS_IN_FRAME;
	_ViewportRenderInfo[(new std::string("VIEWPORT_RENDER_INFO_PRIMITIVES_IN_FRAME"))->c_str()] = RenderingServer::ViewportRenderInfo::VIEWPORT_RENDER_INFO_PRIMITIVES_IN_FRAME;
	_ViewportRenderInfo[(new std::string("VIEWPORT_RENDER_INFO_DRAW_CALLS_IN_FRAME"))->c_str()] = RenderingServer::ViewportRenderInfo::VIEWPORT_RENDER_INFO_DRAW_CALLS_IN_FRAME;
	_ViewportRenderInfo[(new std::string("VIEWPORT_RENDER_INFO_MAX"))->c_str()] = RenderingServer::ViewportRenderInfo::VIEWPORT_RENDER_INFO_MAX;
	js_singleton[(new std::string("ViewportRenderInfo"))->c_str()] = _ViewportRenderInfo;
	qjs::Value _ViewportRenderInfoType = context->newObject();
	_ViewportRenderInfoType[(new std::string("VIEWPORT_RENDER_INFO_TYPE_VISIBLE"))->c_str()] = RenderingServer::ViewportRenderInfoType::VIEWPORT_RENDER_INFO_TYPE_VISIBLE;
	_ViewportRenderInfoType[(new std::string("VIEWPORT_RENDER_INFO_TYPE_SHADOW"))->c_str()] = RenderingServer::ViewportRenderInfoType::VIEWPORT_RENDER_INFO_TYPE_SHADOW;
	_ViewportRenderInfoType[(new std::string("VIEWPORT_RENDER_INFO_TYPE_CANVAS"))->c_str()] = RenderingServer::ViewportRenderInfoType::VIEWPORT_RENDER_INFO_TYPE_CANVAS;
	_ViewportRenderInfoType[(new std::string("VIEWPORT_RENDER_INFO_TYPE_MAX"))->c_str()] = RenderingServer::ViewportRenderInfoType::VIEWPORT_RENDER_INFO_TYPE_MAX;
	js_singleton[(new std::string("ViewportRenderInfoType"))->c_str()] = _ViewportRenderInfoType;
	qjs::Value _ViewportDebugDraw = context->newObject();
	_ViewportDebugDraw[(new std::string("VIEWPORT_DEBUG_DRAW_DISABLED"))->c_str()] = RenderingServer::ViewportDebugDraw::VIEWPORT_DEBUG_DRAW_DISABLED;
	_ViewportDebugDraw[(new std::string("VIEWPORT_DEBUG_DRAW_UNSHADED"))->c_str()] = RenderingServer::ViewportDebugDraw::VIEWPORT_DEBUG_DRAW_UNSHADED;
	_ViewportDebugDraw[(new std::string("VIEWPORT_DEBUG_DRAW_LIGHTING"))->c_str()] = RenderingServer::ViewportDebugDraw::VIEWPORT_DEBUG_DRAW_LIGHTING;
	_ViewportDebugDraw[(new std::string("VIEWPORT_DEBUG_DRAW_OVERDRAW"))->c_str()] = RenderingServer::ViewportDebugDraw::VIEWPORT_DEBUG_DRAW_OVERDRAW;
	_ViewportDebugDraw[(new std::string("VIEWPORT_DEBUG_DRAW_WIREFRAME"))->c_str()] = RenderingServer::ViewportDebugDraw::VIEWPORT_DEBUG_DRAW_WIREFRAME;
	_ViewportDebugDraw[(new std::string("VIEWPORT_DEBUG_DRAW_NORMAL_BUFFER"))->c_str()] = RenderingServer::ViewportDebugDraw::VIEWPORT_DEBUG_DRAW_NORMAL_BUFFER;
	_ViewportDebugDraw[(new std::string("VIEWPORT_DEBUG_DRAW_VOXEL_GI_ALBEDO"))->c_str()] = RenderingServer::ViewportDebugDraw::VIEWPORT_DEBUG_DRAW_VOXEL_GI_ALBEDO;
	_ViewportDebugDraw[(new std::string("VIEWPORT_DEBUG_DRAW_VOXEL_GI_LIGHTING"))->c_str()] = RenderingServer::ViewportDebugDraw::VIEWPORT_DEBUG_DRAW_VOXEL_GI_LIGHTING;
	_ViewportDebugDraw[(new std::string("VIEWPORT_DEBUG_DRAW_VOXEL_GI_EMISSION"))->c_str()] = RenderingServer::ViewportDebugDraw::VIEWPORT_DEBUG_DRAW_VOXEL_GI_EMISSION;
	_ViewportDebugDraw[(new std::string("VIEWPORT_DEBUG_DRAW_SHADOW_ATLAS"))->c_str()] = RenderingServer::ViewportDebugDraw::VIEWPORT_DEBUG_DRAW_SHADOW_ATLAS;
	_ViewportDebugDraw[(new std::string("VIEWPORT_DEBUG_DRAW_DIRECTIONAL_SHADOW_ATLAS"))->c_str()] = RenderingServer::ViewportDebugDraw::VIEWPORT_DEBUG_DRAW_DIRECTIONAL_SHADOW_ATLAS;
	_ViewportDebugDraw[(new std::string("VIEWPORT_DEBUG_DRAW_SCENE_LUMINANCE"))->c_str()] = RenderingServer::ViewportDebugDraw::VIEWPORT_DEBUG_DRAW_SCENE_LUMINANCE;
	_ViewportDebugDraw[(new std::string("VIEWPORT_DEBUG_DRAW_SSAO"))->c_str()] = RenderingServer::ViewportDebugDraw::VIEWPORT_DEBUG_DRAW_SSAO;
	_ViewportDebugDraw[(new std::string("VIEWPORT_DEBUG_DRAW_SSIL"))->c_str()] = RenderingServer::ViewportDebugDraw::VIEWPORT_DEBUG_DRAW_SSIL;
	_ViewportDebugDraw[(new std::string("VIEWPORT_DEBUG_DRAW_PSSM_SPLITS"))->c_str()] = RenderingServer::ViewportDebugDraw::VIEWPORT_DEBUG_DRAW_PSSM_SPLITS;
	_ViewportDebugDraw[(new std::string("VIEWPORT_DEBUG_DRAW_DECAL_ATLAS"))->c_str()] = RenderingServer::ViewportDebugDraw::VIEWPORT_DEBUG_DRAW_DECAL_ATLAS;
	_ViewportDebugDraw[(new std::string("VIEWPORT_DEBUG_DRAW_SDFGI"))->c_str()] = RenderingServer::ViewportDebugDraw::VIEWPORT_DEBUG_DRAW_SDFGI;
	_ViewportDebugDraw[(new std::string("VIEWPORT_DEBUG_DRAW_SDFGI_PROBES"))->c_str()] = RenderingServer::ViewportDebugDraw::VIEWPORT_DEBUG_DRAW_SDFGI_PROBES;
	_ViewportDebugDraw[(new std::string("VIEWPORT_DEBUG_DRAW_GI_BUFFER"))->c_str()] = RenderingServer::ViewportDebugDraw::VIEWPORT_DEBUG_DRAW_GI_BUFFER;
	_ViewportDebugDraw[(new std::string("VIEWPORT_DEBUG_DRAW_DISABLE_LOD"))->c_str()] = RenderingServer::ViewportDebugDraw::VIEWPORT_DEBUG_DRAW_DISABLE_LOD;
	_ViewportDebugDraw[(new std::string("VIEWPORT_DEBUG_DRAW_CLUSTER_OMNI_LIGHTS"))->c_str()] = RenderingServer::ViewportDebugDraw::VIEWPORT_DEBUG_DRAW_CLUSTER_OMNI_LIGHTS;
	_ViewportDebugDraw[(new std::string("VIEWPORT_DEBUG_DRAW_CLUSTER_SPOT_LIGHTS"))->c_str()] = RenderingServer::ViewportDebugDraw::VIEWPORT_DEBUG_DRAW_CLUSTER_SPOT_LIGHTS;
	_ViewportDebugDraw[(new std::string("VIEWPORT_DEBUG_DRAW_CLUSTER_DECALS"))->c_str()] = RenderingServer::ViewportDebugDraw::VIEWPORT_DEBUG_DRAW_CLUSTER_DECALS;
	_ViewportDebugDraw[(new std::string("VIEWPORT_DEBUG_DRAW_CLUSTER_REFLECTION_PROBES"))->c_str()] = RenderingServer::ViewportDebugDraw::VIEWPORT_DEBUG_DRAW_CLUSTER_REFLECTION_PROBES;
	_ViewportDebugDraw[(new std::string("VIEWPORT_DEBUG_DRAW_OCCLUDERS"))->c_str()] = RenderingServer::ViewportDebugDraw::VIEWPORT_DEBUG_DRAW_OCCLUDERS;
	_ViewportDebugDraw[(new std::string("VIEWPORT_DEBUG_DRAW_MOTION_VECTORS"))->c_str()] = RenderingServer::ViewportDebugDraw::VIEWPORT_DEBUG_DRAW_MOTION_VECTORS;
	_ViewportDebugDraw[(new std::string("VIEWPORT_DEBUG_DRAW_INTERNAL_BUFFER"))->c_str()] = RenderingServer::ViewportDebugDraw::VIEWPORT_DEBUG_DRAW_INTERNAL_BUFFER;
	js_singleton[(new std::string("ViewportDebugDraw"))->c_str()] = _ViewportDebugDraw;
	qjs::Value _ViewportVRSMode = context->newObject();
	_ViewportVRSMode[(new std::string("VIEWPORT_VRS_DISABLED"))->c_str()] = RenderingServer::ViewportVRSMode::VIEWPORT_VRS_DISABLED;
	_ViewportVRSMode[(new std::string("VIEWPORT_VRS_TEXTURE"))->c_str()] = RenderingServer::ViewportVRSMode::VIEWPORT_VRS_TEXTURE;
	_ViewportVRSMode[(new std::string("VIEWPORT_VRS_XR"))->c_str()] = RenderingServer::ViewportVRSMode::VIEWPORT_VRS_XR;
	_ViewportVRSMode[(new std::string("VIEWPORT_VRS_MAX"))->c_str()] = RenderingServer::ViewportVRSMode::VIEWPORT_VRS_MAX;
	js_singleton[(new std::string("ViewportVRSMode"))->c_str()] = _ViewportVRSMode;
	qjs::Value _ViewportVRSUpdateMode = context->newObject();
	_ViewportVRSUpdateMode[(new std::string("VIEWPORT_VRS_UPDATE_DISABLED"))->c_str()] = RenderingServer::ViewportVRSUpdateMode::VIEWPORT_VRS_UPDATE_DISABLED;
	_ViewportVRSUpdateMode[(new std::string("VIEWPORT_VRS_UPDATE_ONCE"))->c_str()] = RenderingServer::ViewportVRSUpdateMode::VIEWPORT_VRS_UPDATE_ONCE;
	_ViewportVRSUpdateMode[(new std::string("VIEWPORT_VRS_UPDATE_ALWAYS"))->c_str()] = RenderingServer::ViewportVRSUpdateMode::VIEWPORT_VRS_UPDATE_ALWAYS;
	_ViewportVRSUpdateMode[(new std::string("VIEWPORT_VRS_UPDATE_MAX"))->c_str()] = RenderingServer::ViewportVRSUpdateMode::VIEWPORT_VRS_UPDATE_MAX;
	js_singleton[(new std::string("ViewportVRSUpdateMode"))->c_str()] = _ViewportVRSUpdateMode;
	qjs::Value _SkyMode = context->newObject();
	_SkyMode[(new std::string("SKY_MODE_AUTOMATIC"))->c_str()] = RenderingServer::SkyMode::SKY_MODE_AUTOMATIC;
	_SkyMode[(new std::string("SKY_MODE_QUALITY"))->c_str()] = RenderingServer::SkyMode::SKY_MODE_QUALITY;
	_SkyMode[(new std::string("SKY_MODE_INCREMENTAL"))->c_str()] = RenderingServer::SkyMode::SKY_MODE_INCREMENTAL;
	_SkyMode[(new std::string("SKY_MODE_REALTIME"))->c_str()] = RenderingServer::SkyMode::SKY_MODE_REALTIME;
	js_singleton[(new std::string("SkyMode"))->c_str()] = _SkyMode;
	qjs::Value _CompositorEffectFlags = context->newObject();
	_CompositorEffectFlags[(new std::string("COMPOSITOR_EFFECT_FLAG_ACCESS_RESOLVED_COLOR"))->c_str()] = RenderingServer::CompositorEffectFlags::COMPOSITOR_EFFECT_FLAG_ACCESS_RESOLVED_COLOR;
	_CompositorEffectFlags[(new std::string("COMPOSITOR_EFFECT_FLAG_ACCESS_RESOLVED_DEPTH"))->c_str()] = RenderingServer::CompositorEffectFlags::COMPOSITOR_EFFECT_FLAG_ACCESS_RESOLVED_DEPTH;
	_CompositorEffectFlags[(new std::string("COMPOSITOR_EFFECT_FLAG_NEEDS_MOTION_VECTORS"))->c_str()] = RenderingServer::CompositorEffectFlags::COMPOSITOR_EFFECT_FLAG_NEEDS_MOTION_VECTORS;
	_CompositorEffectFlags[(new std::string("COMPOSITOR_EFFECT_FLAG_NEEDS_ROUGHNESS"))->c_str()] = RenderingServer::CompositorEffectFlags::COMPOSITOR_EFFECT_FLAG_NEEDS_ROUGHNESS;
	_CompositorEffectFlags[(new std::string("COMPOSITOR_EFFECT_FLAG_NEEDS_SEPARATE_SPECULAR"))->c_str()] = RenderingServer::CompositorEffectFlags::COMPOSITOR_EFFECT_FLAG_NEEDS_SEPARATE_SPECULAR;
	js_singleton[(new std::string("CompositorEffectFlags"))->c_str()] = _CompositorEffectFlags;
	qjs::Value _CompositorEffectCallbackType = context->newObject();
	_CompositorEffectCallbackType[(new std::string("COMPOSITOR_EFFECT_CALLBACK_TYPE_PRE_OPAQUE"))->c_str()] = RenderingServer::CompositorEffectCallbackType::COMPOSITOR_EFFECT_CALLBACK_TYPE_PRE_OPAQUE;
	_CompositorEffectCallbackType[(new std::string("COMPOSITOR_EFFECT_CALLBACK_TYPE_POST_OPAQUE"))->c_str()] = RenderingServer::CompositorEffectCallbackType::COMPOSITOR_EFFECT_CALLBACK_TYPE_POST_OPAQUE;
	_CompositorEffectCallbackType[(new std::string("COMPOSITOR_EFFECT_CALLBACK_TYPE_POST_SKY"))->c_str()] = RenderingServer::CompositorEffectCallbackType::COMPOSITOR_EFFECT_CALLBACK_TYPE_POST_SKY;
	_CompositorEffectCallbackType[(new std::string("COMPOSITOR_EFFECT_CALLBACK_TYPE_PRE_TRANSPARENT"))->c_str()] = RenderingServer::CompositorEffectCallbackType::COMPOSITOR_EFFECT_CALLBACK_TYPE_PRE_TRANSPARENT;
	_CompositorEffectCallbackType[(new std::string("COMPOSITOR_EFFECT_CALLBACK_TYPE_POST_TRANSPARENT"))->c_str()] = RenderingServer::CompositorEffectCallbackType::COMPOSITOR_EFFECT_CALLBACK_TYPE_POST_TRANSPARENT;
	_CompositorEffectCallbackType[(new std::string("COMPOSITOR_EFFECT_CALLBACK_TYPE_ANY"))->c_str()] = RenderingServer::CompositorEffectCallbackType::COMPOSITOR_EFFECT_CALLBACK_TYPE_ANY;
	js_singleton[(new std::string("CompositorEffectCallbackType"))->c_str()] = _CompositorEffectCallbackType;
	qjs::Value _EnvironmentBG = context->newObject();
	_EnvironmentBG[(new std::string("ENV_BG_CLEAR_COLOR"))->c_str()] = RenderingServer::EnvironmentBG::ENV_BG_CLEAR_COLOR;
	_EnvironmentBG[(new std::string("ENV_BG_COLOR"))->c_str()] = RenderingServer::EnvironmentBG::ENV_BG_COLOR;
	_EnvironmentBG[(new std::string("ENV_BG_SKY"))->c_str()] = RenderingServer::EnvironmentBG::ENV_BG_SKY;
	_EnvironmentBG[(new std::string("ENV_BG_CANVAS"))->c_str()] = RenderingServer::EnvironmentBG::ENV_BG_CANVAS;
	_EnvironmentBG[(new std::string("ENV_BG_KEEP"))->c_str()] = RenderingServer::EnvironmentBG::ENV_BG_KEEP;
	_EnvironmentBG[(new std::string("ENV_BG_CAMERA_FEED"))->c_str()] = RenderingServer::EnvironmentBG::ENV_BG_CAMERA_FEED;
	_EnvironmentBG[(new std::string("ENV_BG_MAX"))->c_str()] = RenderingServer::EnvironmentBG::ENV_BG_MAX;
	js_singleton[(new std::string("EnvironmentBG"))->c_str()] = _EnvironmentBG;
	qjs::Value _EnvironmentAmbientSource = context->newObject();
	_EnvironmentAmbientSource[(new std::string("ENV_AMBIENT_SOURCE_BG"))->c_str()] = RenderingServer::EnvironmentAmbientSource::ENV_AMBIENT_SOURCE_BG;
	_EnvironmentAmbientSource[(new std::string("ENV_AMBIENT_SOURCE_DISABLED"))->c_str()] = RenderingServer::EnvironmentAmbientSource::ENV_AMBIENT_SOURCE_DISABLED;
	_EnvironmentAmbientSource[(new std::string("ENV_AMBIENT_SOURCE_COLOR"))->c_str()] = RenderingServer::EnvironmentAmbientSource::ENV_AMBIENT_SOURCE_COLOR;
	_EnvironmentAmbientSource[(new std::string("ENV_AMBIENT_SOURCE_SKY"))->c_str()] = RenderingServer::EnvironmentAmbientSource::ENV_AMBIENT_SOURCE_SKY;
	js_singleton[(new std::string("EnvironmentAmbientSource"))->c_str()] = _EnvironmentAmbientSource;
	qjs::Value _EnvironmentReflectionSource = context->newObject();
	_EnvironmentReflectionSource[(new std::string("ENV_REFLECTION_SOURCE_BG"))->c_str()] = RenderingServer::EnvironmentReflectionSource::ENV_REFLECTION_SOURCE_BG;
	_EnvironmentReflectionSource[(new std::string("ENV_REFLECTION_SOURCE_DISABLED"))->c_str()] = RenderingServer::EnvironmentReflectionSource::ENV_REFLECTION_SOURCE_DISABLED;
	_EnvironmentReflectionSource[(new std::string("ENV_REFLECTION_SOURCE_SKY"))->c_str()] = RenderingServer::EnvironmentReflectionSource::ENV_REFLECTION_SOURCE_SKY;
	js_singleton[(new std::string("EnvironmentReflectionSource"))->c_str()] = _EnvironmentReflectionSource;
	qjs::Value _EnvironmentGlowBlendMode = context->newObject();
	_EnvironmentGlowBlendMode[(new std::string("ENV_GLOW_BLEND_MODE_ADDITIVE"))->c_str()] = RenderingServer::EnvironmentGlowBlendMode::ENV_GLOW_BLEND_MODE_ADDITIVE;
	_EnvironmentGlowBlendMode[(new std::string("ENV_GLOW_BLEND_MODE_SCREEN"))->c_str()] = RenderingServer::EnvironmentGlowBlendMode::ENV_GLOW_BLEND_MODE_SCREEN;
	_EnvironmentGlowBlendMode[(new std::string("ENV_GLOW_BLEND_MODE_SOFTLIGHT"))->c_str()] = RenderingServer::EnvironmentGlowBlendMode::ENV_GLOW_BLEND_MODE_SOFTLIGHT;
	_EnvironmentGlowBlendMode[(new std::string("ENV_GLOW_BLEND_MODE_REPLACE"))->c_str()] = RenderingServer::EnvironmentGlowBlendMode::ENV_GLOW_BLEND_MODE_REPLACE;
	_EnvironmentGlowBlendMode[(new std::string("ENV_GLOW_BLEND_MODE_MIX"))->c_str()] = RenderingServer::EnvironmentGlowBlendMode::ENV_GLOW_BLEND_MODE_MIX;
	js_singleton[(new std::string("EnvironmentGlowBlendMode"))->c_str()] = _EnvironmentGlowBlendMode;
	qjs::Value _EnvironmentFogMode = context->newObject();
	_EnvironmentFogMode[(new std::string("ENV_FOG_MODE_EXPONENTIAL"))->c_str()] = RenderingServer::EnvironmentFogMode::ENV_FOG_MODE_EXPONENTIAL;
	_EnvironmentFogMode[(new std::string("ENV_FOG_MODE_DEPTH"))->c_str()] = RenderingServer::EnvironmentFogMode::ENV_FOG_MODE_DEPTH;
	js_singleton[(new std::string("EnvironmentFogMode"))->c_str()] = _EnvironmentFogMode;
	qjs::Value _EnvironmentToneMapper = context->newObject();
	_EnvironmentToneMapper[(new std::string("ENV_TONE_MAPPER_LINEAR"))->c_str()] = RenderingServer::EnvironmentToneMapper::ENV_TONE_MAPPER_LINEAR;
	_EnvironmentToneMapper[(new std::string("ENV_TONE_MAPPER_REINHARD"))->c_str()] = RenderingServer::EnvironmentToneMapper::ENV_TONE_MAPPER_REINHARD;
	_EnvironmentToneMapper[(new std::string("ENV_TONE_MAPPER_FILMIC"))->c_str()] = RenderingServer::EnvironmentToneMapper::ENV_TONE_MAPPER_FILMIC;
	_EnvironmentToneMapper[(new std::string("ENV_TONE_MAPPER_ACES"))->c_str()] = RenderingServer::EnvironmentToneMapper::ENV_TONE_MAPPER_ACES;
	js_singleton[(new std::string("EnvironmentToneMapper"))->c_str()] = _EnvironmentToneMapper;
	qjs::Value _EnvironmentSSRRoughnessQuality = context->newObject();
	_EnvironmentSSRRoughnessQuality[(new std::string("ENV_SSR_ROUGHNESS_QUALITY_DISABLED"))->c_str()] = RenderingServer::EnvironmentSSRRoughnessQuality::ENV_SSR_ROUGHNESS_QUALITY_DISABLED;
	_EnvironmentSSRRoughnessQuality[(new std::string("ENV_SSR_ROUGHNESS_QUALITY_LOW"))->c_str()] = RenderingServer::EnvironmentSSRRoughnessQuality::ENV_SSR_ROUGHNESS_QUALITY_LOW;
	_EnvironmentSSRRoughnessQuality[(new std::string("ENV_SSR_ROUGHNESS_QUALITY_MEDIUM"))->c_str()] = RenderingServer::EnvironmentSSRRoughnessQuality::ENV_SSR_ROUGHNESS_QUALITY_MEDIUM;
	_EnvironmentSSRRoughnessQuality[(new std::string("ENV_SSR_ROUGHNESS_QUALITY_HIGH"))->c_str()] = RenderingServer::EnvironmentSSRRoughnessQuality::ENV_SSR_ROUGHNESS_QUALITY_HIGH;
	js_singleton[(new std::string("EnvironmentSSRRoughnessQuality"))->c_str()] = _EnvironmentSSRRoughnessQuality;
	qjs::Value _EnvironmentSSAOQuality = context->newObject();
	_EnvironmentSSAOQuality[(new std::string("ENV_SSAO_QUALITY_VERY_LOW"))->c_str()] = RenderingServer::EnvironmentSSAOQuality::ENV_SSAO_QUALITY_VERY_LOW;
	_EnvironmentSSAOQuality[(new std::string("ENV_SSAO_QUALITY_LOW"))->c_str()] = RenderingServer::EnvironmentSSAOQuality::ENV_SSAO_QUALITY_LOW;
	_EnvironmentSSAOQuality[(new std::string("ENV_SSAO_QUALITY_MEDIUM"))->c_str()] = RenderingServer::EnvironmentSSAOQuality::ENV_SSAO_QUALITY_MEDIUM;
	_EnvironmentSSAOQuality[(new std::string("ENV_SSAO_QUALITY_HIGH"))->c_str()] = RenderingServer::EnvironmentSSAOQuality::ENV_SSAO_QUALITY_HIGH;
	_EnvironmentSSAOQuality[(new std::string("ENV_SSAO_QUALITY_ULTRA"))->c_str()] = RenderingServer::EnvironmentSSAOQuality::ENV_SSAO_QUALITY_ULTRA;
	js_singleton[(new std::string("EnvironmentSSAOQuality"))->c_str()] = _EnvironmentSSAOQuality;
	qjs::Value _EnvironmentSSILQuality = context->newObject();
	_EnvironmentSSILQuality[(new std::string("ENV_SSIL_QUALITY_VERY_LOW"))->c_str()] = RenderingServer::EnvironmentSSILQuality::ENV_SSIL_QUALITY_VERY_LOW;
	_EnvironmentSSILQuality[(new std::string("ENV_SSIL_QUALITY_LOW"))->c_str()] = RenderingServer::EnvironmentSSILQuality::ENV_SSIL_QUALITY_LOW;
	_EnvironmentSSILQuality[(new std::string("ENV_SSIL_QUALITY_MEDIUM"))->c_str()] = RenderingServer::EnvironmentSSILQuality::ENV_SSIL_QUALITY_MEDIUM;
	_EnvironmentSSILQuality[(new std::string("ENV_SSIL_QUALITY_HIGH"))->c_str()] = RenderingServer::EnvironmentSSILQuality::ENV_SSIL_QUALITY_HIGH;
	_EnvironmentSSILQuality[(new std::string("ENV_SSIL_QUALITY_ULTRA"))->c_str()] = RenderingServer::EnvironmentSSILQuality::ENV_SSIL_QUALITY_ULTRA;
	js_singleton[(new std::string("EnvironmentSSILQuality"))->c_str()] = _EnvironmentSSILQuality;
	qjs::Value _EnvironmentSDFGIYScale = context->newObject();
	_EnvironmentSDFGIYScale[(new std::string("ENV_SDFGI_Y_SCALE_50_PERCENT"))->c_str()] = RenderingServer::EnvironmentSDFGIYScale::ENV_SDFGI_Y_SCALE_50_PERCENT;
	_EnvironmentSDFGIYScale[(new std::string("ENV_SDFGI_Y_SCALE_75_PERCENT"))->c_str()] = RenderingServer::EnvironmentSDFGIYScale::ENV_SDFGI_Y_SCALE_75_PERCENT;
	_EnvironmentSDFGIYScale[(new std::string("ENV_SDFGI_Y_SCALE_100_PERCENT"))->c_str()] = RenderingServer::EnvironmentSDFGIYScale::ENV_SDFGI_Y_SCALE_100_PERCENT;
	js_singleton[(new std::string("EnvironmentSDFGIYScale"))->c_str()] = _EnvironmentSDFGIYScale;
	qjs::Value _EnvironmentSDFGIRayCount = context->newObject();
	_EnvironmentSDFGIRayCount[(new std::string("ENV_SDFGI_RAY_COUNT_4"))->c_str()] = RenderingServer::EnvironmentSDFGIRayCount::ENV_SDFGI_RAY_COUNT_4;
	_EnvironmentSDFGIRayCount[(new std::string("ENV_SDFGI_RAY_COUNT_8"))->c_str()] = RenderingServer::EnvironmentSDFGIRayCount::ENV_SDFGI_RAY_COUNT_8;
	_EnvironmentSDFGIRayCount[(new std::string("ENV_SDFGI_RAY_COUNT_16"))->c_str()] = RenderingServer::EnvironmentSDFGIRayCount::ENV_SDFGI_RAY_COUNT_16;
	_EnvironmentSDFGIRayCount[(new std::string("ENV_SDFGI_RAY_COUNT_32"))->c_str()] = RenderingServer::EnvironmentSDFGIRayCount::ENV_SDFGI_RAY_COUNT_32;
	_EnvironmentSDFGIRayCount[(new std::string("ENV_SDFGI_RAY_COUNT_64"))->c_str()] = RenderingServer::EnvironmentSDFGIRayCount::ENV_SDFGI_RAY_COUNT_64;
	_EnvironmentSDFGIRayCount[(new std::string("ENV_SDFGI_RAY_COUNT_96"))->c_str()] = RenderingServer::EnvironmentSDFGIRayCount::ENV_SDFGI_RAY_COUNT_96;
	_EnvironmentSDFGIRayCount[(new std::string("ENV_SDFGI_RAY_COUNT_128"))->c_str()] = RenderingServer::EnvironmentSDFGIRayCount::ENV_SDFGI_RAY_COUNT_128;
	_EnvironmentSDFGIRayCount[(new std::string("ENV_SDFGI_RAY_COUNT_MAX"))->c_str()] = RenderingServer::EnvironmentSDFGIRayCount::ENV_SDFGI_RAY_COUNT_MAX;
	js_singleton[(new std::string("EnvironmentSDFGIRayCount"))->c_str()] = _EnvironmentSDFGIRayCount;
	qjs::Value _EnvironmentSDFGIFramesToConverge = context->newObject();
	_EnvironmentSDFGIFramesToConverge[(new std::string("ENV_SDFGI_CONVERGE_IN_5_FRAMES"))->c_str()] = RenderingServer::EnvironmentSDFGIFramesToConverge::ENV_SDFGI_CONVERGE_IN_5_FRAMES;
	_EnvironmentSDFGIFramesToConverge[(new std::string("ENV_SDFGI_CONVERGE_IN_10_FRAMES"))->c_str()] = RenderingServer::EnvironmentSDFGIFramesToConverge::ENV_SDFGI_CONVERGE_IN_10_FRAMES;
	_EnvironmentSDFGIFramesToConverge[(new std::string("ENV_SDFGI_CONVERGE_IN_15_FRAMES"))->c_str()] = RenderingServer::EnvironmentSDFGIFramesToConverge::ENV_SDFGI_CONVERGE_IN_15_FRAMES;
	_EnvironmentSDFGIFramesToConverge[(new std::string("ENV_SDFGI_CONVERGE_IN_20_FRAMES"))->c_str()] = RenderingServer::EnvironmentSDFGIFramesToConverge::ENV_SDFGI_CONVERGE_IN_20_FRAMES;
	_EnvironmentSDFGIFramesToConverge[(new std::string("ENV_SDFGI_CONVERGE_IN_25_FRAMES"))->c_str()] = RenderingServer::EnvironmentSDFGIFramesToConverge::ENV_SDFGI_CONVERGE_IN_25_FRAMES;
	_EnvironmentSDFGIFramesToConverge[(new std::string("ENV_SDFGI_CONVERGE_IN_30_FRAMES"))->c_str()] = RenderingServer::EnvironmentSDFGIFramesToConverge::ENV_SDFGI_CONVERGE_IN_30_FRAMES;
	_EnvironmentSDFGIFramesToConverge[(new std::string("ENV_SDFGI_CONVERGE_MAX"))->c_str()] = RenderingServer::EnvironmentSDFGIFramesToConverge::ENV_SDFGI_CONVERGE_MAX;
	js_singleton[(new std::string("EnvironmentSDFGIFramesToConverge"))->c_str()] = _EnvironmentSDFGIFramesToConverge;
	qjs::Value _EnvironmentSDFGIFramesToUpdateLight = context->newObject();
	_EnvironmentSDFGIFramesToUpdateLight[(new std::string("ENV_SDFGI_UPDATE_LIGHT_IN_1_FRAME"))->c_str()] = RenderingServer::EnvironmentSDFGIFramesToUpdateLight::ENV_SDFGI_UPDATE_LIGHT_IN_1_FRAME;
	_EnvironmentSDFGIFramesToUpdateLight[(new std::string("ENV_SDFGI_UPDATE_LIGHT_IN_2_FRAMES"))->c_str()] = RenderingServer::EnvironmentSDFGIFramesToUpdateLight::ENV_SDFGI_UPDATE_LIGHT_IN_2_FRAMES;
	_EnvironmentSDFGIFramesToUpdateLight[(new std::string("ENV_SDFGI_UPDATE_LIGHT_IN_4_FRAMES"))->c_str()] = RenderingServer::EnvironmentSDFGIFramesToUpdateLight::ENV_SDFGI_UPDATE_LIGHT_IN_4_FRAMES;
	_EnvironmentSDFGIFramesToUpdateLight[(new std::string("ENV_SDFGI_UPDATE_LIGHT_IN_8_FRAMES"))->c_str()] = RenderingServer::EnvironmentSDFGIFramesToUpdateLight::ENV_SDFGI_UPDATE_LIGHT_IN_8_FRAMES;
	_EnvironmentSDFGIFramesToUpdateLight[(new std::string("ENV_SDFGI_UPDATE_LIGHT_IN_16_FRAMES"))->c_str()] = RenderingServer::EnvironmentSDFGIFramesToUpdateLight::ENV_SDFGI_UPDATE_LIGHT_IN_16_FRAMES;
	_EnvironmentSDFGIFramesToUpdateLight[(new std::string("ENV_SDFGI_UPDATE_LIGHT_MAX"))->c_str()] = RenderingServer::EnvironmentSDFGIFramesToUpdateLight::ENV_SDFGI_UPDATE_LIGHT_MAX;
	js_singleton[(new std::string("EnvironmentSDFGIFramesToUpdateLight"))->c_str()] = _EnvironmentSDFGIFramesToUpdateLight;
	qjs::Value _SubSurfaceScatteringQuality = context->newObject();
	_SubSurfaceScatteringQuality[(new std::string("SUB_SURFACE_SCATTERING_QUALITY_DISABLED"))->c_str()] = RenderingServer::SubSurfaceScatteringQuality::SUB_SURFACE_SCATTERING_QUALITY_DISABLED;
	_SubSurfaceScatteringQuality[(new std::string("SUB_SURFACE_SCATTERING_QUALITY_LOW"))->c_str()] = RenderingServer::SubSurfaceScatteringQuality::SUB_SURFACE_SCATTERING_QUALITY_LOW;
	_SubSurfaceScatteringQuality[(new std::string("SUB_SURFACE_SCATTERING_QUALITY_MEDIUM"))->c_str()] = RenderingServer::SubSurfaceScatteringQuality::SUB_SURFACE_SCATTERING_QUALITY_MEDIUM;
	_SubSurfaceScatteringQuality[(new std::string("SUB_SURFACE_SCATTERING_QUALITY_HIGH"))->c_str()] = RenderingServer::SubSurfaceScatteringQuality::SUB_SURFACE_SCATTERING_QUALITY_HIGH;
	js_singleton[(new std::string("SubSurfaceScatteringQuality"))->c_str()] = _SubSurfaceScatteringQuality;
	qjs::Value _DOFBokehShape = context->newObject();
	_DOFBokehShape[(new std::string("DOF_BOKEH_BOX"))->c_str()] = RenderingServer::DOFBokehShape::DOF_BOKEH_BOX;
	_DOFBokehShape[(new std::string("DOF_BOKEH_HEXAGON"))->c_str()] = RenderingServer::DOFBokehShape::DOF_BOKEH_HEXAGON;
	_DOFBokehShape[(new std::string("DOF_BOKEH_CIRCLE"))->c_str()] = RenderingServer::DOFBokehShape::DOF_BOKEH_CIRCLE;
	js_singleton[(new std::string("DOFBokehShape"))->c_str()] = _DOFBokehShape;
	qjs::Value _DOFBlurQuality = context->newObject();
	_DOFBlurQuality[(new std::string("DOF_BLUR_QUALITY_VERY_LOW"))->c_str()] = RenderingServer::DOFBlurQuality::DOF_BLUR_QUALITY_VERY_LOW;
	_DOFBlurQuality[(new std::string("DOF_BLUR_QUALITY_LOW"))->c_str()] = RenderingServer::DOFBlurQuality::DOF_BLUR_QUALITY_LOW;
	_DOFBlurQuality[(new std::string("DOF_BLUR_QUALITY_MEDIUM"))->c_str()] = RenderingServer::DOFBlurQuality::DOF_BLUR_QUALITY_MEDIUM;
	_DOFBlurQuality[(new std::string("DOF_BLUR_QUALITY_HIGH"))->c_str()] = RenderingServer::DOFBlurQuality::DOF_BLUR_QUALITY_HIGH;
	js_singleton[(new std::string("DOFBlurQuality"))->c_str()] = _DOFBlurQuality;
	qjs::Value _InstanceType = context->newObject();
	_InstanceType[(new std::string("INSTANCE_NONE"))->c_str()] = RenderingServer::InstanceType::INSTANCE_NONE;
	_InstanceType[(new std::string("INSTANCE_MESH"))->c_str()] = RenderingServer::InstanceType::INSTANCE_MESH;
	_InstanceType[(new std::string("INSTANCE_MULTIMESH"))->c_str()] = RenderingServer::InstanceType::INSTANCE_MULTIMESH;
	_InstanceType[(new std::string("INSTANCE_PARTICLES"))->c_str()] = RenderingServer::InstanceType::INSTANCE_PARTICLES;
	_InstanceType[(new std::string("INSTANCE_PARTICLES_COLLISION"))->c_str()] = RenderingServer::InstanceType::INSTANCE_PARTICLES_COLLISION;
	_InstanceType[(new std::string("INSTANCE_LIGHT"))->c_str()] = RenderingServer::InstanceType::INSTANCE_LIGHT;
	_InstanceType[(new std::string("INSTANCE_REFLECTION_PROBE"))->c_str()] = RenderingServer::InstanceType::INSTANCE_REFLECTION_PROBE;
	_InstanceType[(new std::string("INSTANCE_DECAL"))->c_str()] = RenderingServer::InstanceType::INSTANCE_DECAL;
	_InstanceType[(new std::string("INSTANCE_VOXEL_GI"))->c_str()] = RenderingServer::InstanceType::INSTANCE_VOXEL_GI;
	_InstanceType[(new std::string("INSTANCE_LIGHTMAP"))->c_str()] = RenderingServer::InstanceType::INSTANCE_LIGHTMAP;
	_InstanceType[(new std::string("INSTANCE_OCCLUDER"))->c_str()] = RenderingServer::InstanceType::INSTANCE_OCCLUDER;
	_InstanceType[(new std::string("INSTANCE_VISIBLITY_NOTIFIER"))->c_str()] = RenderingServer::InstanceType::INSTANCE_VISIBLITY_NOTIFIER;
	_InstanceType[(new std::string("INSTANCE_FOG_VOLUME"))->c_str()] = RenderingServer::InstanceType::INSTANCE_FOG_VOLUME;
	_InstanceType[(new std::string("INSTANCE_MAX"))->c_str()] = RenderingServer::InstanceType::INSTANCE_MAX;
	_InstanceType[(new std::string("INSTANCE_GEOMETRY_MASK"))->c_str()] = RenderingServer::InstanceType::INSTANCE_GEOMETRY_MASK;
	js_singleton[(new std::string("InstanceType"))->c_str()] = _InstanceType;
	qjs::Value _InstanceFlags = context->newObject();
	_InstanceFlags[(new std::string("INSTANCE_FLAG_USE_BAKED_LIGHT"))->c_str()] = RenderingServer::InstanceFlags::INSTANCE_FLAG_USE_BAKED_LIGHT;
	_InstanceFlags[(new std::string("INSTANCE_FLAG_USE_DYNAMIC_GI"))->c_str()] = RenderingServer::InstanceFlags::INSTANCE_FLAG_USE_DYNAMIC_GI;
	_InstanceFlags[(new std::string("INSTANCE_FLAG_DRAW_NEXT_FRAME_IF_VISIBLE"))->c_str()] = RenderingServer::InstanceFlags::INSTANCE_FLAG_DRAW_NEXT_FRAME_IF_VISIBLE;
	_InstanceFlags[(new std::string("INSTANCE_FLAG_IGNORE_OCCLUSION_CULLING"))->c_str()] = RenderingServer::InstanceFlags::INSTANCE_FLAG_IGNORE_OCCLUSION_CULLING;
	_InstanceFlags[(new std::string("INSTANCE_FLAG_MAX"))->c_str()] = RenderingServer::InstanceFlags::INSTANCE_FLAG_MAX;
	js_singleton[(new std::string("InstanceFlags"))->c_str()] = _InstanceFlags;
	qjs::Value _ShadowCastingSetting = context->newObject();
	_ShadowCastingSetting[(new std::string("SHADOW_CASTING_SETTING_OFF"))->c_str()] = RenderingServer::ShadowCastingSetting::SHADOW_CASTING_SETTING_OFF;
	_ShadowCastingSetting[(new std::string("SHADOW_CASTING_SETTING_ON"))->c_str()] = RenderingServer::ShadowCastingSetting::SHADOW_CASTING_SETTING_ON;
	_ShadowCastingSetting[(new std::string("SHADOW_CASTING_SETTING_DOUBLE_SIDED"))->c_str()] = RenderingServer::ShadowCastingSetting::SHADOW_CASTING_SETTING_DOUBLE_SIDED;
	_ShadowCastingSetting[(new std::string("SHADOW_CASTING_SETTING_SHADOWS_ONLY"))->c_str()] = RenderingServer::ShadowCastingSetting::SHADOW_CASTING_SETTING_SHADOWS_ONLY;
	js_singleton[(new std::string("ShadowCastingSetting"))->c_str()] = _ShadowCastingSetting;
	qjs::Value _VisibilityRangeFadeMode = context->newObject();
	_VisibilityRangeFadeMode[(new std::string("VISIBILITY_RANGE_FADE_DISABLED"))->c_str()] = RenderingServer::VisibilityRangeFadeMode::VISIBILITY_RANGE_FADE_DISABLED;
	_VisibilityRangeFadeMode[(new std::string("VISIBILITY_RANGE_FADE_SELF"))->c_str()] = RenderingServer::VisibilityRangeFadeMode::VISIBILITY_RANGE_FADE_SELF;
	_VisibilityRangeFadeMode[(new std::string("VISIBILITY_RANGE_FADE_DEPENDENCIES"))->c_str()] = RenderingServer::VisibilityRangeFadeMode::VISIBILITY_RANGE_FADE_DEPENDENCIES;
	js_singleton[(new std::string("VisibilityRangeFadeMode"))->c_str()] = _VisibilityRangeFadeMode;
	qjs::Value _BakeChannels = context->newObject();
	_BakeChannels[(new std::string("BAKE_CHANNEL_ALBEDO_ALPHA"))->c_str()] = RenderingServer::BakeChannels::BAKE_CHANNEL_ALBEDO_ALPHA;
	_BakeChannels[(new std::string("BAKE_CHANNEL_NORMAL"))->c_str()] = RenderingServer::BakeChannels::BAKE_CHANNEL_NORMAL;
	_BakeChannels[(new std::string("BAKE_CHANNEL_ORM"))->c_str()] = RenderingServer::BakeChannels::BAKE_CHANNEL_ORM;
	_BakeChannels[(new std::string("BAKE_CHANNEL_EMISSION"))->c_str()] = RenderingServer::BakeChannels::BAKE_CHANNEL_EMISSION;
	js_singleton[(new std::string("BakeChannels"))->c_str()] = _BakeChannels;
	qjs::Value _CanvasTextureChannel = context->newObject();
	_CanvasTextureChannel[(new std::string("CANVAS_TEXTURE_CHANNEL_DIFFUSE"))->c_str()] = RenderingServer::CanvasTextureChannel::CANVAS_TEXTURE_CHANNEL_DIFFUSE;
	_CanvasTextureChannel[(new std::string("CANVAS_TEXTURE_CHANNEL_NORMAL"))->c_str()] = RenderingServer::CanvasTextureChannel::CANVAS_TEXTURE_CHANNEL_NORMAL;
	_CanvasTextureChannel[(new std::string("CANVAS_TEXTURE_CHANNEL_SPECULAR"))->c_str()] = RenderingServer::CanvasTextureChannel::CANVAS_TEXTURE_CHANNEL_SPECULAR;
	js_singleton[(new std::string("CanvasTextureChannel"))->c_str()] = _CanvasTextureChannel;
	qjs::Value _NinePatchAxisMode = context->newObject();
	_NinePatchAxisMode[(new std::string("NINE_PATCH_STRETCH"))->c_str()] = RenderingServer::NinePatchAxisMode::NINE_PATCH_STRETCH;
	_NinePatchAxisMode[(new std::string("NINE_PATCH_TILE"))->c_str()] = RenderingServer::NinePatchAxisMode::NINE_PATCH_TILE;
	_NinePatchAxisMode[(new std::string("NINE_PATCH_TILE_FIT"))->c_str()] = RenderingServer::NinePatchAxisMode::NINE_PATCH_TILE_FIT;
	js_singleton[(new std::string("NinePatchAxisMode"))->c_str()] = _NinePatchAxisMode;
	qjs::Value _CanvasItemTextureFilter = context->newObject();
	_CanvasItemTextureFilter[(new std::string("CANVAS_ITEM_TEXTURE_FILTER_DEFAULT"))->c_str()] = RenderingServer::CanvasItemTextureFilter::CANVAS_ITEM_TEXTURE_FILTER_DEFAULT;
	_CanvasItemTextureFilter[(new std::string("CANVAS_ITEM_TEXTURE_FILTER_NEAREST"))->c_str()] = RenderingServer::CanvasItemTextureFilter::CANVAS_ITEM_TEXTURE_FILTER_NEAREST;
	_CanvasItemTextureFilter[(new std::string("CANVAS_ITEM_TEXTURE_FILTER_LINEAR"))->c_str()] = RenderingServer::CanvasItemTextureFilter::CANVAS_ITEM_TEXTURE_FILTER_LINEAR;
	_CanvasItemTextureFilter[(new std::string("CANVAS_ITEM_TEXTURE_FILTER_NEAREST_WITH_MIPMAPS"))->c_str()] = RenderingServer::CanvasItemTextureFilter::CANVAS_ITEM_TEXTURE_FILTER_NEAREST_WITH_MIPMAPS;
	_CanvasItemTextureFilter[(new std::string("CANVAS_ITEM_TEXTURE_FILTER_LINEAR_WITH_MIPMAPS"))->c_str()] = RenderingServer::CanvasItemTextureFilter::CANVAS_ITEM_TEXTURE_FILTER_LINEAR_WITH_MIPMAPS;
	_CanvasItemTextureFilter[(new std::string("CANVAS_ITEM_TEXTURE_FILTER_NEAREST_WITH_MIPMAPS_ANISOTROPIC"))->c_str()] = RenderingServer::CanvasItemTextureFilter::CANVAS_ITEM_TEXTURE_FILTER_NEAREST_WITH_MIPMAPS_ANISOTROPIC;
	_CanvasItemTextureFilter[(new std::string("CANVAS_ITEM_TEXTURE_FILTER_LINEAR_WITH_MIPMAPS_ANISOTROPIC"))->c_str()] = RenderingServer::CanvasItemTextureFilter::CANVAS_ITEM_TEXTURE_FILTER_LINEAR_WITH_MIPMAPS_ANISOTROPIC;
	_CanvasItemTextureFilter[(new std::string("CANVAS_ITEM_TEXTURE_FILTER_MAX"))->c_str()] = RenderingServer::CanvasItemTextureFilter::CANVAS_ITEM_TEXTURE_FILTER_MAX;
	js_singleton[(new std::string("CanvasItemTextureFilter"))->c_str()] = _CanvasItemTextureFilter;
	qjs::Value _CanvasItemTextureRepeat = context->newObject();
	_CanvasItemTextureRepeat[(new std::string("CANVAS_ITEM_TEXTURE_REPEAT_DEFAULT"))->c_str()] = RenderingServer::CanvasItemTextureRepeat::CANVAS_ITEM_TEXTURE_REPEAT_DEFAULT;
	_CanvasItemTextureRepeat[(new std::string("CANVAS_ITEM_TEXTURE_REPEAT_DISABLED"))->c_str()] = RenderingServer::CanvasItemTextureRepeat::CANVAS_ITEM_TEXTURE_REPEAT_DISABLED;
	_CanvasItemTextureRepeat[(new std::string("CANVAS_ITEM_TEXTURE_REPEAT_ENABLED"))->c_str()] = RenderingServer::CanvasItemTextureRepeat::CANVAS_ITEM_TEXTURE_REPEAT_ENABLED;
	_CanvasItemTextureRepeat[(new std::string("CANVAS_ITEM_TEXTURE_REPEAT_MIRROR"))->c_str()] = RenderingServer::CanvasItemTextureRepeat::CANVAS_ITEM_TEXTURE_REPEAT_MIRROR;
	_CanvasItemTextureRepeat[(new std::string("CANVAS_ITEM_TEXTURE_REPEAT_MAX"))->c_str()] = RenderingServer::CanvasItemTextureRepeat::CANVAS_ITEM_TEXTURE_REPEAT_MAX;
	js_singleton[(new std::string("CanvasItemTextureRepeat"))->c_str()] = _CanvasItemTextureRepeat;
	qjs::Value _CanvasGroupMode = context->newObject();
	_CanvasGroupMode[(new std::string("CANVAS_GROUP_MODE_DISABLED"))->c_str()] = RenderingServer::CanvasGroupMode::CANVAS_GROUP_MODE_DISABLED;
	_CanvasGroupMode[(new std::string("CANVAS_GROUP_MODE_CLIP_ONLY"))->c_str()] = RenderingServer::CanvasGroupMode::CANVAS_GROUP_MODE_CLIP_ONLY;
	_CanvasGroupMode[(new std::string("CANVAS_GROUP_MODE_CLIP_AND_DRAW"))->c_str()] = RenderingServer::CanvasGroupMode::CANVAS_GROUP_MODE_CLIP_AND_DRAW;
	_CanvasGroupMode[(new std::string("CANVAS_GROUP_MODE_TRANSPARENT"))->c_str()] = RenderingServer::CanvasGroupMode::CANVAS_GROUP_MODE_TRANSPARENT;
	js_singleton[(new std::string("CanvasGroupMode"))->c_str()] = _CanvasGroupMode;
	qjs::Value _CanvasLightMode = context->newObject();
	_CanvasLightMode[(new std::string("CANVAS_LIGHT_MODE_POINT"))->c_str()] = RenderingServer::CanvasLightMode::CANVAS_LIGHT_MODE_POINT;
	_CanvasLightMode[(new std::string("CANVAS_LIGHT_MODE_DIRECTIONAL"))->c_str()] = RenderingServer::CanvasLightMode::CANVAS_LIGHT_MODE_DIRECTIONAL;
	js_singleton[(new std::string("CanvasLightMode"))->c_str()] = _CanvasLightMode;
	qjs::Value _CanvasLightBlendMode = context->newObject();
	_CanvasLightBlendMode[(new std::string("CANVAS_LIGHT_BLEND_MODE_ADD"))->c_str()] = RenderingServer::CanvasLightBlendMode::CANVAS_LIGHT_BLEND_MODE_ADD;
	_CanvasLightBlendMode[(new std::string("CANVAS_LIGHT_BLEND_MODE_SUB"))->c_str()] = RenderingServer::CanvasLightBlendMode::CANVAS_LIGHT_BLEND_MODE_SUB;
	_CanvasLightBlendMode[(new std::string("CANVAS_LIGHT_BLEND_MODE_MIX"))->c_str()] = RenderingServer::CanvasLightBlendMode::CANVAS_LIGHT_BLEND_MODE_MIX;
	js_singleton[(new std::string("CanvasLightBlendMode"))->c_str()] = _CanvasLightBlendMode;
	qjs::Value _CanvasLightShadowFilter = context->newObject();
	_CanvasLightShadowFilter[(new std::string("CANVAS_LIGHT_FILTER_NONE"))->c_str()] = RenderingServer::CanvasLightShadowFilter::CANVAS_LIGHT_FILTER_NONE;
	_CanvasLightShadowFilter[(new std::string("CANVAS_LIGHT_FILTER_PCF5"))->c_str()] = RenderingServer::CanvasLightShadowFilter::CANVAS_LIGHT_FILTER_PCF5;
	_CanvasLightShadowFilter[(new std::string("CANVAS_LIGHT_FILTER_PCF13"))->c_str()] = RenderingServer::CanvasLightShadowFilter::CANVAS_LIGHT_FILTER_PCF13;
	_CanvasLightShadowFilter[(new std::string("CANVAS_LIGHT_FILTER_MAX"))->c_str()] = RenderingServer::CanvasLightShadowFilter::CANVAS_LIGHT_FILTER_MAX;
	js_singleton[(new std::string("CanvasLightShadowFilter"))->c_str()] = _CanvasLightShadowFilter;
	qjs::Value _CanvasOccluderPolygonCullMode = context->newObject();
	_CanvasOccluderPolygonCullMode[(new std::string("CANVAS_OCCLUDER_POLYGON_CULL_DISABLED"))->c_str()] = RenderingServer::CanvasOccluderPolygonCullMode::CANVAS_OCCLUDER_POLYGON_CULL_DISABLED;
	_CanvasOccluderPolygonCullMode[(new std::string("CANVAS_OCCLUDER_POLYGON_CULL_CLOCKWISE"))->c_str()] = RenderingServer::CanvasOccluderPolygonCullMode::CANVAS_OCCLUDER_POLYGON_CULL_CLOCKWISE;
	_CanvasOccluderPolygonCullMode[(new std::string("CANVAS_OCCLUDER_POLYGON_CULL_COUNTER_CLOCKWISE"))->c_str()] = RenderingServer::CanvasOccluderPolygonCullMode::CANVAS_OCCLUDER_POLYGON_CULL_COUNTER_CLOCKWISE;
	js_singleton[(new std::string("CanvasOccluderPolygonCullMode"))->c_str()] = _CanvasOccluderPolygonCullMode;
	qjs::Value _GlobalShaderParameterType = context->newObject();
	_GlobalShaderParameterType[(new std::string("GLOBAL_VAR_TYPE_BOOL"))->c_str()] = RenderingServer::GlobalShaderParameterType::GLOBAL_VAR_TYPE_BOOL;
	_GlobalShaderParameterType[(new std::string("GLOBAL_VAR_TYPE_BVEC2"))->c_str()] = RenderingServer::GlobalShaderParameterType::GLOBAL_VAR_TYPE_BVEC2;
	_GlobalShaderParameterType[(new std::string("GLOBAL_VAR_TYPE_BVEC3"))->c_str()] = RenderingServer::GlobalShaderParameterType::GLOBAL_VAR_TYPE_BVEC3;
	_GlobalShaderParameterType[(new std::string("GLOBAL_VAR_TYPE_BVEC4"))->c_str()] = RenderingServer::GlobalShaderParameterType::GLOBAL_VAR_TYPE_BVEC4;
	_GlobalShaderParameterType[(new std::string("GLOBAL_VAR_TYPE_INT"))->c_str()] = RenderingServer::GlobalShaderParameterType::GLOBAL_VAR_TYPE_INT;
	_GlobalShaderParameterType[(new std::string("GLOBAL_VAR_TYPE_IVEC2"))->c_str()] = RenderingServer::GlobalShaderParameterType::GLOBAL_VAR_TYPE_IVEC2;
	_GlobalShaderParameterType[(new std::string("GLOBAL_VAR_TYPE_IVEC3"))->c_str()] = RenderingServer::GlobalShaderParameterType::GLOBAL_VAR_TYPE_IVEC3;
	_GlobalShaderParameterType[(new std::string("GLOBAL_VAR_TYPE_IVEC4"))->c_str()] = RenderingServer::GlobalShaderParameterType::GLOBAL_VAR_TYPE_IVEC4;
	_GlobalShaderParameterType[(new std::string("GLOBAL_VAR_TYPE_RECT2I"))->c_str()] = RenderingServer::GlobalShaderParameterType::GLOBAL_VAR_TYPE_RECT2I;
	_GlobalShaderParameterType[(new std::string("GLOBAL_VAR_TYPE_UINT"))->c_str()] = RenderingServer::GlobalShaderParameterType::GLOBAL_VAR_TYPE_UINT;
	_GlobalShaderParameterType[(new std::string("GLOBAL_VAR_TYPE_UVEC2"))->c_str()] = RenderingServer::GlobalShaderParameterType::GLOBAL_VAR_TYPE_UVEC2;
	_GlobalShaderParameterType[(new std::string("GLOBAL_VAR_TYPE_UVEC3"))->c_str()] = RenderingServer::GlobalShaderParameterType::GLOBAL_VAR_TYPE_UVEC3;
	_GlobalShaderParameterType[(new std::string("GLOBAL_VAR_TYPE_UVEC4"))->c_str()] = RenderingServer::GlobalShaderParameterType::GLOBAL_VAR_TYPE_UVEC4;
	_GlobalShaderParameterType[(new std::string("GLOBAL_VAR_TYPE_FLOAT"))->c_str()] = RenderingServer::GlobalShaderParameterType::GLOBAL_VAR_TYPE_FLOAT;
	_GlobalShaderParameterType[(new std::string("GLOBAL_VAR_TYPE_VEC2"))->c_str()] = RenderingServer::GlobalShaderParameterType::GLOBAL_VAR_TYPE_VEC2;
	_GlobalShaderParameterType[(new std::string("GLOBAL_VAR_TYPE_VEC3"))->c_str()] = RenderingServer::GlobalShaderParameterType::GLOBAL_VAR_TYPE_VEC3;
	_GlobalShaderParameterType[(new std::string("GLOBAL_VAR_TYPE_VEC4"))->c_str()] = RenderingServer::GlobalShaderParameterType::GLOBAL_VAR_TYPE_VEC4;
	_GlobalShaderParameterType[(new std::string("GLOBAL_VAR_TYPE_COLOR"))->c_str()] = RenderingServer::GlobalShaderParameterType::GLOBAL_VAR_TYPE_COLOR;
	_GlobalShaderParameterType[(new std::string("GLOBAL_VAR_TYPE_RECT2"))->c_str()] = RenderingServer::GlobalShaderParameterType::GLOBAL_VAR_TYPE_RECT2;
	_GlobalShaderParameterType[(new std::string("GLOBAL_VAR_TYPE_MAT2"))->c_str()] = RenderingServer::GlobalShaderParameterType::GLOBAL_VAR_TYPE_MAT2;
	_GlobalShaderParameterType[(new std::string("GLOBAL_VAR_TYPE_MAT3"))->c_str()] = RenderingServer::GlobalShaderParameterType::GLOBAL_VAR_TYPE_MAT3;
	_GlobalShaderParameterType[(new std::string("GLOBAL_VAR_TYPE_MAT4"))->c_str()] = RenderingServer::GlobalShaderParameterType::GLOBAL_VAR_TYPE_MAT4;
	_GlobalShaderParameterType[(new std::string("GLOBAL_VAR_TYPE_TRANSFORM_2D"))->c_str()] = RenderingServer::GlobalShaderParameterType::GLOBAL_VAR_TYPE_TRANSFORM_2D;
	_GlobalShaderParameterType[(new std::string("GLOBAL_VAR_TYPE_TRANSFORM"))->c_str()] = RenderingServer::GlobalShaderParameterType::GLOBAL_VAR_TYPE_TRANSFORM;
	_GlobalShaderParameterType[(new std::string("GLOBAL_VAR_TYPE_SAMPLER2D"))->c_str()] = RenderingServer::GlobalShaderParameterType::GLOBAL_VAR_TYPE_SAMPLER2D;
	_GlobalShaderParameterType[(new std::string("GLOBAL_VAR_TYPE_SAMPLER2DARRAY"))->c_str()] = RenderingServer::GlobalShaderParameterType::GLOBAL_VAR_TYPE_SAMPLER2DARRAY;
	_GlobalShaderParameterType[(new std::string("GLOBAL_VAR_TYPE_SAMPLER3D"))->c_str()] = RenderingServer::GlobalShaderParameterType::GLOBAL_VAR_TYPE_SAMPLER3D;
	_GlobalShaderParameterType[(new std::string("GLOBAL_VAR_TYPE_SAMPLERCUBE"))->c_str()] = RenderingServer::GlobalShaderParameterType::GLOBAL_VAR_TYPE_SAMPLERCUBE;
	_GlobalShaderParameterType[(new std::string("GLOBAL_VAR_TYPE_MAX"))->c_str()] = RenderingServer::GlobalShaderParameterType::GLOBAL_VAR_TYPE_MAX;
	js_singleton[(new std::string("GlobalShaderParameterType"))->c_str()] = _GlobalShaderParameterType;
	qjs::Value _RenderingInfo = context->newObject();
	_RenderingInfo[(new std::string("RENDERING_INFO_TOTAL_OBJECTS_IN_FRAME"))->c_str()] = RenderingServer::RenderingInfo::RENDERING_INFO_TOTAL_OBJECTS_IN_FRAME;
	_RenderingInfo[(new std::string("RENDERING_INFO_TOTAL_PRIMITIVES_IN_FRAME"))->c_str()] = RenderingServer::RenderingInfo::RENDERING_INFO_TOTAL_PRIMITIVES_IN_FRAME;
	_RenderingInfo[(new std::string("RENDERING_INFO_TOTAL_DRAW_CALLS_IN_FRAME"))->c_str()] = RenderingServer::RenderingInfo::RENDERING_INFO_TOTAL_DRAW_CALLS_IN_FRAME;
	_RenderingInfo[(new std::string("RENDERING_INFO_TEXTURE_MEM_USED"))->c_str()] = RenderingServer::RenderingInfo::RENDERING_INFO_TEXTURE_MEM_USED;
	_RenderingInfo[(new std::string("RENDERING_INFO_BUFFER_MEM_USED"))->c_str()] = RenderingServer::RenderingInfo::RENDERING_INFO_BUFFER_MEM_USED;
	_RenderingInfo[(new std::string("RENDERING_INFO_VIDEO_MEM_USED"))->c_str()] = RenderingServer::RenderingInfo::RENDERING_INFO_VIDEO_MEM_USED;
	js_singleton[(new std::string("RenderingInfo"))->c_str()] = _RenderingInfo;
	qjs::Value _Features = context->newObject();
	_Features[(new std::string("FEATURE_SHADERS"))->c_str()] = RenderingServer::Features::FEATURE_SHADERS;
	_Features[(new std::string("FEATURE_MULTITHREADED"))->c_str()] = RenderingServer::Features::FEATURE_MULTITHREADED;
	js_singleton[(new std::string("Features"))->c_str()] = _Features;
}