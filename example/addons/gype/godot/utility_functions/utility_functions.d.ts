declare global {
    declare class UtilityFunctions {
        sin(_angle_rad: number): number;
        cos(_angle_rad: number): number;
        tan(_angle_rad: number): number;
        sinh(_x: number): number;
        cosh(_x: number): number;
        tanh(_x: number): number;
        asin(_x: number): number;
        acos(_x: number): number;
        atan(_x: number): number;
        atan2(_y: number, _x: number): number;
        asinh(_x: number): number;
        acosh(_x: number): number;
        atanh(_x: number): number;
        sqrt(_x: number): number;
        fmod(_x: number, _y: number): number;
        fposmod(_x: number, _y: number): number;
        posmod(_x: number, _y: number): number;
        floor(_x: any): any;
        floorf(_x: number): number;
        floori(_x: number): number;
        ceil(_x: any): any;
        ceilf(_x: number): number;
        ceili(_x: number): number;
        round(_x: any): any;
        roundf(_x: number): number;
        roundi(_x: number): number;
        abs(_x: any): any;
        absf(_x: number): number;
        absi(_x: number): number;
        sign(_x: any): any;
        signf(_x: number): number;
        signi(_x: number): number;
        snapped(_x: any, _step: any): any;
        snappedf(_x: number, _step: number): number;
        snappedi(_x: number, _step: number): number;
        pow(_base: number, _exp: number): number;
        log(_x: number): number;
        exp(_x: number): number;
        is_nan(_x: number): boolean;
        is_inf(_x: number): boolean;
        is_equal_approx(_a: number, _b: number): boolean;
        is_zero_approx(_x: number): boolean;
        is_finite(_x: number): boolean;
        ease(_x: number, _curve: number): number;
        step_decimals(_x: number): number;
        lerp(_from: any, _to: any, _weight: any): any;
        lerpf(_from: number, _to: number, _weight: number): number;
        cubic_interpolate(_from: number, _to: number, _pre: number, _post: number, _weight: number): number;
        cubic_interpolate_angle(_from: number, _to: number, _pre: number, _post: number, _weight: number): number;
        cubic_interpolate_in_time(_from: number, _to: number, _pre: number, _post: number, _weight: number, _to_t: number, _pre_t: number, _post_t: number): number;
        cubic_interpolate_angle_in_time(_from: number, _to: number, _pre: number, _post: number, _weight: number, _to_t: number, _pre_t: number, _post_t: number): number;
        bezier_interpolate(_start: number, _control_1: number, _control_2: number, _end: number, _t: number): number;
        bezier_derivative(_start: number, _control_1: number, _control_2: number, _end: number, _t: number): number;
        angle_difference(_from: number, _to: number): number;
        lerp_angle(_from: number, _to: number, _weight: number): number;
        inverse_lerp(_from: number, _to: number, _weight: number): number;
        remap(_value: number, _istart: number, _istop: number, _ostart: number, _ostop: number): number;
        smoothstep(_from: number, _to: number, _x: number): number;
        move_toward(_from: number, _to: number, _delta: number): number;
        rotate_toward(_from: number, _to: number, _delta: number): number;
        deg_to_rad(_deg: number): number;
        rad_to_deg(_rad: number): number;
        linear_to_db(_lin: number): number;
        db_to_linear(_db: number): number;
        wrap(_value: any, _min: any, _max: any): any;
        wrapi(_value: number, _min: number, _max: number): number;
        wrapf(_value: number, _min: number, _max: number): number;
        max(_arg1: any, _arg2: any, ...arg: any): any;
        maxi(_a: number, _b: number): number;
        maxf(_a: number, _b: number): number;
        min(_arg1: any, _arg2: any, ...arg: any): any;
        mini(_a: number, _b: number): number;
        minf(_a: number, _b: number): number;
        clamp(_value: any, _min: any, _max: any): any;
        clampi(_value: number, _min: number, _max: number): number;
        clampf(_value: number, _min: number, _max: number): number;
        nearest_po2(_value: number): number;
        pingpong(_value: number, _length: number): number;
        randomize(): void;
        randi(): number;
        randf(): number;
        randi_range(_from: number, _to: number): number;
        randf_range(_from: number, _to: number): number;
        randfn(_mean: number, _deviation: number): number;
        seed(_base: number): void;
        rand_from_seed(_seed: number): PackedInt64Array;
        weakref(_obj: any): any;
        typeof(_variable: any): number;
        type_convert(_variant: any, _type: number): any;
        str(_arg1: any, ...arg: any): String;
        error_string(_error: number): String;
        type_string(_type: number): String;
        print(_arg1: any, ...arg: any): void;
        print_rich(_arg1: any, ...arg: any): void;
        printerr(_arg1: any, ...arg: any): void;
        printt(_arg1: any, ...arg: any): void;
        prints(_arg1: any, ...arg: any): void;
        printraw(_arg1: any, ...arg: any): void;
        print_verbose(_arg1: any, ...arg: any): void;
        push_error(_arg1: any, ...arg: any): void;
        push_warning(_arg1: any, ...arg: any): void;
        var_to_str(_variable: any): String;
        str_to_var(_string: GDString | StringName | string): any;
        var_to_bytes(_variable: any): PackedByteArray;
        bytes_to_var(_bytes: PackedByteArray): any;
        var_to_bytes_with_objects(_variable: any): PackedByteArray;
        bytes_to_var_with_objects(_bytes: PackedByteArray): any;
        hash(_variable: any): number;
        instance_from_id(_instance_id: number): GodotObject;
        is_instance_id_valid(_id: number): boolean;
        is_instance_valid(_instance: any): boolean;
        rid_allocate_id(): number;
        rid_from_int64(_base: number): RID;
        is_same(_a: any, _b: any): boolean;
    }
    const GD: UtilityFunctions;
}
export {};