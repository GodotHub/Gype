#pragma once

#include "godot_headers.hpp"
#include "quickjs.h"

#include <algorithm>
#include <cassert>
#include <cstddef>
#include <filesystem>
#include <fstream>
#include <functional>
#include <ios>
#include <memory>
#include <optional>
#include <sstream>
#include <stdexcept>
#include <string>
#include <string_view>
#include <tuple>
#include <type_traits>
#include <unordered_map>
#include <variant>
#include <vector>

#if defined(__cpp_rtti)
#define QJSPP_TYPENAME(...) (typeid(__VA_ARGS__).name())
#else
#define QJSPP_TYPENAME(...) #__VA_ARGS__
#endif

namespace qjs {

class Context;
class Value;

template <typename>
struct is_bitfield : std::false_type {};

template <typename T>
struct is_bitfield<godot::BitField<T>> : std::true_type {};

/** Exception type.
 * Indicates that exception has occured in JS context.
 */
class exception {
	JSContext *ctx;

public:
	exception(JSContext *ctx) :
			ctx(ctx) {}
	Context &context() const;

	/// Clears and returns the occurred exception.
	Value get();
};

/** std::shared_ptr, for compatibility with quickjspp v2. */
template <class T>
using shared_ptr = std::shared_ptr<T>;
/** std::make_shared, for compatibility with quickjspp v2. */
template <class T, typename... Args>
shared_ptr<T> make_shared(JSContext *, Args &&...args) {
	return std::make_shared<T>(std::forward<Args>(args)...);
}

/** Javascript conversion traits.
 * Describes how to convert type R to/from JSValue. Second template argument can be used for SFINAE/enable_if type filters.
 */
template <typename R, typename /*_SFINAE*/ = void>
struct js_traits {
	/** Create an object of C++ type R given JSValue v and JSContext.
	 * This function is intentionally not implemented. User should implement this function for their own type.
	 * @param v This value is passed as JSValueConst so it should be freed by the caller.
	 * @throws exception in case of conversion error
	 */
	static R unwrap(JSContext *ctx, JSValueConst v) = delete;

	/** Create JSValue from an object of type R and JSContext.
	 * This function is intentionally not implemented. User should implement this function for their own type.
	 * @return Returns JSValue which should be freed by the caller or JS_EXCEPTION in case of error.
	 */
	static JSValue wrap(JSContext *ctx, R value) = delete;
};

/** Conversion traits for JSValue (identity).
 */
template <>
struct js_traits<JSValue> {
	static JSValue unwrap(JSContext *ctx, JSValueConst v) noexcept {
		return JS_DupValue(ctx, v);
	}

	static JSValue wrap(JSContext *ctx, JSValue &&v) noexcept {
		return v;
	}
};

/** Conversion traits for integers.
 * Intentionally doesn't define traits for uint64_t since it can be typedefed to JSValue. (@see JS_NAN_BOXING)
 */
template <typename Int>
struct js_traits<Int, std::enable_if_t<std::is_integral_v<Int> && sizeof(Int) <= sizeof(int64_t) && !std::is_same_v<Int, uint64_t>>> {
	/// @throws exception
	static Int unwrap(JSContext *ctx, JSValueConst v) {
		if constexpr (sizeof(Int) > sizeof(int32_t)) {
			int64_t r;
			if (JS_ToInt64(ctx, &r, v))
				throw exception{ ctx };
			return static_cast<Int>(r);
		} else {
			int32_t r;
			if (JS_ToInt32(ctx, &r, v))
				throw exception{ ctx };
			return static_cast<Int>(r);
		}
	}

	static JSValue wrap(JSContext *ctx, Int i) noexcept {
		if constexpr (std::is_same_v<Int, uint32_t> || sizeof(Int) > sizeof(int32_t))
			return JS_NewInt64(ctx, static_cast<Int>(i));
		else
			return JS_NewInt32(ctx, static_cast<Int>(i));
	}
};

/** Conversion traits for boolean.
 */
template <>
struct js_traits<bool> {
	static bool unwrap(JSContext *ctx, JSValueConst v) noexcept {
		// TODO: is this behaviour correct?
		return JS_ToBool(ctx, v) > 0;
	}

	static JSValue wrap(JSContext *ctx, bool i) noexcept {
		return JS_NewBool(ctx, i);
	}
};

/** Conversion trait for void.
 */
template <>
struct js_traits<void> {
	/// @throws exception if jsvalue is neither undefined nor null
	static void unwrap(JSContext *ctx, JSValueConst value) {
		if (JS_IsException(value))
			throw exception{ ctx };
	}
};

template <>
struct js_traits<int &> {
	/// @throws exception
	static int &unwrap(JSContext *ctx, JSValueConst v) {
		int *r;
		if (JS_ToInt32(ctx, r, v))
			throw exception{ ctx };
		int ret = static_cast<int>(*r);
		int *ptr = &ret;
		return *ptr;
	}

	static JSValue wrap(JSContext *ctx, int &v) noexcept {
		return JS_NewInt32(ctx, v);
	}
};
template <>
struct js_traits<float> {
	/// @throws exception
	static float unwrap(JSContext *ctx, JSValueConst v) {
		double r;
		if (JS_ToFloat64(ctx, &r, v))
			throw exception{ ctx };
		return r;
	}

	static JSValue wrap(JSContext *ctx, float v) noexcept {
		return JS_NewFloat64(ctx, v);
	}
};
template <>
struct js_traits<float &> {
	/// @throws exception
	static float &unwrap(JSContext *ctx, JSValueConst v) {
		double *r;
		if (JS_ToFloat64(ctx, r, v))
			throw exception{ ctx };
		float ret = static_cast<float>(*r);
		float *ptr = &ret;
		return *ptr;
	}

	static JSValue wrap(JSContext *ctx, float &v) noexcept {
		return JS_NewFloat64(ctx, v);
	}
};
template <>
struct js_traits<double> {
	/// @throws exception
	static double unwrap(JSContext *ctx, JSValueConst v) {
		double r;
		if (JS_ToFloat64(ctx, &r, v))
			throw exception{ ctx };
		return r;
	}

	static JSValue wrap(JSContext *ctx, double v) noexcept {
		return JS_NewFloat64(ctx, v);
	}
};
template <>
struct js_traits<double &> {
	/// @throws exception
	static double &unwrap(JSContext *ctx, JSValueConst v) {
		double *r;
		if (JS_ToFloat64(ctx, r, v))
			throw exception{ ctx };
		double ret = static_cast<double>(*r);
		double *ptr = &ret;
		return *ptr;
	}

	static JSValue wrap(JSContext *ctx, double &v) noexcept {
		return JS_NewFloat64(ctx, v);
	}
};
template <>
struct js_traits<char *> {
	/// @throws exception
	static char *unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsString(v))
			throw exception{ ctx };
		return const_cast<char *>(JS_ToCString(ctx, v));
	}

	static JSValue wrap(JSContext *ctx, char *v) noexcept {
		return JS_NewString(ctx, reinterpret_cast<const char *>(v));
	}
};
template <>
struct js_traits<const char16_t *> {
	/// @throws exception
	static char16_t *unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsString(v))
			throw exception{ ctx };
		return reinterpret_cast<char16_t *>(const_cast<char *>(JS_ToCString(ctx, v)));
	}

	static JSValue wrap(JSContext *ctx, char16_t *v) noexcept {
		return JS_NewString(ctx, reinterpret_cast<const char *>(v));
	}
};
template <>
struct js_traits<const char32_t *> {
	/// @throws exception
	static char32_t *unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsString(v))
			throw exception{ ctx };
		return reinterpret_cast<char32_t *>(const_cast<char *>(JS_ToCString(ctx, v)));
	}

	static JSValue wrap(JSContext *ctx, char32_t *v) noexcept {
		return JS_NewString(ctx, reinterpret_cast<const char *>(v));
	}
};
template <>
struct js_traits<const wchar_t *> {
	/// @throws exception
	static wchar_t *unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsString(v))
			throw exception{ ctx };
		return reinterpret_cast<wchar_t *>(const_cast<char *>(JS_ToCString(ctx, v)));
	}

	static JSValue wrap(JSContext *ctx, wchar_t *v) noexcept {
		return JS_NewString(ctx, reinterpret_cast<const char *>(v));
	}
};

template <>
struct js_traits<std::nullptr_t> {
	static JSValue wrap(JSContext *ctx, std::nullptr_t value) {
		return JS_NULL;
	}

	static std::nullptr_t unwrap(JSContext *ctx, JSValueConst value) {
		if (JS_IsNull(value))
			throw exception{ ctx };
		return nullptr;
	}
};

template <>
struct js_traits<void *> {
	static JSValue wrap(JSContext *ctx, void *value) {
		return JS_NewInt64(ctx, reinterpret_cast<int64_t>(value));
	}

	static void *unwrap(JSContext *ctx, JSValueConst value) {
		int64_t ptr;
		if (JS_ToInt64(ctx, &ptr, value))
			throw exception{ ctx };
		return reinterpret_cast<void *>(ptr);
	}
};

template <>
struct js_traits<const void *> {
	static JSValue wrap(JSContext *ctx, const void *value) {
		return JS_NewBigUint64(ctx, reinterpret_cast<uint64_t>(value));
	}

	static const void *unwrap(JSContext *ctx, JSValueConst value) {
		uint64_t ptr;
		if (JS_ToIndex(ctx, &ptr, value))
			throw exception{ ctx };
		return reinterpret_cast<const void *>(ptr);
	}
};

template <>
struct js_traits<const void *const *> {
	static JSValue wrap(JSContext *ctx, const void *const *value) {
		auto jsArray = JS_NewArray(ctx);

		for (int i = 0; i < 4; i++) {
			int elem = *reinterpret_cast<const int *>(value[i]);
			JSValue jsElem = JS_NewInt32(ctx, elem);
			JS_SetPropertyUint32(ctx, jsArray, i, jsElem);
		}

		return jsArray;
	}

	static const void *const *unwrap(JSContext *ctx, JSValueConst v) {
		throw std::runtime_error("Unwrapping to const void* const* is not implemented");
	}
};

template <>
struct js_traits<long long unsigned int> {
	static JSValue wrap(JSContext *ctx, long long unsigned int value) {
		return JS_NewInt64(ctx, static_cast<int64_t>(value));
	}

	static long long unsigned int unwrap(JSContext *ctx, JSValueConst value) {
		int64_t ptr;
		if (JS_ToInt64(ctx, &ptr, value))
			throw exception{ ctx };
		return static_cast<long long unsigned int>(ptr);
	}
};

template <>
struct js_traits<long long int> {
	static JSValue wrap(JSContext *ctx, long long int value) {
		return JS_NewInt64(ctx, static_cast<int64_t>(value));
	}

	static long long int unwrap(JSContext *ctx, JSValueConst value) {
		int64_t ptr;
		if (JS_ToInt64(ctx, &ptr, value)) {
			throw exception{ ctx };
		}
		return static_cast<long long int>(ptr);
	}
};

template <>
struct js_traits<unsigned char *> {
	static JSValue wrap(JSContext *ctx, unsigned char *value) {
		return JS_NewString(ctx, reinterpret_cast<const char *>(value));
	}

	static unsigned char *unwrap(JSContext *ctx, JSValueConst value) {
		if (JS_IsString(value)) {
			return reinterpret_cast<unsigned char *>(const_cast<char *>(JS_ToCString(ctx, value)));
		} else {
			throw exception{ ctx };
		}
	}
};

template <>
struct js_traits<godot::Variant> {
	/// @throws exception
	static godot::Variant unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsNumber(v)) {
			if (JS_IsInt(v)) {
				int32_t num;
				if (JS_ToInt32(ctx, &num, v)) {
					return num;
				}
			} else if (JS_IsFloat(v)) {
				double num;
				if (JS_ToFloat64(ctx, &num, v)) {
					return num;
				}
			}
		} else if (JS_IsBool(v)) {
			return JS_ToBool(ctx, v);
		} else if (JS_IsString(v)) {
			return JS_ToCString(ctx, v);
		}
		return nullptr;
	}

	static JSValue wrap(JSContext *ctx, godot::Variant variant) noexcept {
		switch (variant.get_type()) {
			case godot::Variant::Type::INT:
				return JS_NewInt32(ctx, variant);
			case godot::Variant::Type::FLOAT:
				return JS_NewFloat64(ctx, variant);
			case godot::Variant::Type::BOOL:
				return JS_NewBool(ctx, variant);
			case godot::Variant::Type::STRING:
			case godot::Variant::Type::STRING_NAME:
				return JS_NewString(ctx, (const char *)variant._native_ptr());
			default:
				return JS_UNDEFINED;
		}
	}
};

namespace detail {
/** Fake std::string_view which frees the string on destruction.
 */
class js_string : public std::string_view {
	using Base = std::string_view;
	JSContext *ctx = nullptr;

	friend struct js_traits<std::string_view>;

	js_string(JSContext *ctx, const char *ptr, std::size_t len) :
			Base(ptr, len), ctx(ctx) {}

public:
	template <typename... Args>
	js_string(Args &&...args) :
			Base(std::forward<Args>(args)...), ctx(nullptr) {}

	js_string(const js_string &other) = delete;

	operator const char *() const {
		return this->data();
	}

	~js_string() {
		if (ctx)
			JS_FreeCString(ctx, this->data());
	}
};
} // namespace detail

/** Conversion traits from std::string_view and to detail::js_string. */
template <>
struct js_traits<std::string_view> {
	static detail::js_string unwrap(JSContext *ctx, JSValueConst v) {
		size_t plen;
		const char *ptr = JS_ToCStringLen(ctx, &plen, v);
		if (!ptr)
			throw exception{ ctx };
		return detail::js_string{ ctx, ptr, plen };
	}

	static JSValue wrap(JSContext *ctx, std::string_view str) noexcept {
		return JS_NewStringLen(ctx, str.data(), str.size());
	}
};

/** Conversion traits for std::string */
template <> // slower
struct js_traits<std::string> {
	static std::string unwrap(JSContext *ctx, JSValueConst v) {
		auto str_view = js_traits<std::string_view>::unwrap(ctx, v);
		return std::string{ str_view.data(), str_view.size() };
	}

	static JSValue wrap(JSContext *ctx, const std::string &str) noexcept {
		return JS_NewStringLen(ctx, str.data(), str.size());
	}
};

/** Conversion from const char * */
template <>
struct js_traits<const char *> {
	static JSValue wrap(JSContext *ctx, const char *str) noexcept {
		return JS_NewString(ctx, str);
	}

	static detail::js_string unwrap(JSContext *ctx, JSValueConst v) {
		return js_traits<std::string_view>::unwrap(ctx, v);
	}
};

/** Conversion from const std::variant */
template <typename... Ts>
struct js_traits<std::variant<Ts...>> {
	static JSValue wrap(JSContext *ctx, std::variant<Ts...> value) noexcept {
		return std::visit([ctx](auto &&value) {
            using T = std::decay_t<decltype(value)>;
            return js_traits<T>::wrap(ctx, value); }, std::move(value));
	}

	/* Useful type traits */
	template <typename T>
	struct is_shared_ptr : std::false_type {
	};
	template <typename T>
	struct is_shared_ptr<std::shared_ptr<T>> : std::true_type {
	};
	template <typename T>
	struct is_string {
		static constexpr bool value = std::is_same_v<T, const char *> || std::is_same_v<std::decay_t<T>, std::string> ||
				std::is_same_v<std::decay_t<T>, std::string_view>;
	};
	template <typename T>
	struct is_boolean {
		static constexpr bool value = std::is_same_v<std::decay_t<T>, bool>;
	};
	template <typename T>
	struct is_double {
		static constexpr bool value = std::is_same_v<std::decay_t<T>, double>;
	};
	template <typename T>
	struct is_vector : std::false_type {
	};
	template <typename T>
	struct is_vector<std::vector<T>> : std::true_type {
	};
	template <typename T>
	struct is_pair : std::false_type {
	};
	template <typename U, typename V>
	struct is_pair<std::pair<U, V>> : std::true_type {
	};
	template <typename T>
	struct is_variant : std::false_type {
	};
	template <typename... Us>
	struct is_variant<std::variant<Us...>> : std::true_type {
	};

	/** Attempt to match common types (integral, floating-point, string, etc.) */
	template <template <typename R> typename Trait, typename U, typename... Us>
	static std::optional<std::variant<Ts...>> unwrapImpl(JSContext *ctx, JSValueConst v) {
		if constexpr (Trait<U>::value) {
			return js_traits<U>::unwrap(ctx, v);
		}
		if constexpr ((sizeof...(Us)) > 0) {
			return unwrapImpl<Trait, Us...>(ctx, v);
		}
		return std::nullopt;
	}

	/** Attempt to match class ID with type */
	template <typename U, typename... Us>
	static std::optional<std::variant<Ts...>> unwrapObj(JSContext *ctx, JSValueConst v, JSClassID class_id) {
		if constexpr (is_shared_ptr<U>::value) {
			if (class_id == js_traits<U>::QJSClassId) {
				return js_traits<U>::unwrap(ctx, v);
			}
		}

		// try to unwrap embedded variant (variant<variant<...>>), might be slow
		if constexpr (is_variant<U>::value) {
			if (auto opt = js_traits<std::optional<U>>::unwrap(ctx, v))
				return *opt;
		}

		if constexpr (is_vector<U>::value) {
			if (JS_IsArray(ctx, v) == 1) {
				auto firstElement = JS_GetPropertyUint32(ctx, v, 0);
				bool ok = isCompatible<std::decay_t<typename U::value_type>>(ctx, firstElement);
				JS_FreeValue(ctx, firstElement);
				if (ok) {
					return U{ js_traits<U>::unwrap(ctx, v) };
				}
			}
		}

		if constexpr (is_pair<U>::value) {
			if (JS_IsArray(ctx, v) == 1) {
				// todo: check length?
				auto firstElement = JS_GetPropertyUint32(ctx, v, 0);
				auto secondElement = JS_GetPropertyUint32(ctx, v, 1);
				bool ok = isCompatible<std::decay_t<typename U::first_type>>(ctx, firstElement) && isCompatible<std::decay_t<typename U::second_type>>(ctx, secondElement);
				JS_FreeValue(ctx, firstElement);
				JS_FreeValue(ctx, secondElement);
				if (ok) {
					return U{ js_traits<U>::unwrap(ctx, v) };
				}
			}
		}

		if constexpr ((sizeof...(Us)) > 0) {
			return unwrapObj<Us...>(ctx, v, class_id);
		}
		return std::nullopt;
	}

	/** Attempt to cast to types satisfying traits, ordered in terms of priority */
	template <template <typename T> typename Trait, template <typename T> typename... Traits>
	static std::variant<Ts...> unwrapPriority(JSContext *ctx, JSValueConst v) {
		if (auto result = unwrapImpl<Trait, Ts...>(ctx, v)) {
			return *result;
		}
		if constexpr ((sizeof...(Traits)) > 0) {
			return unwrapPriority<Traits...>(ctx, v);
		}
		JS_ThrowTypeError(ctx, "Expected type %s", QJSPP_TYPENAME(std::variant<Ts...>));
		throw exception{ ctx };
	}

	template <typename T>
	static bool isCompatible(JSContext *ctx, JSValueConst v) noexcept {
		// const char * type_name = typeid(T).name();
		switch (JS_VALUE_GET_TAG(v)) {
			case JS_TAG_STRING:
				return is_string<T>::value;

			case JS_TAG_FUNCTION_BYTECODE:
				return std::is_function<T>::value;
			case JS_TAG_OBJECT:
				if (JS_IsArray(ctx, v) == 1)
					return is_vector<T>::value || is_pair<T>::value;
				if constexpr (is_shared_ptr<T>::value) {
					if (JS_GetClassID(v) == js_traits<T>::QJSClassId)
						return true;
				}
				return false;

			case JS_TAG_INT:
				[[fallthrough]];
			case JS_TAG_BIG_INT:
				return std::is_integral_v<T> || std::is_floating_point_v<T>;
			case JS_TAG_BOOL:
				return is_boolean<T>::value || std::is_integral_v<T> || std::is_floating_point_v<T>;

			case JS_TAG_BIG_DECIMAL:
				[[fallthrough]];
			case JS_TAG_BIG_FLOAT:
				[[fallthrough]];
			case JS_TAG_FLOAT64:
			default: // >JS_TAG_FLOAT64 (JS_NAN_BOXING)
				return is_double<T>::value || std::is_floating_point_v<T>;

			case JS_TAG_SYMBOL:
				[[fallthrough]];
			case JS_TAG_MODULE:
				[[fallthrough]];
			case JS_TAG_NULL:
				[[fallthrough]];
			case JS_TAG_UNDEFINED:
				[[fallthrough]];
			case JS_TAG_UNINITIALIZED:
				[[fallthrough]];
			case JS_TAG_CATCH_OFFSET:
				[[fallthrough]];
			case JS_TAG_EXCEPTION:
				break;
		}
		return false;
	}

	static std::variant<Ts...> unwrap(JSContext *ctx, JSValueConst v) {
		const auto tag = JS_VALUE_GET_TAG(v);
		switch (tag) {
			case JS_TAG_STRING:
				return unwrapPriority<is_string>(ctx, v);

			case JS_TAG_FUNCTION_BYTECODE:
				return unwrapPriority<std::is_function>(ctx, v);
			case JS_TAG_OBJECT:
				if (auto result = unwrapObj<Ts...>(ctx, v, JS_GetClassID(v))) {
					return *result;
				}
				JS_ThrowTypeError(ctx, "Expected type %s, got object with classid %d",
						QJSPP_TYPENAME(std::variant<Ts...>), JS_GetClassID(v));
				break;

			case JS_TAG_INT:
				[[fallthrough]];
			case JS_TAG_BIG_INT:
				return unwrapPriority<std::is_integral, std::is_floating_point>(ctx, v);
			case JS_TAG_BOOL:
				return unwrapPriority<is_boolean, std::is_integral, std::is_floating_point>(ctx, v);

			case JS_TAG_SYMBOL:
				[[fallthrough]];
			case JS_TAG_MODULE:
				[[fallthrough]];
			case JS_TAG_NULL:
				[[fallthrough]];
			case JS_TAG_UNDEFINED:
				[[fallthrough]];
			case JS_TAG_UNINITIALIZED:
				[[fallthrough]];
			case JS_TAG_CATCH_OFFSET:
				JS_ThrowTypeError(ctx, "Expected type %s, got tag %d", QJSPP_TYPENAME(std::variant<Ts...>), tag);
				[[fallthrough]];
			case JS_TAG_EXCEPTION:
				break;

			case JS_TAG_BIG_DECIMAL:
				[[fallthrough]];
			case JS_TAG_BIG_FLOAT:
				[[fallthrough]];

			case JS_TAG_FLOAT64:
				[[fallthrough]];
			default: // more than JS_TAG_FLOAT64 (nan boxing)
				return unwrapPriority<is_double, std::is_floating_point>(ctx, v);
		}

		throw exception{ ctx };
	}
};

// template <typename T>
// struct rest : std::vector<T> {
// 	using std::vector<T>::vector;
// 	using std::vector<T>::operator=;
// };

namespace detail {

/** Helper function to convert and then free JSValue. */
template <typename T>
T unwrap_free(JSContext *ctx, JSValue val) {
	if constexpr (std::is_same_v<T, void>) {
		JS_FreeValue(ctx, val);
		return js_traits<T>::unwrap(ctx, val);
	} else {
		try {
			T result = js_traits<std::decay_t<T>>::unwrap(ctx, val);
			JS_FreeValue(ctx, val);
			return result;
		} catch (...) {
			JS_FreeValue(ctx, val);
			throw;
		}
	}
}

template <typename T, size_t I, size_t NArgs>
struct unwrap_arg_impl {
	static auto unwrap(JSContext *ctx, int argc, JSValueConst *argv) {
		if (size_t(argc) <= I) {
			JS_ThrowTypeError(ctx, "Expected at least %lu arguments but received %d",
					(unsigned long)NArgs, argc);
			throw exception{ ctx };
		}
		return js_traits<std::decay_t<T>>::unwrap(ctx, argv[I]);
	}
};

template <typename T, size_t I, size_t NArgs>
struct unwrap_arg_impl<rest<T>, I, NArgs> {
	static rest<T> unwrap(JSContext *ctx, int argc, JSValueConst *argv) {
		static_assert(I == NArgs - 1, "The `rest` argument must be the last function argument.");
		rest<T> result;
		result.reserve(argc - I);
		for (size_t i = I; i < size_t(argc); ++i)
			result.push_back(js_traits<T>::unwrap(ctx, argv[i]));
		return result;
	}
};

template <class Tuple, std::size_t... I>
Tuple unwrap_args_impl(JSContext *ctx, int argc, JSValueConst *argv, std::index_sequence<I...>) {
	return Tuple{ unwrap_arg_impl<std::tuple_element_t<I, Tuple>, I, sizeof...(I)>::unwrap(ctx, argc, argv)... };
}

/** Helper function to convert an array of JSValues to a tuple.
 * @tparam Args C++ types of the argv array
 */
template <typename... Args>
std::tuple<std::decay_t<Args>...> unwrap_args(JSContext *ctx, int argc, JSValueConst *argv) {
	return unwrap_args_impl<std::tuple<std::decay_t<Args>...>>(ctx, argc, argv, std::make_index_sequence<sizeof...(Args)>());
}

/** Helper function to call f with an array of JSValues.
 * @tparam R return type of f
 * @tparam Args argument types of f
 * @tparam Callable type of f (inferred)
 * @param ctx JSContext
 * @param f callable object
 * @param argv array of JSValue's
 * @return converted return value of f or JS_NULL if f returns void
 */
template <typename R, typename... Args, typename Callable>
JSValue wrap_call(JSContext *ctx, Callable &&f, int argc, JSValueConst *argv) noexcept {
	try {
		if constexpr (std::is_same_v<R, void>) {
			std::apply(std::forward<Callable>(f), unwrap_args<Args...>(ctx, argc, argv));
			return JS_NULL;
		} else {
			return js_traits<std::decay_t<R>>::wrap(ctx,
					std::apply(std::forward<Callable>(f),
							unwrap_args<Args...>(ctx, argc, argv)));
		}
	} catch (exception) {
		return JS_EXCEPTION;
	} catch (std::exception const &err) {
		JS_ThrowInternalError(ctx, "%s", err.what());
		return JS_EXCEPTION;
	} catch (...) {
		JS_ThrowInternalError(ctx, "Unknown error");
		return JS_EXCEPTION;
	}
}

/** Same as wrap_call, but pass this_value as first argument.
 * @tparam FirstArg type of this_value
 */
template <typename R, typename FirstArg, typename... Args, typename Callable>
JSValue wrap_this_call(JSContext *ctx, Callable &&f, JSValueConst this_value, int argc, JSValueConst *argv) noexcept {
	try {
		if constexpr (std::is_same_v<R, void>) {
			std::apply(std::forward<Callable>(f), std::tuple_cat(unwrap_args<FirstArg>(ctx, 1, &this_value), unwrap_args<Args...>(ctx, argc, argv)));
			return JS_NULL;
		} else {
			return js_traits<std::decay_t<R>>::wrap(ctx,
					std::apply(std::forward<Callable>(f),
							std::tuple_cat(
									unwrap_args<FirstArg>(ctx, 1, &this_value),
									unwrap_args<Args...>(ctx, argc, argv))));
		}
	} catch (exception) {
		return JS_EXCEPTION;
	} catch (std::exception const &err) {
		JS_ThrowInternalError(ctx, "%s", err.what());
		return JS_EXCEPTION;
	} catch (...) {
		JS_ThrowInternalError(ctx, "Unknown error");
		return JS_EXCEPTION;
	}
}

template <class Tuple, std::size_t... I>
void wrap_args_impl(JSContext *ctx, JSValue *argv, Tuple tuple, std::index_sequence<I...>) {
	((argv[I] = js_traits<std::decay_t<std::tuple_element_t<I, Tuple>>>::wrap(ctx, std::get<I>(tuple))), ...);
}

/** Converts C++ args to JSValue array.
 * @tparam Args argument types
 * @param argv array of size at least sizeof...(Args)
 */
template <typename... Args>
void wrap_args(JSContext *ctx, JSValue *argv, Args &&...args) {
	wrap_args_impl(ctx, argv, std::make_tuple(std::forward<Args>(args)...),
			std::make_index_sequence<sizeof...(Args)>());
}

// Helper trait to obtain `T` in `T::*` expressions
template <typename T>
struct class_from_member_pointer {
	using type = void;
};
template <typename T, typename U>
struct class_from_member_pointer<T U::*> {
	using type = U;
};
template <typename T>
using class_from_member_pointer_t = typename class_from_member_pointer<T>::type;

} // namespace detail

/** A wrapper type for free and class member functions.
 * Pointer to function F is a template argument.
 * @tparam F either a pointer to free function or a pointer to class member function
 * @tparam PassThis if true and F is a pointer to free function, passes Javascript "this" value as first argument:
 */
template <auto F, bool PassThis = false /* pass this as the first argument */>
struct fwrapper {
	/// "name" property of the JS function object (not defined if nullptr)
	const char *name = nullptr;
};

/** Conversion to JSValue for free function in fwrapper. */
template <typename R, typename... Args, R (*F)(Args...), bool PassThis>
struct js_traits<fwrapper<F, PassThis>> {
	static JSValue wrap(JSContext *ctx, fwrapper<F, PassThis> fw) noexcept {
		return JS_NewCFunction(ctx, [](JSContext *ctx, JSValueConst this_value, int argc, JSValueConst *argv) noexcept -> JSValue {
            if constexpr(PassThis)
                return detail::wrap_this_call<R, Args...>(ctx, F, this_value, argc, argv);
            else
                return detail::wrap_call<R, Args...>(ctx, F, argc, argv); }, fw.name, sizeof...(Args));
	}
};

/** Conversion to JSValue for class member function in fwrapper. PassThis is ignored and treated as true */
template <typename R, class T, typename... Args, R (T::*F)(Args...), bool PassThis /*=ignored*/>
struct js_traits<fwrapper<F, PassThis>> {
	static JSValue wrap(JSContext *ctx, fwrapper<F, PassThis> fw) noexcept {
		return JS_NewCFunction(ctx, [](JSContext *ctx, JSValueConst this_value, int argc, JSValueConst *argv) noexcept -> JSValue { return detail::wrap_this_call<R, std::shared_ptr<T>, Args...>(ctx, F, this_value, argc, argv); }, fw.name, sizeof...(Args));
	}
};

/** Conversion to JSValue for const class member function in fwrapper. PassThis is ignored and treated as true */
template <typename R, class T, typename... Args, R (T::*F)(Args...) const, bool PassThis /*=ignored*/>
struct js_traits<fwrapper<F, PassThis>> {
	static JSValue wrap(JSContext *ctx, fwrapper<F, PassThis> fw) noexcept {
		return JS_NewCFunction(ctx, [](JSContext *ctx, JSValueConst this_value, int argc, JSValueConst *argv) noexcept -> JSValue { return detail::wrap_this_call<R, std::shared_ptr<T>, Args...>(ctx, F, this_value, argc, argv); }, fw.name, sizeof...(Args));
	}
};

/** A wrapper type for constructor of type T with arguments Args.
 * Compilation fails if no such constructor is defined.
 * @tparam Args constructor arguments
 */
template <class T, typename... Args>
struct ctor_wrapper {
	static_assert(std::is_constructible<T, Args...>::value, "no such constructor!");
	/// "name" property of JS constructor object
	const char *name = nullptr;
};

namespace detail {
/// equivalent to JS_GetPropertyStr(ctx, this_value, "prototype");
inline JSValue GetPropertyPrototype(JSContext *ctx, JSValueConst this_value) {
	// constant atom: doesn't need to be freed and doesn't change with context
	static const JSAtom JS_ATOM_prototype = JS_NewAtom(ctx, "prototype");
	return JS_GetProperty(ctx, this_value, JS_ATOM_prototype);
}
} // namespace detail

/** Conversion to JSValue for ctor_wrapper. */
template <class T, typename... Args>
struct js_traits<ctor_wrapper<T, Args...>> {
	static JSValue wrap(JSContext *ctx, ctor_wrapper<T, Args...> cw) noexcept {
		return JS_NewCFunction2(ctx, [](JSContext *ctx, JSValueConst this_value, int argc, JSValueConst *argv) noexcept -> JSValue {
			if (js_traits<std::shared_ptr<T>>::QJSClassId == 0) // not registered
			{
#if defined(__cpp_rtti)
				// automatically register class on first use (no prototype)
				js_traits<std::shared_ptr<T>>::register_class(ctx, typeid(T).name());
#else
				JS_ThrowTypeError(ctx, "quickjspp ctor_wrapper<T>::wrap: Class is not registered");
				return JS_EXCEPTION;
#endif
			}

			auto proto = detail::GetPropertyPrototype(ctx, this_value);
			if (JS_IsException(proto))
				return proto;
			auto jsobj = JS_NewObjectProtoClass(ctx, proto, js_traits<std::shared_ptr<T>>::QJSClassId);
			JS_FreeValue(ctx, proto);
			if (JS_IsException(jsobj))
				return jsobj;

			try {
				std::shared_ptr<T> ptr = std::apply(std::make_shared<T, Args...>, detail::unwrap_args<Args...>(ctx, argc, argv));
				JS_SetOpaque(jsobj, new std::shared_ptr<T>(std::move(ptr)));
				return jsobj;
			} catch (exception) {
				JS_FreeValue(ctx, jsobj);
				return JS_EXCEPTION;
			} catch (std::exception const &err) {
				JS_FreeValue(ctx, jsobj);
				JS_ThrowInternalError(ctx, "%s", err.what());
				return JS_EXCEPTION;
			} catch (...) {
				JS_FreeValue(ctx, jsobj);
				JS_ThrowInternalError(ctx, "Unknown error");
				return JS_EXCEPTION;
			}

			// return detail::wrap_call<std::shared_ptr<T>, Args...>(ctx, std::make_shared<T, Args...>, argv);
		},
				cw.name, sizeof...(Args), JS_CFUNC_constructor, 0);
	}
};

/** Conversions for std::shared_ptr<T>. Empty shared_ptr corresponds to JS_NULL.
 * T should be registered to a context before conversions.
 * @tparam T class type
 */
template <class T>
struct js_traits<std::shared_ptr<T>> {
	/// Registered class id in QuickJS.
	inline static JSClassID QJSClassId = 0;

	/// Signature of the function to obtain the std::shared_ptr from the JSValue.
	using ptr_cast_fcn_t = std::function<std::shared_ptr<T>(JSContext *, JSValueConst)>;

	/// Used by registerDerivedClass to register new derived classes with this class' base type.
	inline static std::function<void(JSClassID, ptr_cast_fcn_t)> registerWithBase;

	/// Mapping between derived class' JSClassID and function to obtain the std::shared_ptr from the JSValue.
	inline static std::unordered_map<JSClassID, ptr_cast_fcn_t> ptrCastFcnMap;

	/** Register a class as a derived class.
	 *
	 * @tparam D type of the derived class
	 * @param derived_class_id class id of the derived class
	 * @param ptr_cast_fcn function to obtain a std::shared_ptr from the JSValue
	 */
	template <typename D>
	static void registerDerivedClass(JSClassID derived_class_id, ptr_cast_fcn_t ptr_cast_fcn) {
		static_assert(std::is_base_of<T, D>::value && !std::is_same<T, D>::value, "Type is not a derived class");
		using derived_ptr_cast_fcn_t = typename js_traits<std::shared_ptr<D>>::ptr_cast_fcn_t;

		// Register how to obtain the std::shared_ptr from the derived class.
		ptrCastFcnMap[derived_class_id] = ptr_cast_fcn;

		// Propagate the registration to our base class (if any).
		if (registerWithBase)
			registerWithBase(derived_class_id, ptr_cast_fcn);

		// Instrument the derived class so that it can propagate new derived classes to us.
		auto old_registerWithBase = js_traits<std::shared_ptr<D>>::registerWithBase;
		js_traits<std::shared_ptr<D>>::registerWithBase =
				[old_registerWithBase = std::move(old_registerWithBase)](JSClassID derived_class_id, derived_ptr_cast_fcn_t derived_ptr_cast_fcn) {
					if (old_registerWithBase)
						old_registerWithBase(derived_class_id, derived_ptr_cast_fcn);
					registerDerivedClass<D>(derived_class_id, [derived_cast_fcn = std::move(derived_ptr_cast_fcn)](JSContext *ctx, JSValueConst v) { return std::shared_ptr<T>(derived_cast_fcn(ctx, v)); });
				};
	}

	template <typename B>
	static std::enable_if_t<std::is_same_v<B, T> || std::is_same_v<B, void>>
	ensureCanCastToBase() {}

	template <typename B>
	static std::enable_if_t<!std::is_same_v<B, T> && !std::is_same_v<B, void>>
	ensureCanCastToBase() {
		static_assert(std::is_base_of_v<B, T>, "Type is not a derived class");

		if (js_traits<std::shared_ptr<T>>::QJSClassId == 0)
			JS_NewClassID(&js_traits<std::shared_ptr<T>>::QJSClassId);

		js_traits<std::shared_ptr<B>>::template registerDerivedClass<T>(QJSClassId, unwrap);
	}

	template <auto M>
	static void ensureCanCastToBase() {
		ensureCanCastToBase<detail::class_from_member_pointer_t<decltype(M)>>();
	}

	/** Stores offsets to qjs::Value members of T.
	 * These values should be marked by class_registrar::mark for QuickJS garbage collector
	 * so that the cycle removal algorithm can find the other objects referenced by this object.
	 */
	static inline std::vector<Value T::*> markOffsets;

	/** Register class in QuickJS context.
	 *
	 * @param ctx context
	 * @param name class name
	 * @param proto class prototype or JS_NULL
	 * @param call QJS call function. see quickjs doc
	 * @param exotic pointer to QJS exotic methods(static lifetime) which allow custom property handling. see quickjs doc
	 * @throws exception
	 */
	static void register_class(JSContext *ctx, const char *name, JSValue proto = JS_NULL,
			JSClassCall *call = nullptr, JSClassExoticMethods *exotic = nullptr) {
		if (QJSClassId == 0) {
			JS_NewClassID(&QJSClassId);
		}
		auto rt = JS_GetRuntime(ctx);
		if (!JS_IsRegisteredClass(rt, QJSClassId)) {
			JSClassGCMark *marker = nullptr;
			if (!markOffsets.empty()) {
				marker = [](JSRuntime *rt, JSValueConst val, JS_MarkFunc *mark_func) {
					auto pptr = static_cast<std::shared_ptr<T> *>(JS_GetOpaque(val, QJSClassId));
					assert(pptr);
					const T *ptr = pptr->get();
					assert(ptr);
					for (Value T::*member : markOffsets) {
						JS_MarkValue(rt, (*ptr.*member).v, mark_func);
					}
				};
			}
			JSClassDef def{
				name,
				// destructor (finalizer)
				[](JSRuntime *rt, JSValue obj) noexcept {
					auto pptr = static_cast<std::shared_ptr<T> *>(JS_GetOpaque(obj, QJSClassId));
					delete pptr;
				},
				// mark
				marker,
				// call
				call,
				// exotic
				exotic
			};
			int e = JS_NewClass(rt, QJSClassId, &def);
			if (e < 0) {
				JS_ThrowInternalError(ctx, "Can't register class %s", name);
				throw exception{ ctx };
			}
		}
		JS_SetClassProto(ctx, QJSClassId, proto);
	}

	/** Create a JSValue from std::shared_ptr<T>.
	 * Creates an object with class if #QJSClassId and sets its opaque pointer to a new copy of #ptr.
	 */
	static JSValue wrap(JSContext *ctx, std::shared_ptr<T> ptr) {
		if (!ptr)
			return JS_NULL;
		if (QJSClassId == 0) // not registered
		{
#if defined(__cpp_rtti)
			// automatically register class on first use (no prototype)
			register_class(ctx, typeid(T).name());
#else
			JS_ThrowTypeError(ctx, "quickjspp std::shared_ptr<T>::wrap: Class is not registered");
			return JS_EXCEPTION;
#endif
		}
		auto jsobj = JS_NewObjectClass(ctx, QJSClassId);
		if (JS_IsException(jsobj))
			return jsobj;

		auto pptr = new std::shared_ptr<T>(std::move(ptr));
		JS_SetOpaque(jsobj, pptr);
		return jsobj;
	}

	/// @throws exception if #v doesn't have the correct class id
	static std::shared_ptr<T> unwrap(JSContext *ctx, JSValueConst v) {
		std::shared_ptr<T> ptr = nullptr;
		if (JS_IsNull(v)) {
			return ptr;
		}
		auto obj_class_id = JS_GetClassID(v);

		if (obj_class_id == QJSClassId) {
			// The JS object is of class T
			void *opaque = JS_GetOpaque2(ctx, v, obj_class_id);
			assert(opaque && "No opaque pointer in object");
			ptr = *static_cast<std::shared_ptr<T> *>(opaque);
		} else if (ptrCastFcnMap.count(obj_class_id)) {
			// The JS object is of a class derived from T
			ptr = ptrCastFcnMap[obj_class_id](ctx, v);
		} else {
			// The JS object does not derives from T
			JS_ThrowTypeError(ctx, "Expected type %s, got object with classid %d",
					QJSPP_TYPENAME(T), obj_class_id);
			throw exception{ ctx };
		}
		if (!ptr) {
			JS_ThrowInternalError(ctx, "Object's opaque pointer is NULL");
			throw exception{ ctx };
		}
		return ptr;
	}
};

/** Conversions for non-owning pointers to class T. nullptr corresponds to JS_NULL.
 * @tparam T class type
 */
template <class T>
struct js_traits<T *, std::enable_if_t<std::is_class_v<T>>> {
	static JSValue wrap(JSContext *ctx, T *ptr) {
		if (ptr == nullptr) {
			return JS_NULL;
		}
		if (js_traits<std::shared_ptr<T>>::QJSClassId == 0) // not registered
		{
#if defined(__cpp_rtti)
			// If you have an error here with T=JSValueConst
			// it probably means you are passing JSValueConst to where JSValue is expected
			js_traits<std::shared_ptr<T>>::register_class(ctx, typeid(T).name());
#else
			JS_ThrowTypeError(ctx, "quickjspp js_traits<T *>::wrap: Class is not registered");
			return JS_EXCEPTION;
#endif
		}
		auto jsobj = JS_NewObjectClass(ctx, js_traits<std::shared_ptr<T>>::QJSClassId);
		if (JS_IsException(jsobj))
			return jsobj;

		// shared_ptr with empty deleter since we don't own T*
		auto pptr = new std::shared_ptr<T>(ptr, [](T *) {});
		JS_SetOpaque(jsobj, pptr);
		return jsobj;
	}

	static T *unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsNull(v)) {
			return nullptr;
		}
		auto ptr = js_traits<std::shared_ptr<T>>::unwrap(ctx, v);
		return ptr.get();
	}
};

/** Conversions for enums. */
template <typename E>
struct js_traits<E, std::enable_if_t<std::is_enum_v<E>>> {
	using T = std::underlying_type_t<E>;
	static E unwrap(JSContext *ctx, JSValue v) noexcept {
		return static_cast<E>(js_traits<T>::unwrap(ctx, v));
	}

	static JSValue wrap(JSContext *ctx, E t) noexcept {
		return js_traits<T>::wrap(ctx, static_cast<T>(t));
		;
	}
};

namespace detail {
/** A faster std::function-like object with type erasure.
 * Used to convert any callable objects (including lambdas) to JSValue.
 */
struct function {
	JSValue (*invoker)(function *self, JSContext *ctx, JSValueConst this_value, int argc, JSValueConst *argv) = nullptr;

	void (*destroyer)(function *self) = nullptr;

	alignas(std::max_align_t) char functor[];

	template <typename Functor>
	static function *create(JSRuntime *rt, Functor &&f) {
		using Functor_t = std::decay_t<Functor>;
		auto fptr = static_cast<function *>(js_malloc_rt(rt, sizeof(function) + sizeof(Functor_t)));
		if (!fptr)
			throw std::bad_alloc{};
		new (fptr) function;
		auto functorptr = reinterpret_cast<Functor_t *>(fptr->functor);
		new (functorptr) Functor_t(std::forward<Functor>(f));
		fptr->destroyer = nullptr;
		if constexpr (!std::is_trivially_destructible_v<Functor_t>) {
			fptr->destroyer = [](function *fptr) {
				auto functorptr = reinterpret_cast<Functor_t *>(fptr->functor);
				functorptr->~Functor_t();
			};
		}
		return fptr;
	}
};

static_assert(std::is_trivially_destructible_v<function>);
} //namespace detail

template <>
struct js_traits<detail::function> {
	inline static JSClassID QJSClassId = 0;

	// TODO: replace ctx with rt
	static void register_class(JSContext *ctx, const char *name) {
		if (QJSClassId == 0) {
			JS_NewClassID(&QJSClassId);
		}
		auto rt = JS_GetRuntime(ctx);
		if (JS_IsRegisteredClass(rt, QJSClassId))
			return;
		JSClassDef def{
			name,
			// destructor
			[](JSRuntime *rt, JSValue obj) noexcept {
				auto fptr = static_cast<detail::function *>(JS_GetOpaque(obj, QJSClassId));
				assert(fptr);
				if (fptr->destroyer)
					fptr->destroyer(fptr);
				js_free_rt(rt, fptr);
			},
			nullptr, // mark
			// call
			[](JSContext *ctx, JSValueConst func_obj, JSValueConst this_val, int argc,
					JSValueConst *argv, int flags) -> JSValue {
				auto ptr = static_cast<detail::function *>(JS_GetOpaque2(ctx, func_obj, QJSClassId));
				if (!ptr)
					return JS_EXCEPTION;
				return ptr->invoker(ptr, ctx, this_val, argc, argv);
			},
			nullptr
		};
		int e = JS_NewClass(rt, QJSClassId, &def);
		if (e < 0)
			throw std::runtime_error{ "Cannot register C++ function class" };
	}
};

/** Traits for accessing object properties.
 * @tparam Key property key type (uint32 and strings are supported)
 */
template <typename Key>
struct js_property_traits {
	static void set_property(JSContext *ctx, JSValue this_obj, Key key, JSValue value);

	static JSValue get_property(JSContext *ctx, JSValue this_obj, Key key);
};

template <>
struct js_property_traits<const char *> {
	static void set_property(JSContext *ctx, JSValue this_obj, const char *name, JSValue value) {
		int err = JS_SetPropertyStr(ctx, this_obj, name, value);
		if (err < 0)
			throw exception{ ctx };
	}

	static JSValue get_property(JSContext *ctx, JSValue this_obj, const char *name) noexcept {
		return JS_GetPropertyStr(ctx, this_obj, name);
	}
};

template <>
struct js_property_traits<uint32_t> {
	static void set_property(JSContext *ctx, JSValue this_obj, uint32_t idx, JSValue value) {
		int err = JS_SetPropertyUint32(ctx, this_obj, idx, value);
		if (err < 0)
			throw exception{ ctx };
	}

	static JSValue get_property(JSContext *ctx, JSValue this_obj, uint32_t idx) noexcept {
		return JS_GetPropertyUint32(ctx, this_obj, idx);
	}
};

template <>
struct js_property_traits<int> : js_property_traits<uint32_t> {
};

namespace detail {
template <typename Key>
struct property_proxy {
	JSContext *ctx;
	JSValue this_obj;
	Key key;

	/** Conversion helper function */
	template <typename T>
	T as() const {
		return unwrap_free<T>(ctx, js_property_traits<Key>::get_property(ctx, this_obj, key));
	}

	/** Explicit conversion operator (to any type) */
	template <typename T>
	explicit operator T() const { return as<T>(); }

	/** Implicit converion to qjs::Value */
	operator Value() const; // defined later due to Value being incomplete type

	/// noncopyable
	property_proxy &operator=(property_proxy) = delete;

	template <typename T>
	property_proxy &operator=(T &&value) {
		js_property_traits<Key>::set_property(ctx, this_obj, key,
				js_traits<std::decay_t<T>>::wrap(ctx, std::forward<T>(value)));
		return *this;
	}

	template <typename Key2>
	property_proxy<Key2> operator[](Key2 key2) const {
		return { ctx, as<JSValue>(), std::move(key2) };
	}

	~property_proxy() noexcept { JS_FreeValue(ctx, this_obj); }
};

// class member variable getter/setter
template <auto M>
struct get_set {
};

// M -  member object
template <class T, typename R, R T::*M>
struct get_set<M> {
	using is_const = std::is_const<R>;

	static const R &get(std::shared_ptr<T> ptr) {
		return *ptr.*M;
	}

	static R &set(std::shared_ptr<T> ptr, R value) {
		return *ptr.*M = std::move(value);
	}
};

// M - static member object
template <typename R, R *M>
struct get_set<M> {
	using is_const = std::is_const<R>;

	static const R &get(bool) {
		return *M;
	}

	static R &set(bool, R value) {
		return *M = std::move(value);
	}
};

} // namespace detail

/** JSValue with RAAI semantics.
 * A wrapper over (JSValue v, JSContext * ctx).
 * Calls JS_FreeValue(ctx, v) on destruction. Can be copied and moved.
 * A JSValue can be released by either JSValue x = std::move(value); or JSValue x = value.release(), then the Value becomes invalid and FreeValue won't be called
 * Can be converted to C++ type, for example: auto string = value.as<std::string>(); qjs::exception would be thrown on error
 * Properties can be accessed (read/write): value["property1"] = 1; value[2] = "2";
 */
class Value {
public:
	JSValue v;
	JSContext *ctx = nullptr;

public:
	/** Use context.newValue(val) instead */
	template <typename T>
	Value(JSContext *ctx, T &&val) :
			ctx(ctx) {
		v = js_traits<std::decay_t<T>>::wrap(ctx, std::forward<T>(val));
		if (JS_IsException(v))
			throw exception{ ctx };
	}

	Value(JSValue &&v) noexcept :
			v(std::move(v)), ctx(nullptr) {}

	Value(const Value &rhs) noexcept {
		ctx = rhs.ctx;
		v = JS_DupValue(ctx, rhs.v);
	}

	Value(Value &&rhs) noexcept {
		std::swap(ctx, rhs.ctx);
		v = rhs.v;
	}

	Value &operator=(Value rhs) noexcept {
		std::swap(ctx, rhs.ctx);
		std::swap(v, rhs.v);
		return *this;
	}

	bool operator==(JSValueConst other) const {
		return JS_VALUE_GET_TAG(v) == JS_VALUE_GET_TAG(other) && JS_VALUE_GET_PTR(v) == JS_VALUE_GET_PTR(other);
	}

	bool operator!=(JSValueConst other) const { return !((*this) == other); }

	/** Returns true if 2 values are the same (equality for arithmetic types or point to the same object) */
	bool operator==(const Value &rhs) const {
		return (*this == rhs.v);
	}

	bool operator!=(const Value &rhs) const { return !((*this) == rhs); }

	~Value() {
		if (ctx)
			JS_FreeValue(ctx, v);
	}

	bool isError() const { return JS_IsError(ctx, v); }

	/** Conversion helper function: value.as<T>()
	 * @tparam T type to convert to
	 * @return type returned by js_traits<std::decay_t<T>>::unwrap that should be implicitly convertible to T
	 * */
	template <typename T>
	auto as() const { return js_traits<std::decay_t<T>>::unwrap(ctx, v); }

	/** Explicit conversion: static_cast<T>(value) or (T)value */
	template <typename T>
	explicit operator T() const { return as<T>(); }

	JSValue release() noexcept // dont call freevalue
	{
		ctx = nullptr;
		return v;
	}

	/** Implicit conversion to JSValue (rvalue only). Example: JSValue v = std::move(value); */
	operator JSValue() && noexcept { return release(); }

	/** Access JS properties. Returns proxy type which is implicitly convertible to qjs::Value */
	template <typename Key>
	detail::property_proxy<Key> operator[](Key key) {
		assert(ctx && "Trying to access properties of Value with no JSContext");
		return { ctx, JS_DupValue(ctx, v), std::move(key) };
	}

	// add("f", []() {...});
	template <typename Function>
	Value &add(const char *name, Function &&f) {
		(*this)[name] = js_traits<decltype(std::function{ std::forward<Function>(f) })>::wrap(ctx,
				std::forward<Function>(f));
		return *this;
	}

	// add<&f>("f");
	// add<&T::f>("f");
	template <auto F>
	std::enable_if_t<std::is_member_function_pointer_v<decltype(F)> || std::is_function_v<std::remove_pointer_t<decltype(F)>>, Value &>
	add(const char *name) {
		(*this)[name] = fwrapper<F>{ name };
		return *this;
	}

	// add_getter_setter<&T::get_member, &T::set_member>("member");
	template <auto FGet, auto FSet>
	Value &add_getter_setter(const char *name) {
		auto prop = JS_NewAtom(ctx, name);
		using fgetter = fwrapper<FGet, true>;
		using fsetter = fwrapper<FSet, true>;
		int ret = JS_DefinePropertyGetSet(ctx, v, prop,
				js_traits<fgetter>::wrap(ctx, fgetter{ name }),
				js_traits<fsetter>::wrap(ctx, fsetter{ name }),
				JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE | JS_PROP_ENUMERABLE);
		JS_FreeAtom(ctx, prop);
		if (ret < 0)
			throw exception{ ctx };
		return *this;
	}

	// add_getter<&T::get_member>("member");
	template <auto FGet>
	Value &add_getter(const char *name) {
		auto prop = JS_NewAtom(ctx, name);
		using fgetter = fwrapper<FGet, true>;
		int ret = JS_DefinePropertyGetSet(ctx, v, prop,
				js_traits<fgetter>::wrap(ctx, fgetter{ name }),
				JS_UNDEFINED,
				JS_PROP_CONFIGURABLE | JS_PROP_ENUMERABLE);
		JS_FreeAtom(ctx, prop);
		if (ret < 0)
			throw exception{ ctx };
		return *this;
	}

	// add<&T::member>("member");
	template <auto M>
	std::enable_if_t<std::is_member_object_pointer_v<decltype(M)>, Value &>
	add(const char *name) {
		if constexpr (detail::get_set<M>::is_const::value)
			return add_getter<detail::get_set<M>::get>(name);
		else
			return add_getter_setter<detail::get_set<M>::get, detail::get_set<M>::set>(name);
	}

	// add<&T::static_member>("static_member");
	template <auto M>
	std::enable_if_t<std::is_pointer_v<decltype(M)> && !std::is_function_v<std::remove_pointer_t<decltype(M)>>, Value &>
	add(const char *name) {
		if constexpr (detail::get_set<M>::is_const::value)
			return add_getter<detail::get_set<M>::get>(name);
		else
			return add_getter_setter<detail::get_set<M>::get, detail::get_set<M>::set>(name);
	}

	std::string
	toJSON(const Value &replacer = JS_UNDEFINED, const Value &space = JS_UNDEFINED) {
		assert(ctx);
		assert(!replacer.ctx || ctx == replacer.ctx);
		assert(!space.ctx || ctx == space.ctx);
		return (std::string)Value{ ctx, JS_JSONStringify(ctx, v, replacer.v, space.v) };
	}

	/** same as Context::eval() but with this Value as 'this' */
	Value evalThis(std::string_view buffer, const char *filename = "<evalThis>", int flags = 0) {
		assert(buffer.data()[buffer.size()] == '\0' && "eval buffer is not null-terminated"); // JS_Eval requirement
		assert(ctx);
		return Value{ ctx, JS_EvalThis(ctx, v, buffer.data(), buffer.size(), filename, flags) };
	}
};

/** Thin wrapper over JSRuntime * rt
 * Calls JS_FreeRuntime on destruction. noncopyable.
 */
class Runtime {
public:
	JSRuntime *rt;

	Runtime() {
		rt = JS_NewRuntime();
		if (!rt)
			throw std::runtime_error{ "qjs: Cannot create runtime" };

		JS_SetHostPromiseRejectionTracker(rt, promise_unhandled_rejection_tracker, NULL);
		JS_SetModuleLoaderFunc(rt, nullptr, module_loader, nullptr);
	}

	// noncopyable
	Runtime(const Runtime &) = delete;

	~Runtime() {
		JS_FreeRuntime(rt);
	}

	/// @return pointer to qjs::Context of the executed job or nullptr if no job is pending
	Context *executePendingJob();

	bool isJobPending() const {
		return JS_IsJobPending(rt);
	}

private:
	static void promise_unhandled_rejection_tracker(JSContext *ctx, JSValueConst promise,
			JSValueConst reason, JS_BOOL is_handled, void *opaque);

	static JSModuleDef *module_loader(JSContext *ctx,
			const char *module_name, void *opaque);
};

namespace detail {

inline std::optional<std::string> readFile(std::filesystem::path const &filepath) {
	if (!std::filesystem::exists(filepath))
		return std::nullopt;
	std::ifstream f(filepath, std::ios::in | std::ios::binary);
	if (!f.is_open())
		return std::nullopt;
	std::stringstream sstream;
	sstream << f.rdbuf();
	return sstream.str();
}

inline std::string toUri(std::string_view filename) {
	auto fname = std::string{ filename };
	if (fname.find("://") < fname.find("/"))
		return fname;

	auto fpath = std::filesystem::path(fname);
	if (!fpath.is_absolute()) {
		fpath = "." / fpath;
	}
	fpath = std::filesystem::weakly_canonical(fpath);
	fname = "file://" + fpath.generic_string();
	return fname;
}

} //namespace detail

/** Wrapper over JSContext * ctx
 * Calls JS_SetContextOpaque(ctx, this); on construction and JS_FreeContext on destruction
 */
class Context {
public:
	JSContext *ctx;

	/** Module wrapper
	 * Workaround for lack of opaque pointer for module load function by keeping a list of modules in qjs::Context.
	 */
	class Module {
		friend class Context;

		JSModuleDef *m;
		JSContext *ctx;
		const char *name;

		using nvp = std::pair<const char *, Value>;
		std::vector<nvp> exports;

	public:
		Module(JSContext *ctx, const char *name) :
				ctx(ctx), name(name) {
			m = JS_NewCModule(ctx, name, [](JSContext *ctx, JSModuleDef *m) noexcept {
                auto& context = Context::get(ctx);
                auto it = std::find_if(context.modules.begin(), context.modules.end(),
                                       [m](const Module& module) { return module.m == m; });
                if(it == context.modules.end())
                    return -1;
                for(const auto& e : it->exports)
                {
                    if(JS_SetModuleExport(ctx, m, e.first, JS_DupValue(ctx, e.second.v)) != 0)
                        return -1;
                }
                return 0; });
			if (!m)
				throw exception{ ctx };
		}

		Module &add(const char *name, JSValue &&value) {
			exports.push_back({ name, { ctx, std::move(value) } });
			JS_AddModuleExport(ctx, m, name);
			return *this;
		}

		template <typename T>
		Module &add(const char *name, T &&value) {
			return add(name, js_traits<T>::wrap(ctx, std::forward<T>(value)));
		}

		Module(const Module &) = delete;

		Module(Module &&) = default;
		// Module& operator=(Module&&) = default;

		// function wrappers

		/** Add free function F.
		 * Example:
		 * module.function<static_cast<double (*)(double)>(&::sin)>("sin");
		 */
		template <auto F>
		Module &function(const char *name) {
			return add(name, qjs::fwrapper<F>{ name });
		}

		/** Add function object f.
		 * Slower than template version.
		 * Example: module.function("sin", [](double x) { return ::sin(x); });
		 */
		template <typename F>
		Module &function(const char *name, F &&f) {
			return add(name, js_traits<decltype(std::function{ std::forward<F>(f) })>::wrap(ctx, std::forward<F>(f)));
		}

		// class register wrapper
	private:
		/** Helper class to register class members and constructors.
		 * See fun, constructor.
		 * Actual registration occurs at object destruction.
		 */
		template <class T>
		class class_registrar {
			const char *name;
			qjs::Value prototype;
			qjs::Context::Module &module;
			qjs::Context &context;
			qjs::Value ctor; // last added constructor
		public:
			explicit class_registrar(const char *name, qjs::Context::Module &module, qjs::Context &context) :
					name(name),
					prototype(context.newObject()),
					module(module),
					context(context),
					ctor(JS_NULL) {
			}

			class_registrar(const class_registrar &) = delete;

			/** Add functional object f
			 */
			template <typename F>
			class_registrar &fun(const char *name, F &&f) {
				prototype[name] = std::forward<F>(f);
				return *this;
			}

			/** Add class member function or class member variable F
			 * Example:
			 * struct T { int var; int func(); }
			 * auto& module = context.addModule("module");
			 * module.class_<T>("T").fun<&T::var>("var").fun<&T::func>("func");
			 */
			template <auto F>
			class_registrar &fun(const char *name) {
				js_traits<std::shared_ptr<T>>::template ensureCanCastToBase<F>();
				prototype.add<F>(name);
				return *this;
			}

			/** Add a static member or function to the last added constructor.
			 * Example:
			 *  struct T { static int var; static int func(); }
			 *  module.class_<T>("T").contructor<>("T").static_fun<&T::var>("var").static_fun<&T::func>("func");
			 */
			template <auto F>
			class_registrar &static_fun(const char *name) {
				assert(!JS_IsNull(ctor.v) && "You should call .constructor before .static_fun");
				js_traits<qjs::shared_ptr<T>>::template ensureCanCastToBase<F>();
				ctor.add<F>(name);
				return *this;
			}

			/** Add a property with custom getter and setter.
			 * Example:
			 * module.class_<T>("T").property<&T::getX, &T::setX>("x");
			 */
			template <auto FGet, auto FSet = nullptr>
			class_registrar &property(const char *name) {
				js_traits<std::shared_ptr<T>>::template ensureCanCastToBase<FGet>();
				js_traits<std::shared_ptr<T>>::template ensureCanCastToBase<FSet>();
				if constexpr (std::is_same_v<decltype(FSet), std::nullptr_t>)
					prototype.add_getter<FGet>(name);
				else
					prototype.add_getter_setter<FGet, FSet>(name);
				return *this;
			}

			/** Add class constructor
			 * @tparam Args contructor arguments
			 * @param name constructor name (if not specified class name will be used)
			 */
			template <typename... Args>
			class_registrar &constructor(const char *name = nullptr) {
				if (!name)
					name = this->name;
				ctor = context.newValue(qjs::ctor_wrapper<T, Args...>{ name });
				JS_SetConstructor(context.ctx, ctor.v, prototype.v);
				module.add(name, qjs::Value{ ctor });
				return *this;
			}

			/** Sets the base class
			 * @tparam B base class
			 */
			template <class B>
			class_registrar &base() {
				static_assert(!std::is_same_v<B, T>, "Type cannot be a base of itself");
				assert(js_traits<std::shared_ptr<B>>::QJSClassId && "base class is not registered");
				js_traits<std::shared_ptr<T>>::template ensureCanCastToBase<B>();
				auto base_proto = JS_GetClassProto(context.ctx, js_traits<std::shared_ptr<B>>::QJSClassId);
				int err = JS_SetPrototype(context.ctx, prototype.v, base_proto);
				JS_FreeValue(context.ctx, base_proto);
				if (err < 0)
					throw exception{ context.ctx };
				return *this;
			}

			/** All qjs::Value members of T should be marked by mark<> for QuickJS garbage collector
			 * so that the cycle removal algorithm can find the other objects referenced by this object.
			 */
			template <Value T::*V>
			class_registrar &mark() {
				js_traits<std::shared_ptr<T>>::markOffsets.push_back(V);
				return *this;
			}

			~class_registrar() {
				context.registerClass<T>(name, std::move(prototype));
			}
		};

	public:
		/** Add class to module.
		 * See \ref class_registrar.
		 */
		template <class T>
		class_registrar<T> class_(const char *name) {
			return class_registrar<T>{ name, *this, qjs::Context::get(ctx) };
		}
	};

	std::vector<Module> modules;

private:
	void init() {
		JS_SetContextOpaque(ctx, this);
		js_traits<detail::function>::register_class(ctx, "C++ function");
	}

public:
	Context(Runtime &rt) :
			Context(rt.rt) {}

	Context(JSRuntime *rt) {
		ctx = JS_NewContext(rt);
		if (!ctx)
			throw std::runtime_error{ "qjs: Cannot create context" };
		init();
	}

	Context(JSContext *ctx) :
			ctx{ ctx } {
		init();
	}

	// noncopyable
	Context(const Context &) = delete;

	~Context() {
		modules.clear();
		JS_FreeContext(ctx);
	}

	/** Callback triggered when a Promise rejection won't ever be handled */
	std::function<void(Value)> onUnhandledPromiseRejection;

	/** Data type returned by the moduleLoader function */
	struct ModuleData {
		std::optional<std::string> source, url;
		ModuleData() :
				source(std::nullopt), url(std::nullopt) {}
		ModuleData(std::optional<std::string> source) :
				source(std::move(source)), url(std::nullopt) {}
		ModuleData(std::optional<std::string> url, std::optional<std::string> source) :
				source(std::move(source)), url(std::move(url)) {}
	};

	/** Function called to obtain the source of a module */
	std::function<ModuleData(std::string_view)> moduleLoader =
			[](std::string_view filename) -> ModuleData {
		return ModuleData{ detail::toUri(filename), detail::readFile(filename) };
	};

	template <typename Function>
	void enqueueJob(Function &&job);

	/** Create module and return a reference to it */
	Module &addModule(const char *name) {
		modules.emplace_back(ctx, name);
		return modules.back();
	}

	/** returns globalThis */
	Value global() { return Value{ ctx, JS_GetGlobalObject(ctx) }; }

	/** returns new Object() */
	Value newObject() { return Value{ ctx, JS_NewObject(ctx) }; }

	/** returns JS value converted from c++ object val */
	template <typename T>
	Value newValue(T &&val) { return Value{ ctx, std::forward<T>(val) }; }

	/** returns current exception associated with context and clears it. Should be called when qjs::exception is caught */
	Value getException() { return Value{ ctx, JS_GetException(ctx) }; }

	/** Register class T for conversions to/from std::shared_ptr<T> to work.
	 * Wherever possible module.class_<T>("T")... should be used instead.
	 * @tparam T class type
	 * @param name class name in JS engine
	 * @param proto JS class prototype or JS_UNDEFINED
	 */
	template <class T>
	void registerClass(const char *name, JSValue proto = JS_NULL) {
		js_traits<std::shared_ptr<T>>::register_class(ctx, name, proto);
	}

	/// @see JS_Eval
	Value eval(std::string_view buffer, const char *filename = "<eval>", int flags = 0) {
		assert(buffer.data()[buffer.size()] == '\0' && "eval buffer is not null-terminated"); // JS_Eval requirement
		JSValue v = JS_Eval(ctx, buffer.data(), buffer.size(), filename, flags);
		return Value{ ctx, std::move(v) };
	}

	Value evalFile(const char *filename, int flags = 0) {
		auto buf = detail::readFile(filename);
		if (!buf)
			throw std::runtime_error{ std::string{ "evalFile: can't read file: " } + filename };
		return eval(*buf, filename, flags);
	}

	/// @see JS_ParseJSON2
	Value fromJSON(std::string_view buffer, const char *filename = "<fromJSON>", int flags = 0) {
		assert(buffer.data()[buffer.size()] == '\0' &&
				"fromJSON buffer is not null-terminated"); // JS_ParseJSON requirement
		return Value{ ctx, JS_ParseJSON2(ctx, buffer.data(), buffer.size(), filename, flags) };
	}

	/** Get qjs::Context from JSContext opaque pointer */
	static Context &get(JSContext *ctx) {
		void *ptr = JS_GetContextOpaque(ctx);
		assert(ptr);
		return *static_cast<Context *>(ptr);
	}
};

template <>
struct js_traits<godot::AudioFrame> {
	/// @throws exception
	static godot::AudioFrame unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioFrame *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioFrame rid) noexcept {
		return Value{ ctx, std::forward<godot::AudioFrame>(rid) };
	}
};
template <>
struct js_traits<godot::CaretInfo> {
	/// @throws exception
	static godot::CaretInfo unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CaretInfo *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CaretInfo rid) noexcept {
		return Value{ ctx, std::forward<godot::CaretInfo>(rid) };
	}
};
template <>
struct js_traits<godot::Glyph> {
	/// @throws exception
	static godot::Glyph unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Glyph *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Glyph rid) noexcept {
		return Value{ ctx, std::forward<godot::Glyph>(rid) };
	}
};
template <>
struct js_traits<godot::ObjectID> {
	/// @throws exception
	static godot::ObjectID unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ObjectID *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ObjectID rid) noexcept {
		return Value{ ctx, std::forward<godot::ObjectID>(rid) };
	}
};
template <>
struct js_traits<godot::PhysicsServer2DExtensionMotionResult> {
	/// @throws exception
	static godot::PhysicsServer2DExtensionMotionResult unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsServer2DExtensionMotionResult *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsServer2DExtensionMotionResult rid) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsServer2DExtensionMotionResult>(rid) };
	}
};
template <>
struct js_traits<godot::PhysicsServer2DExtensionRayResult> {
	/// @throws exception
	static godot::PhysicsServer2DExtensionRayResult unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsServer2DExtensionRayResult *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsServer2DExtensionRayResult rid) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsServer2DExtensionRayResult>(rid) };
	}
};
template <>
struct js_traits<godot::PhysicsServer2DExtensionShapeRestInfo> {
	/// @throws exception
	static godot::PhysicsServer2DExtensionShapeRestInfo unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsServer2DExtensionShapeRestInfo *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsServer2DExtensionShapeRestInfo rid) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsServer2DExtensionShapeRestInfo>(rid) };
	}
};
template <>
struct js_traits<godot::PhysicsServer2DExtensionShapeResult> {
	/// @throws exception
	static godot::PhysicsServer2DExtensionShapeResult unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsServer2DExtensionShapeResult *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsServer2DExtensionShapeResult rid) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsServer2DExtensionShapeResult>(rid) };
	}
};
template <>
struct js_traits<godot::PhysicsServer3DExtensionMotionCollision> {
	/// @throws exception
	static godot::PhysicsServer3DExtensionMotionCollision unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsServer3DExtensionMotionCollision *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsServer3DExtensionMotionCollision rid) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsServer3DExtensionMotionCollision>(rid) };
	}
};
template <>
struct js_traits<godot::PhysicsServer3DExtensionMotionResult> {
	/// @throws exception
	static godot::PhysicsServer3DExtensionMotionResult unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsServer3DExtensionMotionResult *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsServer3DExtensionMotionResult rid) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsServer3DExtensionMotionResult>(rid) };
	}
};
template <>
struct js_traits<godot::PhysicsServer3DExtensionRayResult> {
	/// @throws exception
	static godot::PhysicsServer3DExtensionRayResult unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsServer3DExtensionRayResult *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsServer3DExtensionRayResult rid) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsServer3DExtensionRayResult>(rid) };
	}
};
template <>
struct js_traits<godot::PhysicsServer3DExtensionShapeRestInfo> {
	/// @throws exception
	static godot::PhysicsServer3DExtensionShapeRestInfo unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsServer3DExtensionShapeRestInfo *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsServer3DExtensionShapeRestInfo rid) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsServer3DExtensionShapeRestInfo>(rid) };
	}
};
template <>
struct js_traits<godot::PhysicsServer3DExtensionShapeResult> {
	/// @throws exception
	static godot::PhysicsServer3DExtensionShapeResult unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsServer3DExtensionShapeResult *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsServer3DExtensionShapeResult rid) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsServer3DExtensionShapeResult>(rid) };
	}
};
template <>
struct js_traits<godot::ScriptLanguageExtensionProfilingInfo> {
	/// @throws exception
	static godot::ScriptLanguageExtensionProfilingInfo unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ScriptLanguageExtensionProfilingInfo *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ScriptLanguageExtensionProfilingInfo rid) noexcept {
		return Value{ ctx, std::forward<godot::ScriptLanguageExtensionProfilingInfo>(rid) };
	}
};

template <>
struct js_traits<godot::AESContext> {
	/// @throws exception
	static godot::AESContext unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AESContext *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AESContext v) noexcept {
		return Value{ ctx, std::forward<godot::AESContext>(v) };
	}
};
template <>
struct js_traits<godot::AESContext &> {
	/// @throws exception
	static godot::AESContext &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AESContext *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AESContext &v) noexcept {
		return Value{ ctx, std::forward<godot::AESContext>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AESContext>> {
	/// @throws exception
	static godot::Ref<godot::AESContext> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AESContext>((godot::AESContext *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AESContext> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AESContext>>(v) };
	}
};
template <>
struct js_traits<godot::AStar2D> {
	/// @throws exception
	static godot::AStar2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AStar2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AStar2D v) noexcept {
		return Value{ ctx, std::forward<godot::AStar2D>(v) };
	}
};
template <>
struct js_traits<godot::AStar2D &> {
	/// @throws exception
	static godot::AStar2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AStar2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AStar2D &v) noexcept {
		return Value{ ctx, std::forward<godot::AStar2D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AStar2D>> {
	/// @throws exception
	static godot::Ref<godot::AStar2D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AStar2D>((godot::AStar2D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AStar2D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AStar2D>>(v) };
	}
};
template <>
struct js_traits<godot::AStar3D> {
	/// @throws exception
	static godot::AStar3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AStar3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AStar3D v) noexcept {
		return Value{ ctx, std::forward<godot::AStar3D>(v) };
	}
};
template <>
struct js_traits<godot::AStar3D &> {
	/// @throws exception
	static godot::AStar3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AStar3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AStar3D &v) noexcept {
		return Value{ ctx, std::forward<godot::AStar3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AStar3D>> {
	/// @throws exception
	static godot::Ref<godot::AStar3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AStar3D>((godot::AStar3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AStar3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AStar3D>>(v) };
	}
};
template <>
struct js_traits<godot::AStarGrid2D> {
	/// @throws exception
	static godot::AStarGrid2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AStarGrid2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AStarGrid2D v) noexcept {
		return Value{ ctx, std::forward<godot::AStarGrid2D>(v) };
	}
};
template <>
struct js_traits<godot::AStarGrid2D &> {
	/// @throws exception
	static godot::AStarGrid2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AStarGrid2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AStarGrid2D &v) noexcept {
		return Value{ ctx, std::forward<godot::AStarGrid2D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AStarGrid2D>> {
	/// @throws exception
	static godot::Ref<godot::AStarGrid2D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AStarGrid2D>((godot::AStarGrid2D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AStarGrid2D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AStarGrid2D>>(v) };
	}
};
template <>
struct js_traits<godot::AcceptDialog> {
	/// @throws exception
	static godot::AcceptDialog unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AcceptDialog *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AcceptDialog v) noexcept {
		return Value{ ctx, std::forward<godot::AcceptDialog>(v) };
	}
};
template <>
struct js_traits<godot::AcceptDialog &> {
	/// @throws exception
	static godot::AcceptDialog &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AcceptDialog *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AcceptDialog &v) noexcept {
		return Value{ ctx, std::forward<godot::AcceptDialog>(v) };
	}
};
template <>
struct js_traits<godot::AnimatableBody2D> {
	/// @throws exception
	static godot::AnimatableBody2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimatableBody2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimatableBody2D v) noexcept {
		return Value{ ctx, std::forward<godot::AnimatableBody2D>(v) };
	}
};
template <>
struct js_traits<godot::AnimatableBody2D &> {
	/// @throws exception
	static godot::AnimatableBody2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimatableBody2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimatableBody2D &v) noexcept {
		return Value{ ctx, std::forward<godot::AnimatableBody2D>(v) };
	}
};
template <>
struct js_traits<godot::AnimatableBody3D> {
	/// @throws exception
	static godot::AnimatableBody3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimatableBody3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimatableBody3D v) noexcept {
		return Value{ ctx, std::forward<godot::AnimatableBody3D>(v) };
	}
};
template <>
struct js_traits<godot::AnimatableBody3D &> {
	/// @throws exception
	static godot::AnimatableBody3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimatableBody3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimatableBody3D &v) noexcept {
		return Value{ ctx, std::forward<godot::AnimatableBody3D>(v) };
	}
};
template <>
struct js_traits<godot::AnimatedSprite2D> {
	/// @throws exception
	static godot::AnimatedSprite2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimatedSprite2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimatedSprite2D v) noexcept {
		return Value{ ctx, std::forward<godot::AnimatedSprite2D>(v) };
	}
};
template <>
struct js_traits<godot::AnimatedSprite2D &> {
	/// @throws exception
	static godot::AnimatedSprite2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimatedSprite2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimatedSprite2D &v) noexcept {
		return Value{ ctx, std::forward<godot::AnimatedSprite2D>(v) };
	}
};
template <>
struct js_traits<godot::AnimatedSprite3D> {
	/// @throws exception
	static godot::AnimatedSprite3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimatedSprite3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimatedSprite3D v) noexcept {
		return Value{ ctx, std::forward<godot::AnimatedSprite3D>(v) };
	}
};
template <>
struct js_traits<godot::AnimatedSprite3D &> {
	/// @throws exception
	static godot::AnimatedSprite3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimatedSprite3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimatedSprite3D &v) noexcept {
		return Value{ ctx, std::forward<godot::AnimatedSprite3D>(v) };
	}
};
template <>
struct js_traits<godot::AnimatedTexture> {
	/// @throws exception
	static godot::AnimatedTexture unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimatedTexture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimatedTexture v) noexcept {
		return Value{ ctx, std::forward<godot::AnimatedTexture>(v) };
	}
};
template <>
struct js_traits<godot::AnimatedTexture &> {
	/// @throws exception
	static godot::AnimatedTexture &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimatedTexture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimatedTexture &v) noexcept {
		return Value{ ctx, std::forward<godot::AnimatedTexture>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AnimatedTexture>> {
	/// @throws exception
	static godot::Ref<godot::AnimatedTexture> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AnimatedTexture>((godot::AnimatedTexture *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AnimatedTexture> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AnimatedTexture>>(v) };
	}
};
template <>
struct js_traits<godot::Animation> {
	/// @throws exception
	static godot::Animation unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Animation *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Animation v) noexcept {
		return Value{ ctx, std::forward<godot::Animation>(v) };
	}
};
template <>
struct js_traits<godot::Animation &> {
	/// @throws exception
	static godot::Animation &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Animation *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Animation &v) noexcept {
		return Value{ ctx, std::forward<godot::Animation>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Animation>> {
	/// @throws exception
	static godot::Ref<godot::Animation> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Animation>((godot::Animation *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Animation> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Animation>>(v) };
	}
};
template <>
struct js_traits<godot::AnimationLibrary> {
	/// @throws exception
	static godot::AnimationLibrary unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationLibrary *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationLibrary v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationLibrary>(v) };
	}
};
template <>
struct js_traits<godot::AnimationLibrary &> {
	/// @throws exception
	static godot::AnimationLibrary &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationLibrary *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationLibrary &v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationLibrary>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AnimationLibrary>> {
	/// @throws exception
	static godot::Ref<godot::AnimationLibrary> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AnimationLibrary>((godot::AnimationLibrary *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AnimationLibrary> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AnimationLibrary>>(v) };
	}
};
template <>
struct js_traits<godot::AnimationMixer> {
	/// @throws exception
	static godot::AnimationMixer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationMixer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationMixer v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationMixer>(v) };
	}
};
template <>
struct js_traits<godot::AnimationMixer &> {
	/// @throws exception
	static godot::AnimationMixer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationMixer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationMixer &v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationMixer>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNode> {
	/// @throws exception
	static godot::AnimationNode unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNode *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNode v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNode>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNode &> {
	/// @throws exception
	static godot::AnimationNode &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNode *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNode &v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNode>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AnimationNode>> {
	/// @throws exception
	static godot::Ref<godot::AnimationNode> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AnimationNode>((godot::AnimationNode *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AnimationNode> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AnimationNode>>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeAdd2> {
	/// @throws exception
	static godot::AnimationNodeAdd2 unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeAdd2 *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeAdd2 v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeAdd2>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeAdd2 &> {
	/// @throws exception
	static godot::AnimationNodeAdd2 &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeAdd2 *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeAdd2 &v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeAdd2>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AnimationNodeAdd2>> {
	/// @throws exception
	static godot::Ref<godot::AnimationNodeAdd2> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AnimationNodeAdd2>((godot::AnimationNodeAdd2 *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AnimationNodeAdd2> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AnimationNodeAdd2>>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeAdd3> {
	/// @throws exception
	static godot::AnimationNodeAdd3 unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeAdd3 *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeAdd3 v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeAdd3>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeAdd3 &> {
	/// @throws exception
	static godot::AnimationNodeAdd3 &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeAdd3 *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeAdd3 &v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeAdd3>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AnimationNodeAdd3>> {
	/// @throws exception
	static godot::Ref<godot::AnimationNodeAdd3> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AnimationNodeAdd3>((godot::AnimationNodeAdd3 *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AnimationNodeAdd3> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AnimationNodeAdd3>>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeAnimation> {
	/// @throws exception
	static godot::AnimationNodeAnimation unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeAnimation *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeAnimation v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeAnimation>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeAnimation &> {
	/// @throws exception
	static godot::AnimationNodeAnimation &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeAnimation *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeAnimation &v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeAnimation>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AnimationNodeAnimation>> {
	/// @throws exception
	static godot::Ref<godot::AnimationNodeAnimation> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AnimationNodeAnimation>((godot::AnimationNodeAnimation *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AnimationNodeAnimation> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AnimationNodeAnimation>>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeBlend2> {
	/// @throws exception
	static godot::AnimationNodeBlend2 unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeBlend2 *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeBlend2 v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeBlend2>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeBlend2 &> {
	/// @throws exception
	static godot::AnimationNodeBlend2 &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeBlend2 *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeBlend2 &v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeBlend2>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AnimationNodeBlend2>> {
	/// @throws exception
	static godot::Ref<godot::AnimationNodeBlend2> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AnimationNodeBlend2>((godot::AnimationNodeBlend2 *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AnimationNodeBlend2> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AnimationNodeBlend2>>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeBlend3> {
	/// @throws exception
	static godot::AnimationNodeBlend3 unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeBlend3 *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeBlend3 v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeBlend3>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeBlend3 &> {
	/// @throws exception
	static godot::AnimationNodeBlend3 &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeBlend3 *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeBlend3 &v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeBlend3>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AnimationNodeBlend3>> {
	/// @throws exception
	static godot::Ref<godot::AnimationNodeBlend3> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AnimationNodeBlend3>((godot::AnimationNodeBlend3 *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AnimationNodeBlend3> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AnimationNodeBlend3>>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeBlendSpace1D> {
	/// @throws exception
	static godot::AnimationNodeBlendSpace1D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeBlendSpace1D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeBlendSpace1D v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeBlendSpace1D>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeBlendSpace1D &> {
	/// @throws exception
	static godot::AnimationNodeBlendSpace1D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeBlendSpace1D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeBlendSpace1D &v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeBlendSpace1D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AnimationNodeBlendSpace1D>> {
	/// @throws exception
	static godot::Ref<godot::AnimationNodeBlendSpace1D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AnimationNodeBlendSpace1D>((godot::AnimationNodeBlendSpace1D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AnimationNodeBlendSpace1D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AnimationNodeBlendSpace1D>>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeBlendSpace2D> {
	/// @throws exception
	static godot::AnimationNodeBlendSpace2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeBlendSpace2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeBlendSpace2D v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeBlendSpace2D>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeBlendSpace2D &> {
	/// @throws exception
	static godot::AnimationNodeBlendSpace2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeBlendSpace2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeBlendSpace2D &v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeBlendSpace2D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AnimationNodeBlendSpace2D>> {
	/// @throws exception
	static godot::Ref<godot::AnimationNodeBlendSpace2D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AnimationNodeBlendSpace2D>((godot::AnimationNodeBlendSpace2D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AnimationNodeBlendSpace2D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AnimationNodeBlendSpace2D>>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeBlendTree> {
	/// @throws exception
	static godot::AnimationNodeBlendTree unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeBlendTree *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeBlendTree v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeBlendTree>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeBlendTree &> {
	/// @throws exception
	static godot::AnimationNodeBlendTree &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeBlendTree *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeBlendTree &v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeBlendTree>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AnimationNodeBlendTree>> {
	/// @throws exception
	static godot::Ref<godot::AnimationNodeBlendTree> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AnimationNodeBlendTree>((godot::AnimationNodeBlendTree *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AnimationNodeBlendTree> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AnimationNodeBlendTree>>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeOneShot> {
	/// @throws exception
	static godot::AnimationNodeOneShot unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeOneShot *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeOneShot v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeOneShot>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeOneShot &> {
	/// @throws exception
	static godot::AnimationNodeOneShot &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeOneShot *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeOneShot &v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeOneShot>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AnimationNodeOneShot>> {
	/// @throws exception
	static godot::Ref<godot::AnimationNodeOneShot> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AnimationNodeOneShot>((godot::AnimationNodeOneShot *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AnimationNodeOneShot> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AnimationNodeOneShot>>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeOutput> {
	/// @throws exception
	static godot::AnimationNodeOutput unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeOutput *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeOutput v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeOutput>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeOutput &> {
	/// @throws exception
	static godot::AnimationNodeOutput &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeOutput *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeOutput &v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeOutput>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AnimationNodeOutput>> {
	/// @throws exception
	static godot::Ref<godot::AnimationNodeOutput> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AnimationNodeOutput>((godot::AnimationNodeOutput *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AnimationNodeOutput> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AnimationNodeOutput>>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeStateMachine> {
	/// @throws exception
	static godot::AnimationNodeStateMachine unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeStateMachine *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeStateMachine v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeStateMachine>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeStateMachine &> {
	/// @throws exception
	static godot::AnimationNodeStateMachine &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeStateMachine *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeStateMachine &v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeStateMachine>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AnimationNodeStateMachine>> {
	/// @throws exception
	static godot::Ref<godot::AnimationNodeStateMachine> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AnimationNodeStateMachine>((godot::AnimationNodeStateMachine *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AnimationNodeStateMachine> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AnimationNodeStateMachine>>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeStateMachinePlayback> {
	/// @throws exception
	static godot::AnimationNodeStateMachinePlayback unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeStateMachinePlayback *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeStateMachinePlayback v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeStateMachinePlayback>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeStateMachinePlayback &> {
	/// @throws exception
	static godot::AnimationNodeStateMachinePlayback &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeStateMachinePlayback *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeStateMachinePlayback &v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeStateMachinePlayback>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AnimationNodeStateMachinePlayback>> {
	/// @throws exception
	static godot::Ref<godot::AnimationNodeStateMachinePlayback> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AnimationNodeStateMachinePlayback>((godot::AnimationNodeStateMachinePlayback *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AnimationNodeStateMachinePlayback> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AnimationNodeStateMachinePlayback>>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeStateMachineTransition> {
	/// @throws exception
	static godot::AnimationNodeStateMachineTransition unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeStateMachineTransition *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeStateMachineTransition v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeStateMachineTransition>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeStateMachineTransition &> {
	/// @throws exception
	static godot::AnimationNodeStateMachineTransition &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeStateMachineTransition *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeStateMachineTransition &v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeStateMachineTransition>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AnimationNodeStateMachineTransition>> {
	/// @throws exception
	static godot::Ref<godot::AnimationNodeStateMachineTransition> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AnimationNodeStateMachineTransition>((godot::AnimationNodeStateMachineTransition *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AnimationNodeStateMachineTransition> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AnimationNodeStateMachineTransition>>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeSub2> {
	/// @throws exception
	static godot::AnimationNodeSub2 unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeSub2 *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeSub2 v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeSub2>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeSub2 &> {
	/// @throws exception
	static godot::AnimationNodeSub2 &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeSub2 *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeSub2 &v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeSub2>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AnimationNodeSub2>> {
	/// @throws exception
	static godot::Ref<godot::AnimationNodeSub2> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AnimationNodeSub2>((godot::AnimationNodeSub2 *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AnimationNodeSub2> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AnimationNodeSub2>>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeSync> {
	/// @throws exception
	static godot::AnimationNodeSync unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeSync *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeSync v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeSync>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeSync &> {
	/// @throws exception
	static godot::AnimationNodeSync &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeSync *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeSync &v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeSync>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AnimationNodeSync>> {
	/// @throws exception
	static godot::Ref<godot::AnimationNodeSync> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AnimationNodeSync>((godot::AnimationNodeSync *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AnimationNodeSync> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AnimationNodeSync>>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeTimeScale> {
	/// @throws exception
	static godot::AnimationNodeTimeScale unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeTimeScale *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeTimeScale v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeTimeScale>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeTimeScale &> {
	/// @throws exception
	static godot::AnimationNodeTimeScale &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeTimeScale *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeTimeScale &v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeTimeScale>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AnimationNodeTimeScale>> {
	/// @throws exception
	static godot::Ref<godot::AnimationNodeTimeScale> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AnimationNodeTimeScale>((godot::AnimationNodeTimeScale *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AnimationNodeTimeScale> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AnimationNodeTimeScale>>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeTimeSeek> {
	/// @throws exception
	static godot::AnimationNodeTimeSeek unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeTimeSeek *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeTimeSeek v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeTimeSeek>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeTimeSeek &> {
	/// @throws exception
	static godot::AnimationNodeTimeSeek &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeTimeSeek *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeTimeSeek &v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeTimeSeek>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AnimationNodeTimeSeek>> {
	/// @throws exception
	static godot::Ref<godot::AnimationNodeTimeSeek> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AnimationNodeTimeSeek>((godot::AnimationNodeTimeSeek *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AnimationNodeTimeSeek> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AnimationNodeTimeSeek>>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeTransition> {
	/// @throws exception
	static godot::AnimationNodeTransition unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeTransition *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeTransition v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeTransition>(v) };
	}
};
template <>
struct js_traits<godot::AnimationNodeTransition &> {
	/// @throws exception
	static godot::AnimationNodeTransition &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationNodeTransition *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationNodeTransition &v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationNodeTransition>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AnimationNodeTransition>> {
	/// @throws exception
	static godot::Ref<godot::AnimationNodeTransition> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AnimationNodeTransition>((godot::AnimationNodeTransition *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AnimationNodeTransition> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AnimationNodeTransition>>(v) };
	}
};
template <>
struct js_traits<godot::AnimationPlayer> {
	/// @throws exception
	static godot::AnimationPlayer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationPlayer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationPlayer v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationPlayer>(v) };
	}
};
template <>
struct js_traits<godot::AnimationPlayer &> {
	/// @throws exception
	static godot::AnimationPlayer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationPlayer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationPlayer &v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationPlayer>(v) };
	}
};
template <>
struct js_traits<godot::AnimationRootNode> {
	/// @throws exception
	static godot::AnimationRootNode unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationRootNode *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationRootNode v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationRootNode>(v) };
	}
};
template <>
struct js_traits<godot::AnimationRootNode &> {
	/// @throws exception
	static godot::AnimationRootNode &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationRootNode *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationRootNode &v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationRootNode>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AnimationRootNode>> {
	/// @throws exception
	static godot::Ref<godot::AnimationRootNode> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AnimationRootNode>((godot::AnimationRootNode *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AnimationRootNode> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AnimationRootNode>>(v) };
	}
};
template <>
struct js_traits<godot::AnimationTree> {
	/// @throws exception
	static godot::AnimationTree unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationTree *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationTree v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationTree>(v) };
	}
};
template <>
struct js_traits<godot::AnimationTree &> {
	/// @throws exception
	static godot::AnimationTree &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AnimationTree *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AnimationTree &v) noexcept {
		return Value{ ctx, std::forward<godot::AnimationTree>(v) };
	}
};
template <>
struct js_traits<godot::Area2D> {
	/// @throws exception
	static godot::Area2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Area2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Area2D v) noexcept {
		return Value{ ctx, std::forward<godot::Area2D>(v) };
	}
};
template <>
struct js_traits<godot::Area2D &> {
	/// @throws exception
	static godot::Area2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Area2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Area2D &v) noexcept {
		return Value{ ctx, std::forward<godot::Area2D>(v) };
	}
};
template <>
struct js_traits<godot::Area3D> {
	/// @throws exception
	static godot::Area3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Area3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Area3D v) noexcept {
		return Value{ ctx, std::forward<godot::Area3D>(v) };
	}
};
template <>
struct js_traits<godot::Area3D &> {
	/// @throws exception
	static godot::Area3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Area3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Area3D &v) noexcept {
		return Value{ ctx, std::forward<godot::Area3D>(v) };
	}
};
template <>
struct js_traits<godot::ArrayMesh> {
	/// @throws exception
	static godot::ArrayMesh unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ArrayMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ArrayMesh v) noexcept {
		return Value{ ctx, std::forward<godot::ArrayMesh>(v) };
	}
};
template <>
struct js_traits<godot::ArrayMesh &> {
	/// @throws exception
	static godot::ArrayMesh &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ArrayMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ArrayMesh &v) noexcept {
		return Value{ ctx, std::forward<godot::ArrayMesh>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ArrayMesh>> {
	/// @throws exception
	static godot::Ref<godot::ArrayMesh> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ArrayMesh>((godot::ArrayMesh *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ArrayMesh> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ArrayMesh>>(v) };
	}
};
template <>
struct js_traits<godot::ArrayOccluder3D> {
	/// @throws exception
	static godot::ArrayOccluder3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ArrayOccluder3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ArrayOccluder3D v) noexcept {
		return Value{ ctx, std::forward<godot::ArrayOccluder3D>(v) };
	}
};
template <>
struct js_traits<godot::ArrayOccluder3D &> {
	/// @throws exception
	static godot::ArrayOccluder3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ArrayOccluder3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ArrayOccluder3D &v) noexcept {
		return Value{ ctx, std::forward<godot::ArrayOccluder3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ArrayOccluder3D>> {
	/// @throws exception
	static godot::Ref<godot::ArrayOccluder3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ArrayOccluder3D>((godot::ArrayOccluder3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ArrayOccluder3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ArrayOccluder3D>>(v) };
	}
};
template <>
struct js_traits<godot::AspectRatioContainer> {
	/// @throws exception
	static godot::AspectRatioContainer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AspectRatioContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AspectRatioContainer v) noexcept {
		return Value{ ctx, std::forward<godot::AspectRatioContainer>(v) };
	}
};
template <>
struct js_traits<godot::AspectRatioContainer &> {
	/// @throws exception
	static godot::AspectRatioContainer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AspectRatioContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AspectRatioContainer &v) noexcept {
		return Value{ ctx, std::forward<godot::AspectRatioContainer>(v) };
	}
};
template <>
struct js_traits<godot::AtlasTexture> {
	/// @throws exception
	static godot::AtlasTexture unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AtlasTexture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AtlasTexture v) noexcept {
		return Value{ ctx, std::forward<godot::AtlasTexture>(v) };
	}
};
template <>
struct js_traits<godot::AtlasTexture &> {
	/// @throws exception
	static godot::AtlasTexture &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AtlasTexture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AtlasTexture &v) noexcept {
		return Value{ ctx, std::forward<godot::AtlasTexture>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AtlasTexture>> {
	/// @throws exception
	static godot::Ref<godot::AtlasTexture> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AtlasTexture>((godot::AtlasTexture *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AtlasTexture> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AtlasTexture>>(v) };
	}
};
template <>
struct js_traits<godot::AudioBusLayout> {
	/// @throws exception
	static godot::AudioBusLayout unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioBusLayout *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioBusLayout v) noexcept {
		return Value{ ctx, std::forward<godot::AudioBusLayout>(v) };
	}
};
template <>
struct js_traits<godot::AudioBusLayout &> {
	/// @throws exception
	static godot::AudioBusLayout &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioBusLayout *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioBusLayout &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioBusLayout>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioBusLayout>> {
	/// @throws exception
	static godot::Ref<godot::AudioBusLayout> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioBusLayout>((godot::AudioBusLayout *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioBusLayout> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioBusLayout>>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffect> {
	/// @throws exception
	static godot::AudioEffect unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffect *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffect v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffect>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffect &> {
	/// @throws exception
	static godot::AudioEffect &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffect *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffect &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffect>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioEffect>> {
	/// @throws exception
	static godot::Ref<godot::AudioEffect> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioEffect>((godot::AudioEffect *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioEffect> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioEffect>>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectAmplify> {
	/// @throws exception
	static godot::AudioEffectAmplify unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectAmplify *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectAmplify v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectAmplify>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectAmplify &> {
	/// @throws exception
	static godot::AudioEffectAmplify &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectAmplify *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectAmplify &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectAmplify>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioEffectAmplify>> {
	/// @throws exception
	static godot::Ref<godot::AudioEffectAmplify> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioEffectAmplify>((godot::AudioEffectAmplify *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioEffectAmplify> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioEffectAmplify>>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectBandLimitFilter> {
	/// @throws exception
	static godot::AudioEffectBandLimitFilter unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectBandLimitFilter *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectBandLimitFilter v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectBandLimitFilter>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectBandLimitFilter &> {
	/// @throws exception
	static godot::AudioEffectBandLimitFilter &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectBandLimitFilter *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectBandLimitFilter &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectBandLimitFilter>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioEffectBandLimitFilter>> {
	/// @throws exception
	static godot::Ref<godot::AudioEffectBandLimitFilter> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioEffectBandLimitFilter>((godot::AudioEffectBandLimitFilter *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioEffectBandLimitFilter> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioEffectBandLimitFilter>>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectBandPassFilter> {
	/// @throws exception
	static godot::AudioEffectBandPassFilter unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectBandPassFilter *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectBandPassFilter v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectBandPassFilter>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectBandPassFilter &> {
	/// @throws exception
	static godot::AudioEffectBandPassFilter &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectBandPassFilter *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectBandPassFilter &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectBandPassFilter>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioEffectBandPassFilter>> {
	/// @throws exception
	static godot::Ref<godot::AudioEffectBandPassFilter> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioEffectBandPassFilter>((godot::AudioEffectBandPassFilter *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioEffectBandPassFilter> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioEffectBandPassFilter>>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectCapture> {
	/// @throws exception
	static godot::AudioEffectCapture unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectCapture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectCapture v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectCapture>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectCapture &> {
	/// @throws exception
	static godot::AudioEffectCapture &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectCapture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectCapture &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectCapture>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioEffectCapture>> {
	/// @throws exception
	static godot::Ref<godot::AudioEffectCapture> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioEffectCapture>((godot::AudioEffectCapture *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioEffectCapture> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioEffectCapture>>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectChorus> {
	/// @throws exception
	static godot::AudioEffectChorus unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectChorus *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectChorus v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectChorus>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectChorus &> {
	/// @throws exception
	static godot::AudioEffectChorus &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectChorus *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectChorus &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectChorus>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioEffectChorus>> {
	/// @throws exception
	static godot::Ref<godot::AudioEffectChorus> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioEffectChorus>((godot::AudioEffectChorus *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioEffectChorus> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioEffectChorus>>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectCompressor> {
	/// @throws exception
	static godot::AudioEffectCompressor unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectCompressor *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectCompressor v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectCompressor>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectCompressor &> {
	/// @throws exception
	static godot::AudioEffectCompressor &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectCompressor *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectCompressor &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectCompressor>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioEffectCompressor>> {
	/// @throws exception
	static godot::Ref<godot::AudioEffectCompressor> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioEffectCompressor>((godot::AudioEffectCompressor *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioEffectCompressor> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioEffectCompressor>>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectDelay> {
	/// @throws exception
	static godot::AudioEffectDelay unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectDelay *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectDelay v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectDelay>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectDelay &> {
	/// @throws exception
	static godot::AudioEffectDelay &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectDelay *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectDelay &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectDelay>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioEffectDelay>> {
	/// @throws exception
	static godot::Ref<godot::AudioEffectDelay> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioEffectDelay>((godot::AudioEffectDelay *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioEffectDelay> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioEffectDelay>>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectDistortion> {
	/// @throws exception
	static godot::AudioEffectDistortion unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectDistortion *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectDistortion v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectDistortion>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectDistortion &> {
	/// @throws exception
	static godot::AudioEffectDistortion &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectDistortion *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectDistortion &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectDistortion>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioEffectDistortion>> {
	/// @throws exception
	static godot::Ref<godot::AudioEffectDistortion> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioEffectDistortion>((godot::AudioEffectDistortion *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioEffectDistortion> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioEffectDistortion>>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectEQ> {
	/// @throws exception
	static godot::AudioEffectEQ unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectEQ *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectEQ v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectEQ>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectEQ &> {
	/// @throws exception
	static godot::AudioEffectEQ &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectEQ *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectEQ &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectEQ>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioEffectEQ>> {
	/// @throws exception
	static godot::Ref<godot::AudioEffectEQ> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioEffectEQ>((godot::AudioEffectEQ *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioEffectEQ> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioEffectEQ>>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectEQ10> {
	/// @throws exception
	static godot::AudioEffectEQ10 unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectEQ10 *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectEQ10 v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectEQ10>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectEQ10 &> {
	/// @throws exception
	static godot::AudioEffectEQ10 &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectEQ10 *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectEQ10 &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectEQ10>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioEffectEQ10>> {
	/// @throws exception
	static godot::Ref<godot::AudioEffectEQ10> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioEffectEQ10>((godot::AudioEffectEQ10 *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioEffectEQ10> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioEffectEQ10>>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectEQ21> {
	/// @throws exception
	static godot::AudioEffectEQ21 unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectEQ21 *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectEQ21 v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectEQ21>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectEQ21 &> {
	/// @throws exception
	static godot::AudioEffectEQ21 &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectEQ21 *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectEQ21 &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectEQ21>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioEffectEQ21>> {
	/// @throws exception
	static godot::Ref<godot::AudioEffectEQ21> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioEffectEQ21>((godot::AudioEffectEQ21 *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioEffectEQ21> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioEffectEQ21>>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectEQ6> {
	/// @throws exception
	static godot::AudioEffectEQ6 unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectEQ6 *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectEQ6 v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectEQ6>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectEQ6 &> {
	/// @throws exception
	static godot::AudioEffectEQ6 &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectEQ6 *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectEQ6 &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectEQ6>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioEffectEQ6>> {
	/// @throws exception
	static godot::Ref<godot::AudioEffectEQ6> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioEffectEQ6>((godot::AudioEffectEQ6 *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioEffectEQ6> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioEffectEQ6>>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectFilter> {
	/// @throws exception
	static godot::AudioEffectFilter unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectFilter *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectFilter v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectFilter>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectFilter &> {
	/// @throws exception
	static godot::AudioEffectFilter &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectFilter *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectFilter &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectFilter>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioEffectFilter>> {
	/// @throws exception
	static godot::Ref<godot::AudioEffectFilter> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioEffectFilter>((godot::AudioEffectFilter *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioEffectFilter> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioEffectFilter>>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectHighPassFilter> {
	/// @throws exception
	static godot::AudioEffectHighPassFilter unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectHighPassFilter *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectHighPassFilter v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectHighPassFilter>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectHighPassFilter &> {
	/// @throws exception
	static godot::AudioEffectHighPassFilter &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectHighPassFilter *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectHighPassFilter &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectHighPassFilter>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioEffectHighPassFilter>> {
	/// @throws exception
	static godot::Ref<godot::AudioEffectHighPassFilter> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioEffectHighPassFilter>((godot::AudioEffectHighPassFilter *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioEffectHighPassFilter> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioEffectHighPassFilter>>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectHighShelfFilter> {
	/// @throws exception
	static godot::AudioEffectHighShelfFilter unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectHighShelfFilter *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectHighShelfFilter v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectHighShelfFilter>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectHighShelfFilter &> {
	/// @throws exception
	static godot::AudioEffectHighShelfFilter &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectHighShelfFilter *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectHighShelfFilter &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectHighShelfFilter>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioEffectHighShelfFilter>> {
	/// @throws exception
	static godot::Ref<godot::AudioEffectHighShelfFilter> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioEffectHighShelfFilter>((godot::AudioEffectHighShelfFilter *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioEffectHighShelfFilter> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioEffectHighShelfFilter>>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectInstance> {
	/// @throws exception
	static godot::AudioEffectInstance unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectInstance *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectInstance v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectInstance>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectInstance &> {
	/// @throws exception
	static godot::AudioEffectInstance &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectInstance *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectInstance &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectInstance>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioEffectInstance>> {
	/// @throws exception
	static godot::Ref<godot::AudioEffectInstance> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioEffectInstance>((godot::AudioEffectInstance *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioEffectInstance> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioEffectInstance>>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectLimiter> {
	/// @throws exception
	static godot::AudioEffectLimiter unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectLimiter *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectLimiter v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectLimiter>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectLimiter &> {
	/// @throws exception
	static godot::AudioEffectLimiter &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectLimiter *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectLimiter &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectLimiter>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioEffectLimiter>> {
	/// @throws exception
	static godot::Ref<godot::AudioEffectLimiter> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioEffectLimiter>((godot::AudioEffectLimiter *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioEffectLimiter> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioEffectLimiter>>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectLowPassFilter> {
	/// @throws exception
	static godot::AudioEffectLowPassFilter unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectLowPassFilter *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectLowPassFilter v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectLowPassFilter>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectLowPassFilter &> {
	/// @throws exception
	static godot::AudioEffectLowPassFilter &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectLowPassFilter *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectLowPassFilter &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectLowPassFilter>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioEffectLowPassFilter>> {
	/// @throws exception
	static godot::Ref<godot::AudioEffectLowPassFilter> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioEffectLowPassFilter>((godot::AudioEffectLowPassFilter *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioEffectLowPassFilter> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioEffectLowPassFilter>>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectLowShelfFilter> {
	/// @throws exception
	static godot::AudioEffectLowShelfFilter unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectLowShelfFilter *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectLowShelfFilter v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectLowShelfFilter>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectLowShelfFilter &> {
	/// @throws exception
	static godot::AudioEffectLowShelfFilter &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectLowShelfFilter *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectLowShelfFilter &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectLowShelfFilter>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioEffectLowShelfFilter>> {
	/// @throws exception
	static godot::Ref<godot::AudioEffectLowShelfFilter> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioEffectLowShelfFilter>((godot::AudioEffectLowShelfFilter *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioEffectLowShelfFilter> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioEffectLowShelfFilter>>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectNotchFilter> {
	/// @throws exception
	static godot::AudioEffectNotchFilter unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectNotchFilter *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectNotchFilter v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectNotchFilter>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectNotchFilter &> {
	/// @throws exception
	static godot::AudioEffectNotchFilter &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectNotchFilter *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectNotchFilter &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectNotchFilter>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioEffectNotchFilter>> {
	/// @throws exception
	static godot::Ref<godot::AudioEffectNotchFilter> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioEffectNotchFilter>((godot::AudioEffectNotchFilter *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioEffectNotchFilter> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioEffectNotchFilter>>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectPanner> {
	/// @throws exception
	static godot::AudioEffectPanner unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectPanner *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectPanner v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectPanner>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectPanner &> {
	/// @throws exception
	static godot::AudioEffectPanner &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectPanner *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectPanner &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectPanner>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioEffectPanner>> {
	/// @throws exception
	static godot::Ref<godot::AudioEffectPanner> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioEffectPanner>((godot::AudioEffectPanner *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioEffectPanner> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioEffectPanner>>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectPhaser> {
	/// @throws exception
	static godot::AudioEffectPhaser unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectPhaser *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectPhaser v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectPhaser>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectPhaser &> {
	/// @throws exception
	static godot::AudioEffectPhaser &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectPhaser *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectPhaser &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectPhaser>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioEffectPhaser>> {
	/// @throws exception
	static godot::Ref<godot::AudioEffectPhaser> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioEffectPhaser>((godot::AudioEffectPhaser *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioEffectPhaser> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioEffectPhaser>>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectPitchShift> {
	/// @throws exception
	static godot::AudioEffectPitchShift unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectPitchShift *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectPitchShift v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectPitchShift>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectPitchShift &> {
	/// @throws exception
	static godot::AudioEffectPitchShift &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectPitchShift *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectPitchShift &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectPitchShift>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioEffectPitchShift>> {
	/// @throws exception
	static godot::Ref<godot::AudioEffectPitchShift> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioEffectPitchShift>((godot::AudioEffectPitchShift *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioEffectPitchShift> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioEffectPitchShift>>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectRecord> {
	/// @throws exception
	static godot::AudioEffectRecord unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectRecord *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectRecord v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectRecord>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectRecord &> {
	/// @throws exception
	static godot::AudioEffectRecord &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectRecord *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectRecord &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectRecord>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioEffectRecord>> {
	/// @throws exception
	static godot::Ref<godot::AudioEffectRecord> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioEffectRecord>((godot::AudioEffectRecord *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioEffectRecord> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioEffectRecord>>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectReverb> {
	/// @throws exception
	static godot::AudioEffectReverb unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectReverb *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectReverb v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectReverb>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectReverb &> {
	/// @throws exception
	static godot::AudioEffectReverb &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectReverb *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectReverb &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectReverb>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioEffectReverb>> {
	/// @throws exception
	static godot::Ref<godot::AudioEffectReverb> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioEffectReverb>((godot::AudioEffectReverb *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioEffectReverb> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioEffectReverb>>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectSpectrumAnalyzer> {
	/// @throws exception
	static godot::AudioEffectSpectrumAnalyzer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectSpectrumAnalyzer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectSpectrumAnalyzer v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectSpectrumAnalyzer>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectSpectrumAnalyzer &> {
	/// @throws exception
	static godot::AudioEffectSpectrumAnalyzer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectSpectrumAnalyzer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectSpectrumAnalyzer &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectSpectrumAnalyzer>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioEffectSpectrumAnalyzer>> {
	/// @throws exception
	static godot::Ref<godot::AudioEffectSpectrumAnalyzer> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioEffectSpectrumAnalyzer>((godot::AudioEffectSpectrumAnalyzer *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioEffectSpectrumAnalyzer> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioEffectSpectrumAnalyzer>>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectSpectrumAnalyzerInstance> {
	/// @throws exception
	static godot::AudioEffectSpectrumAnalyzerInstance unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectSpectrumAnalyzerInstance *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectSpectrumAnalyzerInstance v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectSpectrumAnalyzerInstance>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectSpectrumAnalyzerInstance &> {
	/// @throws exception
	static godot::AudioEffectSpectrumAnalyzerInstance &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectSpectrumAnalyzerInstance *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectSpectrumAnalyzerInstance &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectSpectrumAnalyzerInstance>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioEffectSpectrumAnalyzerInstance>> {
	/// @throws exception
	static godot::Ref<godot::AudioEffectSpectrumAnalyzerInstance> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioEffectSpectrumAnalyzerInstance>((godot::AudioEffectSpectrumAnalyzerInstance *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioEffectSpectrumAnalyzerInstance> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioEffectSpectrumAnalyzerInstance>>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectStereoEnhance> {
	/// @throws exception
	static godot::AudioEffectStereoEnhance unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectStereoEnhance *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectStereoEnhance v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectStereoEnhance>(v) };
	}
};
template <>
struct js_traits<godot::AudioEffectStereoEnhance &> {
	/// @throws exception
	static godot::AudioEffectStereoEnhance &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioEffectStereoEnhance *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioEffectStereoEnhance &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioEffectStereoEnhance>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioEffectStereoEnhance>> {
	/// @throws exception
	static godot::Ref<godot::AudioEffectStereoEnhance> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioEffectStereoEnhance>((godot::AudioEffectStereoEnhance *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioEffectStereoEnhance> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioEffectStereoEnhance>>(v) };
	}
};
template <>
struct js_traits<godot::AudioListener2D> {
	/// @throws exception
	static godot::AudioListener2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioListener2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioListener2D v) noexcept {
		return Value{ ctx, std::forward<godot::AudioListener2D>(v) };
	}
};
template <>
struct js_traits<godot::AudioListener2D &> {
	/// @throws exception
	static godot::AudioListener2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioListener2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioListener2D &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioListener2D>(v) };
	}
};
template <>
struct js_traits<godot::AudioListener3D> {
	/// @throws exception
	static godot::AudioListener3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioListener3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioListener3D v) noexcept {
		return Value{ ctx, std::forward<godot::AudioListener3D>(v) };
	}
};
template <>
struct js_traits<godot::AudioListener3D &> {
	/// @throws exception
	static godot::AudioListener3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioListener3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioListener3D &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioListener3D>(v) };
	}
};
template <>
struct js_traits<godot::AudioServer> {
	/// @throws exception
	static godot::AudioServer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioServer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioServer v) noexcept {
		return Value{ ctx, std::forward<godot::AudioServer>(v) };
	}
};
template <>
struct js_traits<godot::AudioServer &> {
	/// @throws exception
	static godot::AudioServer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioServer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioServer &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioServer>(v) };
	}
};
template <>
struct js_traits<godot::AudioStream> {
	/// @throws exception
	static godot::AudioStream unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioStream *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioStream v) noexcept {
		return Value{ ctx, std::forward<godot::AudioStream>(v) };
	}
};
template <>
struct js_traits<godot::AudioStream &> {
	/// @throws exception
	static godot::AudioStream &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioStream *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioStream &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioStream>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioStream>> {
	/// @throws exception
	static godot::Ref<godot::AudioStream> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioStream>((godot::AudioStream *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioStream> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioStream>>(v) };
	}
};
template <>
struct js_traits<godot::AudioStreamGenerator> {
	/// @throws exception
	static godot::AudioStreamGenerator unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioStreamGenerator *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioStreamGenerator v) noexcept {
		return Value{ ctx, std::forward<godot::AudioStreamGenerator>(v) };
	}
};
template <>
struct js_traits<godot::AudioStreamGenerator &> {
	/// @throws exception
	static godot::AudioStreamGenerator &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioStreamGenerator *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioStreamGenerator &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioStreamGenerator>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioStreamGenerator>> {
	/// @throws exception
	static godot::Ref<godot::AudioStreamGenerator> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioStreamGenerator>((godot::AudioStreamGenerator *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioStreamGenerator> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioStreamGenerator>>(v) };
	}
};
template <>
struct js_traits<godot::AudioStreamGeneratorPlayback> {
	/// @throws exception
	static godot::AudioStreamGeneratorPlayback unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioStreamGeneratorPlayback *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioStreamGeneratorPlayback v) noexcept {
		return Value{ ctx, std::forward<godot::AudioStreamGeneratorPlayback>(v) };
	}
};
template <>
struct js_traits<godot::AudioStreamGeneratorPlayback &> {
	/// @throws exception
	static godot::AudioStreamGeneratorPlayback &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioStreamGeneratorPlayback *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioStreamGeneratorPlayback &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioStreamGeneratorPlayback>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioStreamGeneratorPlayback>> {
	/// @throws exception
	static godot::Ref<godot::AudioStreamGeneratorPlayback> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioStreamGeneratorPlayback>((godot::AudioStreamGeneratorPlayback *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioStreamGeneratorPlayback> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioStreamGeneratorPlayback>>(v) };
	}
};
template <>
struct js_traits<godot::AudioStreamMP3> {
	/// @throws exception
	static godot::AudioStreamMP3 unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioStreamMP3 *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioStreamMP3 v) noexcept {
		return Value{ ctx, std::forward<godot::AudioStreamMP3>(v) };
	}
};
template <>
struct js_traits<godot::AudioStreamMP3 &> {
	/// @throws exception
	static godot::AudioStreamMP3 &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioStreamMP3 *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioStreamMP3 &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioStreamMP3>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioStreamMP3>> {
	/// @throws exception
	static godot::Ref<godot::AudioStreamMP3> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioStreamMP3>((godot::AudioStreamMP3 *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioStreamMP3> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioStreamMP3>>(v) };
	}
};
template <>
struct js_traits<godot::AudioStreamMicrophone> {
	/// @throws exception
	static godot::AudioStreamMicrophone unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioStreamMicrophone *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioStreamMicrophone v) noexcept {
		return Value{ ctx, std::forward<godot::AudioStreamMicrophone>(v) };
	}
};
template <>
struct js_traits<godot::AudioStreamMicrophone &> {
	/// @throws exception
	static godot::AudioStreamMicrophone &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioStreamMicrophone *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioStreamMicrophone &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioStreamMicrophone>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioStreamMicrophone>> {
	/// @throws exception
	static godot::Ref<godot::AudioStreamMicrophone> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioStreamMicrophone>((godot::AudioStreamMicrophone *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioStreamMicrophone> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioStreamMicrophone>>(v) };
	}
};
template <>
struct js_traits<godot::AudioStreamOggVorbis> {
	/// @throws exception
	static godot::AudioStreamOggVorbis unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioStreamOggVorbis *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioStreamOggVorbis v) noexcept {
		return Value{ ctx, std::forward<godot::AudioStreamOggVorbis>(v) };
	}
};
template <>
struct js_traits<godot::AudioStreamOggVorbis &> {
	/// @throws exception
	static godot::AudioStreamOggVorbis &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioStreamOggVorbis *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioStreamOggVorbis &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioStreamOggVorbis>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioStreamOggVorbis>> {
	/// @throws exception
	static godot::Ref<godot::AudioStreamOggVorbis> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioStreamOggVorbis>((godot::AudioStreamOggVorbis *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioStreamOggVorbis> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioStreamOggVorbis>>(v) };
	}
};
template <>
struct js_traits<godot::AudioStreamPlayback> {
	/// @throws exception
	static godot::AudioStreamPlayback unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioStreamPlayback *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioStreamPlayback v) noexcept {
		return Value{ ctx, std::forward<godot::AudioStreamPlayback>(v) };
	}
};
template <>
struct js_traits<godot::AudioStreamPlayback &> {
	/// @throws exception
	static godot::AudioStreamPlayback &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioStreamPlayback *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioStreamPlayback &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioStreamPlayback>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioStreamPlayback>> {
	/// @throws exception
	static godot::Ref<godot::AudioStreamPlayback> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioStreamPlayback>((godot::AudioStreamPlayback *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioStreamPlayback> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioStreamPlayback>>(v) };
	}
};
template <>
struct js_traits<godot::AudioStreamPlaybackOggVorbis> {
	/// @throws exception
	static godot::AudioStreamPlaybackOggVorbis unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioStreamPlaybackOggVorbis *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioStreamPlaybackOggVorbis v) noexcept {
		return Value{ ctx, std::forward<godot::AudioStreamPlaybackOggVorbis>(v) };
	}
};
template <>
struct js_traits<godot::AudioStreamPlaybackOggVorbis &> {
	/// @throws exception
	static godot::AudioStreamPlaybackOggVorbis &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioStreamPlaybackOggVorbis *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioStreamPlaybackOggVorbis &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioStreamPlaybackOggVorbis>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioStreamPlaybackOggVorbis>> {
	/// @throws exception
	static godot::Ref<godot::AudioStreamPlaybackOggVorbis> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioStreamPlaybackOggVorbis>((godot::AudioStreamPlaybackOggVorbis *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioStreamPlaybackOggVorbis> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioStreamPlaybackOggVorbis>>(v) };
	}
};
template <>
struct js_traits<godot::AudioStreamPlaybackPolyphonic> {
	/// @throws exception
	static godot::AudioStreamPlaybackPolyphonic unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioStreamPlaybackPolyphonic *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioStreamPlaybackPolyphonic v) noexcept {
		return Value{ ctx, std::forward<godot::AudioStreamPlaybackPolyphonic>(v) };
	}
};
template <>
struct js_traits<godot::AudioStreamPlaybackPolyphonic &> {
	/// @throws exception
	static godot::AudioStreamPlaybackPolyphonic &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioStreamPlaybackPolyphonic *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioStreamPlaybackPolyphonic &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioStreamPlaybackPolyphonic>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioStreamPlaybackPolyphonic>> {
	/// @throws exception
	static godot::Ref<godot::AudioStreamPlaybackPolyphonic> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioStreamPlaybackPolyphonic>((godot::AudioStreamPlaybackPolyphonic *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioStreamPlaybackPolyphonic> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioStreamPlaybackPolyphonic>>(v) };
	}
};
template <>
struct js_traits<godot::AudioStreamPlaybackResampled> {
	/// @throws exception
	static godot::AudioStreamPlaybackResampled unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioStreamPlaybackResampled *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioStreamPlaybackResampled v) noexcept {
		return Value{ ctx, std::forward<godot::AudioStreamPlaybackResampled>(v) };
	}
};
template <>
struct js_traits<godot::AudioStreamPlaybackResampled &> {
	/// @throws exception
	static godot::AudioStreamPlaybackResampled &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioStreamPlaybackResampled *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioStreamPlaybackResampled &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioStreamPlaybackResampled>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioStreamPlaybackResampled>> {
	/// @throws exception
	static godot::Ref<godot::AudioStreamPlaybackResampled> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioStreamPlaybackResampled>((godot::AudioStreamPlaybackResampled *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioStreamPlaybackResampled> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioStreamPlaybackResampled>>(v) };
	}
};
template <>
struct js_traits<godot::AudioStreamPlayer> {
	/// @throws exception
	static godot::AudioStreamPlayer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioStreamPlayer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioStreamPlayer v) noexcept {
		return Value{ ctx, std::forward<godot::AudioStreamPlayer>(v) };
	}
};
template <>
struct js_traits<godot::AudioStreamPlayer &> {
	/// @throws exception
	static godot::AudioStreamPlayer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioStreamPlayer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioStreamPlayer &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioStreamPlayer>(v) };
	}
};
template <>
struct js_traits<godot::AudioStreamPlayer2D> {
	/// @throws exception
	static godot::AudioStreamPlayer2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioStreamPlayer2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioStreamPlayer2D v) noexcept {
		return Value{ ctx, std::forward<godot::AudioStreamPlayer2D>(v) };
	}
};
template <>
struct js_traits<godot::AudioStreamPlayer2D &> {
	/// @throws exception
	static godot::AudioStreamPlayer2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioStreamPlayer2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioStreamPlayer2D &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioStreamPlayer2D>(v) };
	}
};
template <>
struct js_traits<godot::AudioStreamPlayer3D> {
	/// @throws exception
	static godot::AudioStreamPlayer3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioStreamPlayer3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioStreamPlayer3D v) noexcept {
		return Value{ ctx, std::forward<godot::AudioStreamPlayer3D>(v) };
	}
};
template <>
struct js_traits<godot::AudioStreamPlayer3D &> {
	/// @throws exception
	static godot::AudioStreamPlayer3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioStreamPlayer3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioStreamPlayer3D &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioStreamPlayer3D>(v) };
	}
};
template <>
struct js_traits<godot::AudioStreamPolyphonic> {
	/// @throws exception
	static godot::AudioStreamPolyphonic unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioStreamPolyphonic *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioStreamPolyphonic v) noexcept {
		return Value{ ctx, std::forward<godot::AudioStreamPolyphonic>(v) };
	}
};
template <>
struct js_traits<godot::AudioStreamPolyphonic &> {
	/// @throws exception
	static godot::AudioStreamPolyphonic &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioStreamPolyphonic *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioStreamPolyphonic &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioStreamPolyphonic>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioStreamPolyphonic>> {
	/// @throws exception
	static godot::Ref<godot::AudioStreamPolyphonic> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioStreamPolyphonic>((godot::AudioStreamPolyphonic *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioStreamPolyphonic> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioStreamPolyphonic>>(v) };
	}
};
template <>
struct js_traits<godot::AudioStreamRandomizer> {
	/// @throws exception
	static godot::AudioStreamRandomizer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioStreamRandomizer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioStreamRandomizer v) noexcept {
		return Value{ ctx, std::forward<godot::AudioStreamRandomizer>(v) };
	}
};
template <>
struct js_traits<godot::AudioStreamRandomizer &> {
	/// @throws exception
	static godot::AudioStreamRandomizer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioStreamRandomizer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioStreamRandomizer &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioStreamRandomizer>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioStreamRandomizer>> {
	/// @throws exception
	static godot::Ref<godot::AudioStreamRandomizer> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioStreamRandomizer>((godot::AudioStreamRandomizer *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioStreamRandomizer> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioStreamRandomizer>>(v) };
	}
};
template <>
struct js_traits<godot::AudioStreamWAV> {
	/// @throws exception
	static godot::AudioStreamWAV unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioStreamWAV *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioStreamWAV v) noexcept {
		return Value{ ctx, std::forward<godot::AudioStreamWAV>(v) };
	}
};
template <>
struct js_traits<godot::AudioStreamWAV &> {
	/// @throws exception
	static godot::AudioStreamWAV &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AudioStreamWAV *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AudioStreamWAV &v) noexcept {
		return Value{ ctx, std::forward<godot::AudioStreamWAV>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::AudioStreamWAV>> {
	/// @throws exception
	static godot::Ref<godot::AudioStreamWAV> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::AudioStreamWAV>((godot::AudioStreamWAV *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::AudioStreamWAV> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::AudioStreamWAV>>(v) };
	}
};
template <>
struct js_traits<godot::BackBufferCopy> {
	/// @throws exception
	static godot::BackBufferCopy unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::BackBufferCopy *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::BackBufferCopy v) noexcept {
		return Value{ ctx, std::forward<godot::BackBufferCopy>(v) };
	}
};
template <>
struct js_traits<godot::BackBufferCopy &> {
	/// @throws exception
	static godot::BackBufferCopy &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::BackBufferCopy *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::BackBufferCopy &v) noexcept {
		return Value{ ctx, std::forward<godot::BackBufferCopy>(v) };
	}
};
template <>
struct js_traits<godot::BaseButton> {
	/// @throws exception
	static godot::BaseButton unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::BaseButton *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::BaseButton v) noexcept {
		return Value{ ctx, std::forward<godot::BaseButton>(v) };
	}
};
template <>
struct js_traits<godot::BaseButton &> {
	/// @throws exception
	static godot::BaseButton &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::BaseButton *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::BaseButton &v) noexcept {
		return Value{ ctx, std::forward<godot::BaseButton>(v) };
	}
};
template <>
struct js_traits<godot::BaseMaterial3D> {
	/// @throws exception
	static godot::BaseMaterial3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::BaseMaterial3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::BaseMaterial3D v) noexcept {
		return Value{ ctx, std::forward<godot::BaseMaterial3D>(v) };
	}
};
template <>
struct js_traits<godot::BaseMaterial3D &> {
	/// @throws exception
	static godot::BaseMaterial3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::BaseMaterial3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::BaseMaterial3D &v) noexcept {
		return Value{ ctx, std::forward<godot::BaseMaterial3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::BaseMaterial3D>> {
	/// @throws exception
	static godot::Ref<godot::BaseMaterial3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::BaseMaterial3D>((godot::BaseMaterial3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::BaseMaterial3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::BaseMaterial3D>>(v) };
	}
};
template <>
struct js_traits<godot::BitMap> {
	/// @throws exception
	static godot::BitMap unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::BitMap *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::BitMap v) noexcept {
		return Value{ ctx, std::forward<godot::BitMap>(v) };
	}
};
template <>
struct js_traits<godot::BitMap &> {
	/// @throws exception
	static godot::BitMap &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::BitMap *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::BitMap &v) noexcept {
		return Value{ ctx, std::forward<godot::BitMap>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::BitMap>> {
	/// @throws exception
	static godot::Ref<godot::BitMap> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::BitMap>((godot::BitMap *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::BitMap> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::BitMap>>(v) };
	}
};
template <>
struct js_traits<godot::Bone2D> {
	/// @throws exception
	static godot::Bone2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Bone2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Bone2D v) noexcept {
		return Value{ ctx, std::forward<godot::Bone2D>(v) };
	}
};
template <>
struct js_traits<godot::Bone2D &> {
	/// @throws exception
	static godot::Bone2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Bone2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Bone2D &v) noexcept {
		return Value{ ctx, std::forward<godot::Bone2D>(v) };
	}
};
template <>
struct js_traits<godot::BoneAttachment3D> {
	/// @throws exception
	static godot::BoneAttachment3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::BoneAttachment3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::BoneAttachment3D v) noexcept {
		return Value{ ctx, std::forward<godot::BoneAttachment3D>(v) };
	}
};
template <>
struct js_traits<godot::BoneAttachment3D &> {
	/// @throws exception
	static godot::BoneAttachment3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::BoneAttachment3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::BoneAttachment3D &v) noexcept {
		return Value{ ctx, std::forward<godot::BoneAttachment3D>(v) };
	}
};
template <>
struct js_traits<godot::BoneMap> {
	/// @throws exception
	static godot::BoneMap unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::BoneMap *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::BoneMap v) noexcept {
		return Value{ ctx, std::forward<godot::BoneMap>(v) };
	}
};
template <>
struct js_traits<godot::BoneMap &> {
	/// @throws exception
	static godot::BoneMap &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::BoneMap *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::BoneMap &v) noexcept {
		return Value{ ctx, std::forward<godot::BoneMap>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::BoneMap>> {
	/// @throws exception
	static godot::Ref<godot::BoneMap> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::BoneMap>((godot::BoneMap *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::BoneMap> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::BoneMap>>(v) };
	}
};
template <>
struct js_traits<godot::BoxContainer> {
	/// @throws exception
	static godot::BoxContainer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::BoxContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::BoxContainer v) noexcept {
		return Value{ ctx, std::forward<godot::BoxContainer>(v) };
	}
};
template <>
struct js_traits<godot::BoxContainer &> {
	/// @throws exception
	static godot::BoxContainer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::BoxContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::BoxContainer &v) noexcept {
		return Value{ ctx, std::forward<godot::BoxContainer>(v) };
	}
};
template <>
struct js_traits<godot::BoxMesh> {
	/// @throws exception
	static godot::BoxMesh unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::BoxMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::BoxMesh v) noexcept {
		return Value{ ctx, std::forward<godot::BoxMesh>(v) };
	}
};
template <>
struct js_traits<godot::BoxMesh &> {
	/// @throws exception
	static godot::BoxMesh &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::BoxMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::BoxMesh &v) noexcept {
		return Value{ ctx, std::forward<godot::BoxMesh>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::BoxMesh>> {
	/// @throws exception
	static godot::Ref<godot::BoxMesh> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::BoxMesh>((godot::BoxMesh *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::BoxMesh> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::BoxMesh>>(v) };
	}
};
template <>
struct js_traits<godot::BoxOccluder3D> {
	/// @throws exception
	static godot::BoxOccluder3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::BoxOccluder3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::BoxOccluder3D v) noexcept {
		return Value{ ctx, std::forward<godot::BoxOccluder3D>(v) };
	}
};
template <>
struct js_traits<godot::BoxOccluder3D &> {
	/// @throws exception
	static godot::BoxOccluder3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::BoxOccluder3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::BoxOccluder3D &v) noexcept {
		return Value{ ctx, std::forward<godot::BoxOccluder3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::BoxOccluder3D>> {
	/// @throws exception
	static godot::Ref<godot::BoxOccluder3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::BoxOccluder3D>((godot::BoxOccluder3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::BoxOccluder3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::BoxOccluder3D>>(v) };
	}
};
template <>
struct js_traits<godot::BoxShape3D> {
	/// @throws exception
	static godot::BoxShape3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::BoxShape3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::BoxShape3D v) noexcept {
		return Value{ ctx, std::forward<godot::BoxShape3D>(v) };
	}
};
template <>
struct js_traits<godot::BoxShape3D &> {
	/// @throws exception
	static godot::BoxShape3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::BoxShape3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::BoxShape3D &v) noexcept {
		return Value{ ctx, std::forward<godot::BoxShape3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::BoxShape3D>> {
	/// @throws exception
	static godot::Ref<godot::BoxShape3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::BoxShape3D>((godot::BoxShape3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::BoxShape3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::BoxShape3D>>(v) };
	}
};
template <>
struct js_traits<godot::Button> {
	/// @throws exception
	static godot::Button unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Button *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Button v) noexcept {
		return Value{ ctx, std::forward<godot::Button>(v) };
	}
};
template <>
struct js_traits<godot::Button &> {
	/// @throws exception
	static godot::Button &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Button *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Button &v) noexcept {
		return Value{ ctx, std::forward<godot::Button>(v) };
	}
};
template <>
struct js_traits<godot::ButtonGroup> {
	/// @throws exception
	static godot::ButtonGroup unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ButtonGroup *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ButtonGroup v) noexcept {
		return Value{ ctx, std::forward<godot::ButtonGroup>(v) };
	}
};
template <>
struct js_traits<godot::ButtonGroup &> {
	/// @throws exception
	static godot::ButtonGroup &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ButtonGroup *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ButtonGroup &v) noexcept {
		return Value{ ctx, std::forward<godot::ButtonGroup>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ButtonGroup>> {
	/// @throws exception
	static godot::Ref<godot::ButtonGroup> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ButtonGroup>((godot::ButtonGroup *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ButtonGroup> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ButtonGroup>>(v) };
	}
};
template <>
struct js_traits<godot::CPUParticles2D> {
	/// @throws exception
	static godot::CPUParticles2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CPUParticles2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CPUParticles2D v) noexcept {
		return Value{ ctx, std::forward<godot::CPUParticles2D>(v) };
	}
};
template <>
struct js_traits<godot::CPUParticles2D &> {
	/// @throws exception
	static godot::CPUParticles2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CPUParticles2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CPUParticles2D &v) noexcept {
		return Value{ ctx, std::forward<godot::CPUParticles2D>(v) };
	}
};
template <>
struct js_traits<godot::CPUParticles3D> {
	/// @throws exception
	static godot::CPUParticles3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CPUParticles3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CPUParticles3D v) noexcept {
		return Value{ ctx, std::forward<godot::CPUParticles3D>(v) };
	}
};
template <>
struct js_traits<godot::CPUParticles3D &> {
	/// @throws exception
	static godot::CPUParticles3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CPUParticles3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CPUParticles3D &v) noexcept {
		return Value{ ctx, std::forward<godot::CPUParticles3D>(v) };
	}
};
template <>
struct js_traits<godot::CSGBox3D> {
	/// @throws exception
	static godot::CSGBox3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CSGBox3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CSGBox3D v) noexcept {
		return Value{ ctx, std::forward<godot::CSGBox3D>(v) };
	}
};
template <>
struct js_traits<godot::CSGBox3D &> {
	/// @throws exception
	static godot::CSGBox3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CSGBox3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CSGBox3D &v) noexcept {
		return Value{ ctx, std::forward<godot::CSGBox3D>(v) };
	}
};
template <>
struct js_traits<godot::CSGCombiner3D> {
	/// @throws exception
	static godot::CSGCombiner3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CSGCombiner3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CSGCombiner3D v) noexcept {
		return Value{ ctx, std::forward<godot::CSGCombiner3D>(v) };
	}
};
template <>
struct js_traits<godot::CSGCombiner3D &> {
	/// @throws exception
	static godot::CSGCombiner3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CSGCombiner3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CSGCombiner3D &v) noexcept {
		return Value{ ctx, std::forward<godot::CSGCombiner3D>(v) };
	}
};
template <>
struct js_traits<godot::CSGCylinder3D> {
	/// @throws exception
	static godot::CSGCylinder3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CSGCylinder3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CSGCylinder3D v) noexcept {
		return Value{ ctx, std::forward<godot::CSGCylinder3D>(v) };
	}
};
template <>
struct js_traits<godot::CSGCylinder3D &> {
	/// @throws exception
	static godot::CSGCylinder3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CSGCylinder3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CSGCylinder3D &v) noexcept {
		return Value{ ctx, std::forward<godot::CSGCylinder3D>(v) };
	}
};
template <>
struct js_traits<godot::CSGMesh3D> {
	/// @throws exception
	static godot::CSGMesh3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CSGMesh3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CSGMesh3D v) noexcept {
		return Value{ ctx, std::forward<godot::CSGMesh3D>(v) };
	}
};
template <>
struct js_traits<godot::CSGMesh3D &> {
	/// @throws exception
	static godot::CSGMesh3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CSGMesh3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CSGMesh3D &v) noexcept {
		return Value{ ctx, std::forward<godot::CSGMesh3D>(v) };
	}
};
template <>
struct js_traits<godot::CSGPolygon3D> {
	/// @throws exception
	static godot::CSGPolygon3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CSGPolygon3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CSGPolygon3D v) noexcept {
		return Value{ ctx, std::forward<godot::CSGPolygon3D>(v) };
	}
};
template <>
struct js_traits<godot::CSGPolygon3D &> {
	/// @throws exception
	static godot::CSGPolygon3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CSGPolygon3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CSGPolygon3D &v) noexcept {
		return Value{ ctx, std::forward<godot::CSGPolygon3D>(v) };
	}
};
template <>
struct js_traits<godot::CSGPrimitive3D> {
	/// @throws exception
	static godot::CSGPrimitive3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CSGPrimitive3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CSGPrimitive3D v) noexcept {
		return Value{ ctx, std::forward<godot::CSGPrimitive3D>(v) };
	}
};
template <>
struct js_traits<godot::CSGPrimitive3D &> {
	/// @throws exception
	static godot::CSGPrimitive3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CSGPrimitive3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CSGPrimitive3D &v) noexcept {
		return Value{ ctx, std::forward<godot::CSGPrimitive3D>(v) };
	}
};
template <>
struct js_traits<godot::CSGShape3D> {
	/// @throws exception
	static godot::CSGShape3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CSGShape3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CSGShape3D v) noexcept {
		return Value{ ctx, std::forward<godot::CSGShape3D>(v) };
	}
};
template <>
struct js_traits<godot::CSGShape3D &> {
	/// @throws exception
	static godot::CSGShape3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CSGShape3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CSGShape3D &v) noexcept {
		return Value{ ctx, std::forward<godot::CSGShape3D>(v) };
	}
};
template <>
struct js_traits<godot::CSGSphere3D> {
	/// @throws exception
	static godot::CSGSphere3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CSGSphere3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CSGSphere3D v) noexcept {
		return Value{ ctx, std::forward<godot::CSGSphere3D>(v) };
	}
};
template <>
struct js_traits<godot::CSGSphere3D &> {
	/// @throws exception
	static godot::CSGSphere3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CSGSphere3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CSGSphere3D &v) noexcept {
		return Value{ ctx, std::forward<godot::CSGSphere3D>(v) };
	}
};
template <>
struct js_traits<godot::CSGTorus3D> {
	/// @throws exception
	static godot::CSGTorus3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CSGTorus3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CSGTorus3D v) noexcept {
		return Value{ ctx, std::forward<godot::CSGTorus3D>(v) };
	}
};
template <>
struct js_traits<godot::CSGTorus3D &> {
	/// @throws exception
	static godot::CSGTorus3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CSGTorus3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CSGTorus3D &v) noexcept {
		return Value{ ctx, std::forward<godot::CSGTorus3D>(v) };
	}
};
template <>
struct js_traits<godot::CallbackTweener> {
	/// @throws exception
	static godot::CallbackTweener unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CallbackTweener *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CallbackTweener v) noexcept {
		return Value{ ctx, std::forward<godot::CallbackTweener>(v) };
	}
};
template <>
struct js_traits<godot::CallbackTweener &> {
	/// @throws exception
	static godot::CallbackTweener &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CallbackTweener *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CallbackTweener &v) noexcept {
		return Value{ ctx, std::forward<godot::CallbackTweener>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::CallbackTweener>> {
	/// @throws exception
	static godot::Ref<godot::CallbackTweener> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::CallbackTweener>((godot::CallbackTweener *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::CallbackTweener> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::CallbackTweener>>(v) };
	}
};
template <>
struct js_traits<godot::Camera2D> {
	/// @throws exception
	static godot::Camera2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Camera2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Camera2D v) noexcept {
		return Value{ ctx, std::forward<godot::Camera2D>(v) };
	}
};
template <>
struct js_traits<godot::Camera2D &> {
	/// @throws exception
	static godot::Camera2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Camera2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Camera2D &v) noexcept {
		return Value{ ctx, std::forward<godot::Camera2D>(v) };
	}
};
template <>
struct js_traits<godot::Camera3D> {
	/// @throws exception
	static godot::Camera3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Camera3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Camera3D v) noexcept {
		return Value{ ctx, std::forward<godot::Camera3D>(v) };
	}
};
template <>
struct js_traits<godot::Camera3D &> {
	/// @throws exception
	static godot::Camera3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Camera3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Camera3D &v) noexcept {
		return Value{ ctx, std::forward<godot::Camera3D>(v) };
	}
};
template <>
struct js_traits<godot::CameraAttributes> {
	/// @throws exception
	static godot::CameraAttributes unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CameraAttributes *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CameraAttributes v) noexcept {
		return Value{ ctx, std::forward<godot::CameraAttributes>(v) };
	}
};
template <>
struct js_traits<godot::CameraAttributes &> {
	/// @throws exception
	static godot::CameraAttributes &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CameraAttributes *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CameraAttributes &v) noexcept {
		return Value{ ctx, std::forward<godot::CameraAttributes>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::CameraAttributes>> {
	/// @throws exception
	static godot::Ref<godot::CameraAttributes> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::CameraAttributes>((godot::CameraAttributes *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::CameraAttributes> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::CameraAttributes>>(v) };
	}
};
template <>
struct js_traits<godot::CameraAttributesPhysical> {
	/// @throws exception
	static godot::CameraAttributesPhysical unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CameraAttributesPhysical *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CameraAttributesPhysical v) noexcept {
		return Value{ ctx, std::forward<godot::CameraAttributesPhysical>(v) };
	}
};
template <>
struct js_traits<godot::CameraAttributesPhysical &> {
	/// @throws exception
	static godot::CameraAttributesPhysical &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CameraAttributesPhysical *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CameraAttributesPhysical &v) noexcept {
		return Value{ ctx, std::forward<godot::CameraAttributesPhysical>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::CameraAttributesPhysical>> {
	/// @throws exception
	static godot::Ref<godot::CameraAttributesPhysical> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::CameraAttributesPhysical>((godot::CameraAttributesPhysical *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::CameraAttributesPhysical> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::CameraAttributesPhysical>>(v) };
	}
};
template <>
struct js_traits<godot::CameraAttributesPractical> {
	/// @throws exception
	static godot::CameraAttributesPractical unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CameraAttributesPractical *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CameraAttributesPractical v) noexcept {
		return Value{ ctx, std::forward<godot::CameraAttributesPractical>(v) };
	}
};
template <>
struct js_traits<godot::CameraAttributesPractical &> {
	/// @throws exception
	static godot::CameraAttributesPractical &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CameraAttributesPractical *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CameraAttributesPractical &v) noexcept {
		return Value{ ctx, std::forward<godot::CameraAttributesPractical>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::CameraAttributesPractical>> {
	/// @throws exception
	static godot::Ref<godot::CameraAttributesPractical> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::CameraAttributesPractical>((godot::CameraAttributesPractical *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::CameraAttributesPractical> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::CameraAttributesPractical>>(v) };
	}
};
template <>
struct js_traits<godot::CameraFeed> {
	/// @throws exception
	static godot::CameraFeed unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CameraFeed *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CameraFeed v) noexcept {
		return Value{ ctx, std::forward<godot::CameraFeed>(v) };
	}
};
template <>
struct js_traits<godot::CameraFeed &> {
	/// @throws exception
	static godot::CameraFeed &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CameraFeed *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CameraFeed &v) noexcept {
		return Value{ ctx, std::forward<godot::CameraFeed>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::CameraFeed>> {
	/// @throws exception
	static godot::Ref<godot::CameraFeed> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::CameraFeed>((godot::CameraFeed *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::CameraFeed> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::CameraFeed>>(v) };
	}
};
template <>
struct js_traits<godot::CameraServer> {
	/// @throws exception
	static godot::CameraServer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CameraServer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CameraServer v) noexcept {
		return Value{ ctx, std::forward<godot::CameraServer>(v) };
	}
};
template <>
struct js_traits<godot::CameraServer &> {
	/// @throws exception
	static godot::CameraServer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CameraServer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CameraServer &v) noexcept {
		return Value{ ctx, std::forward<godot::CameraServer>(v) };
	}
};
template <>
struct js_traits<godot::CameraTexture> {
	/// @throws exception
	static godot::CameraTexture unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CameraTexture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CameraTexture v) noexcept {
		return Value{ ctx, std::forward<godot::CameraTexture>(v) };
	}
};
template <>
struct js_traits<godot::CameraTexture &> {
	/// @throws exception
	static godot::CameraTexture &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CameraTexture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CameraTexture &v) noexcept {
		return Value{ ctx, std::forward<godot::CameraTexture>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::CameraTexture>> {
	/// @throws exception
	static godot::Ref<godot::CameraTexture> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::CameraTexture>((godot::CameraTexture *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::CameraTexture> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::CameraTexture>>(v) };
	}
};
template <>
struct js_traits<godot::CanvasGroup> {
	/// @throws exception
	static godot::CanvasGroup unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CanvasGroup *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CanvasGroup v) noexcept {
		return Value{ ctx, std::forward<godot::CanvasGroup>(v) };
	}
};
template <>
struct js_traits<godot::CanvasGroup &> {
	/// @throws exception
	static godot::CanvasGroup &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CanvasGroup *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CanvasGroup &v) noexcept {
		return Value{ ctx, std::forward<godot::CanvasGroup>(v) };
	}
};
template <>
struct js_traits<godot::CanvasItem> {
	/// @throws exception
	static godot::CanvasItem unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CanvasItem *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CanvasItem v) noexcept {
		return Value{ ctx, std::forward<godot::CanvasItem>(v) };
	}
};
template <>
struct js_traits<godot::CanvasItem &> {
	/// @throws exception
	static godot::CanvasItem &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CanvasItem *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CanvasItem &v) noexcept {
		return Value{ ctx, std::forward<godot::CanvasItem>(v) };
	}
};
template <>
struct js_traits<godot::CanvasItemMaterial> {
	/// @throws exception
	static godot::CanvasItemMaterial unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CanvasItemMaterial *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CanvasItemMaterial v) noexcept {
		return Value{ ctx, std::forward<godot::CanvasItemMaterial>(v) };
	}
};
template <>
struct js_traits<godot::CanvasItemMaterial &> {
	/// @throws exception
	static godot::CanvasItemMaterial &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CanvasItemMaterial *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CanvasItemMaterial &v) noexcept {
		return Value{ ctx, std::forward<godot::CanvasItemMaterial>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::CanvasItemMaterial>> {
	/// @throws exception
	static godot::Ref<godot::CanvasItemMaterial> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::CanvasItemMaterial>((godot::CanvasItemMaterial *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::CanvasItemMaterial> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::CanvasItemMaterial>>(v) };
	}
};
template <>
struct js_traits<godot::CanvasLayer> {
	/// @throws exception
	static godot::CanvasLayer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CanvasLayer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CanvasLayer v) noexcept {
		return Value{ ctx, std::forward<godot::CanvasLayer>(v) };
	}
};
template <>
struct js_traits<godot::CanvasLayer &> {
	/// @throws exception
	static godot::CanvasLayer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CanvasLayer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CanvasLayer &v) noexcept {
		return Value{ ctx, std::forward<godot::CanvasLayer>(v) };
	}
};
template <>
struct js_traits<godot::CanvasModulate> {
	/// @throws exception
	static godot::CanvasModulate unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CanvasModulate *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CanvasModulate v) noexcept {
		return Value{ ctx, std::forward<godot::CanvasModulate>(v) };
	}
};
template <>
struct js_traits<godot::CanvasModulate &> {
	/// @throws exception
	static godot::CanvasModulate &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CanvasModulate *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CanvasModulate &v) noexcept {
		return Value{ ctx, std::forward<godot::CanvasModulate>(v) };
	}
};
template <>
struct js_traits<godot::CanvasTexture> {
	/// @throws exception
	static godot::CanvasTexture unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CanvasTexture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CanvasTexture v) noexcept {
		return Value{ ctx, std::forward<godot::CanvasTexture>(v) };
	}
};
template <>
struct js_traits<godot::CanvasTexture &> {
	/// @throws exception
	static godot::CanvasTexture &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CanvasTexture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CanvasTexture &v) noexcept {
		return Value{ ctx, std::forward<godot::CanvasTexture>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::CanvasTexture>> {
	/// @throws exception
	static godot::Ref<godot::CanvasTexture> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::CanvasTexture>((godot::CanvasTexture *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::CanvasTexture> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::CanvasTexture>>(v) };
	}
};
template <>
struct js_traits<godot::CapsuleMesh> {
	/// @throws exception
	static godot::CapsuleMesh unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CapsuleMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CapsuleMesh v) noexcept {
		return Value{ ctx, std::forward<godot::CapsuleMesh>(v) };
	}
};
template <>
struct js_traits<godot::CapsuleMesh &> {
	/// @throws exception
	static godot::CapsuleMesh &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CapsuleMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CapsuleMesh &v) noexcept {
		return Value{ ctx, std::forward<godot::CapsuleMesh>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::CapsuleMesh>> {
	/// @throws exception
	static godot::Ref<godot::CapsuleMesh> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::CapsuleMesh>((godot::CapsuleMesh *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::CapsuleMesh> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::CapsuleMesh>>(v) };
	}
};
template <>
struct js_traits<godot::CapsuleShape2D> {
	/// @throws exception
	static godot::CapsuleShape2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CapsuleShape2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CapsuleShape2D v) noexcept {
		return Value{ ctx, std::forward<godot::CapsuleShape2D>(v) };
	}
};
template <>
struct js_traits<godot::CapsuleShape2D &> {
	/// @throws exception
	static godot::CapsuleShape2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CapsuleShape2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CapsuleShape2D &v) noexcept {
		return Value{ ctx, std::forward<godot::CapsuleShape2D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::CapsuleShape2D>> {
	/// @throws exception
	static godot::Ref<godot::CapsuleShape2D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::CapsuleShape2D>((godot::CapsuleShape2D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::CapsuleShape2D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::CapsuleShape2D>>(v) };
	}
};
template <>
struct js_traits<godot::CapsuleShape3D> {
	/// @throws exception
	static godot::CapsuleShape3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CapsuleShape3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CapsuleShape3D v) noexcept {
		return Value{ ctx, std::forward<godot::CapsuleShape3D>(v) };
	}
};
template <>
struct js_traits<godot::CapsuleShape3D &> {
	/// @throws exception
	static godot::CapsuleShape3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CapsuleShape3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CapsuleShape3D &v) noexcept {
		return Value{ ctx, std::forward<godot::CapsuleShape3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::CapsuleShape3D>> {
	/// @throws exception
	static godot::Ref<godot::CapsuleShape3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::CapsuleShape3D>((godot::CapsuleShape3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::CapsuleShape3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::CapsuleShape3D>>(v) };
	}
};
template <>
struct js_traits<godot::CenterContainer> {
	/// @throws exception
	static godot::CenterContainer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CenterContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CenterContainer v) noexcept {
		return Value{ ctx, std::forward<godot::CenterContainer>(v) };
	}
};
template <>
struct js_traits<godot::CenterContainer &> {
	/// @throws exception
	static godot::CenterContainer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CenterContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CenterContainer &v) noexcept {
		return Value{ ctx, std::forward<godot::CenterContainer>(v) };
	}
};
template <>
struct js_traits<godot::CharFXTransform> {
	/// @throws exception
	static godot::CharFXTransform unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CharFXTransform *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CharFXTransform v) noexcept {
		return Value{ ctx, std::forward<godot::CharFXTransform>(v) };
	}
};
template <>
struct js_traits<godot::CharFXTransform &> {
	/// @throws exception
	static godot::CharFXTransform &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CharFXTransform *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CharFXTransform &v) noexcept {
		return Value{ ctx, std::forward<godot::CharFXTransform>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::CharFXTransform>> {
	/// @throws exception
	static godot::Ref<godot::CharFXTransform> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::CharFXTransform>((godot::CharFXTransform *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::CharFXTransform> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::CharFXTransform>>(v) };
	}
};
template <>
struct js_traits<godot::CharacterBody2D> {
	/// @throws exception
	static godot::CharacterBody2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CharacterBody2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CharacterBody2D v) noexcept {
		return Value{ ctx, std::forward<godot::CharacterBody2D>(v) };
	}
};
template <>
struct js_traits<godot::CharacterBody2D &> {
	/// @throws exception
	static godot::CharacterBody2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CharacterBody2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CharacterBody2D &v) noexcept {
		return Value{ ctx, std::forward<godot::CharacterBody2D>(v) };
	}
};
template <>
struct js_traits<godot::CharacterBody3D> {
	/// @throws exception
	static godot::CharacterBody3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CharacterBody3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CharacterBody3D v) noexcept {
		return Value{ ctx, std::forward<godot::CharacterBody3D>(v) };
	}
};
template <>
struct js_traits<godot::CharacterBody3D &> {
	/// @throws exception
	static godot::CharacterBody3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CharacterBody3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CharacterBody3D &v) noexcept {
		return Value{ ctx, std::forward<godot::CharacterBody3D>(v) };
	}
};
template <>
struct js_traits<godot::CheckBox> {
	/// @throws exception
	static godot::CheckBox unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CheckBox *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CheckBox v) noexcept {
		return Value{ ctx, std::forward<godot::CheckBox>(v) };
	}
};
template <>
struct js_traits<godot::CheckBox &> {
	/// @throws exception
	static godot::CheckBox &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CheckBox *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CheckBox &v) noexcept {
		return Value{ ctx, std::forward<godot::CheckBox>(v) };
	}
};
template <>
struct js_traits<godot::CheckButton> {
	/// @throws exception
	static godot::CheckButton unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CheckButton *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CheckButton v) noexcept {
		return Value{ ctx, std::forward<godot::CheckButton>(v) };
	}
};
template <>
struct js_traits<godot::CheckButton &> {
	/// @throws exception
	static godot::CheckButton &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CheckButton *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CheckButton &v) noexcept {
		return Value{ ctx, std::forward<godot::CheckButton>(v) };
	}
};
template <>
struct js_traits<godot::CircleShape2D> {
	/// @throws exception
	static godot::CircleShape2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CircleShape2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CircleShape2D v) noexcept {
		return Value{ ctx, std::forward<godot::CircleShape2D>(v) };
	}
};
template <>
struct js_traits<godot::CircleShape2D &> {
	/// @throws exception
	static godot::CircleShape2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CircleShape2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CircleShape2D &v) noexcept {
		return Value{ ctx, std::forward<godot::CircleShape2D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::CircleShape2D>> {
	/// @throws exception
	static godot::Ref<godot::CircleShape2D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::CircleShape2D>((godot::CircleShape2D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::CircleShape2D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::CircleShape2D>>(v) };
	}
};
template <>
struct js_traits<godot::ClassDB> {
	/// @throws exception
	static godot::ClassDB unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ClassDB *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ClassDB v) noexcept {
		return Value{ ctx, std::forward<godot::ClassDB>(v) };
	}
};
template <>
struct js_traits<godot::ClassDB &> {
	/// @throws exception
	static godot::ClassDB &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ClassDB *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ClassDB &v) noexcept {
		return Value{ ctx, std::forward<godot::ClassDB>(v) };
	}
};
template <>
struct js_traits<godot::CodeEdit> {
	/// @throws exception
	static godot::CodeEdit unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CodeEdit *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CodeEdit v) noexcept {
		return Value{ ctx, std::forward<godot::CodeEdit>(v) };
	}
};
template <>
struct js_traits<godot::CodeEdit &> {
	/// @throws exception
	static godot::CodeEdit &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CodeEdit *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CodeEdit &v) noexcept {
		return Value{ ctx, std::forward<godot::CodeEdit>(v) };
	}
};
template <>
struct js_traits<godot::CodeHighlighter> {
	/// @throws exception
	static godot::CodeHighlighter unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CodeHighlighter *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CodeHighlighter v) noexcept {
		return Value{ ctx, std::forward<godot::CodeHighlighter>(v) };
	}
};
template <>
struct js_traits<godot::CodeHighlighter &> {
	/// @throws exception
	static godot::CodeHighlighter &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CodeHighlighter *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CodeHighlighter &v) noexcept {
		return Value{ ctx, std::forward<godot::CodeHighlighter>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::CodeHighlighter>> {
	/// @throws exception
	static godot::Ref<godot::CodeHighlighter> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::CodeHighlighter>((godot::CodeHighlighter *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::CodeHighlighter> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::CodeHighlighter>>(v) };
	}
};
template <>
struct js_traits<godot::CollisionObject2D> {
	/// @throws exception
	static godot::CollisionObject2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CollisionObject2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CollisionObject2D v) noexcept {
		return Value{ ctx, std::forward<godot::CollisionObject2D>(v) };
	}
};
template <>
struct js_traits<godot::CollisionObject2D &> {
	/// @throws exception
	static godot::CollisionObject2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CollisionObject2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CollisionObject2D &v) noexcept {
		return Value{ ctx, std::forward<godot::CollisionObject2D>(v) };
	}
};
template <>
struct js_traits<godot::CollisionObject3D> {
	/// @throws exception
	static godot::CollisionObject3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CollisionObject3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CollisionObject3D v) noexcept {
		return Value{ ctx, std::forward<godot::CollisionObject3D>(v) };
	}
};
template <>
struct js_traits<godot::CollisionObject3D &> {
	/// @throws exception
	static godot::CollisionObject3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CollisionObject3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CollisionObject3D &v) noexcept {
		return Value{ ctx, std::forward<godot::CollisionObject3D>(v) };
	}
};
template <>
struct js_traits<godot::CollisionPolygon2D> {
	/// @throws exception
	static godot::CollisionPolygon2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CollisionPolygon2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CollisionPolygon2D v) noexcept {
		return Value{ ctx, std::forward<godot::CollisionPolygon2D>(v) };
	}
};
template <>
struct js_traits<godot::CollisionPolygon2D &> {
	/// @throws exception
	static godot::CollisionPolygon2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CollisionPolygon2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CollisionPolygon2D &v) noexcept {
		return Value{ ctx, std::forward<godot::CollisionPolygon2D>(v) };
	}
};
template <>
struct js_traits<godot::CollisionPolygon3D> {
	/// @throws exception
	static godot::CollisionPolygon3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CollisionPolygon3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CollisionPolygon3D v) noexcept {
		return Value{ ctx, std::forward<godot::CollisionPolygon3D>(v) };
	}
};
template <>
struct js_traits<godot::CollisionPolygon3D &> {
	/// @throws exception
	static godot::CollisionPolygon3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CollisionPolygon3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CollisionPolygon3D &v) noexcept {
		return Value{ ctx, std::forward<godot::CollisionPolygon3D>(v) };
	}
};
template <>
struct js_traits<godot::CollisionShape2D> {
	/// @throws exception
	static godot::CollisionShape2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CollisionShape2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CollisionShape2D v) noexcept {
		return Value{ ctx, std::forward<godot::CollisionShape2D>(v) };
	}
};
template <>
struct js_traits<godot::CollisionShape2D &> {
	/// @throws exception
	static godot::CollisionShape2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CollisionShape2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CollisionShape2D &v) noexcept {
		return Value{ ctx, std::forward<godot::CollisionShape2D>(v) };
	}
};
template <>
struct js_traits<godot::CollisionShape3D> {
	/// @throws exception
	static godot::CollisionShape3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CollisionShape3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CollisionShape3D v) noexcept {
		return Value{ ctx, std::forward<godot::CollisionShape3D>(v) };
	}
};
template <>
struct js_traits<godot::CollisionShape3D &> {
	/// @throws exception
	static godot::CollisionShape3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CollisionShape3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CollisionShape3D &v) noexcept {
		return Value{ ctx, std::forward<godot::CollisionShape3D>(v) };
	}
};
template <>
struct js_traits<godot::ColorPicker> {
	/// @throws exception
	static godot::ColorPicker unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ColorPicker *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ColorPicker v) noexcept {
		return Value{ ctx, std::forward<godot::ColorPicker>(v) };
	}
};
template <>
struct js_traits<godot::ColorPicker &> {
	/// @throws exception
	static godot::ColorPicker &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ColorPicker *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ColorPicker &v) noexcept {
		return Value{ ctx, std::forward<godot::ColorPicker>(v) };
	}
};
template <>
struct js_traits<godot::ColorPickerButton> {
	/// @throws exception
	static godot::ColorPickerButton unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ColorPickerButton *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ColorPickerButton v) noexcept {
		return Value{ ctx, std::forward<godot::ColorPickerButton>(v) };
	}
};
template <>
struct js_traits<godot::ColorPickerButton &> {
	/// @throws exception
	static godot::ColorPickerButton &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ColorPickerButton *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ColorPickerButton &v) noexcept {
		return Value{ ctx, std::forward<godot::ColorPickerButton>(v) };
	}
};
template <>
struct js_traits<godot::ColorRect> {
	/// @throws exception
	static godot::ColorRect unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ColorRect *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ColorRect v) noexcept {
		return Value{ ctx, std::forward<godot::ColorRect>(v) };
	}
};
template <>
struct js_traits<godot::ColorRect &> {
	/// @throws exception
	static godot::ColorRect &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ColorRect *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ColorRect &v) noexcept {
		return Value{ ctx, std::forward<godot::ColorRect>(v) };
	}
};
template <>
struct js_traits<godot::CompressedCubemap> {
	/// @throws exception
	static godot::CompressedCubemap unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CompressedCubemap *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CompressedCubemap v) noexcept {
		return Value{ ctx, std::forward<godot::CompressedCubemap>(v) };
	}
};
template <>
struct js_traits<godot::CompressedCubemap &> {
	/// @throws exception
	static godot::CompressedCubemap &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CompressedCubemap *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CompressedCubemap &v) noexcept {
		return Value{ ctx, std::forward<godot::CompressedCubemap>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::CompressedCubemap>> {
	/// @throws exception
	static godot::Ref<godot::CompressedCubemap> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::CompressedCubemap>((godot::CompressedCubemap *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::CompressedCubemap> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::CompressedCubemap>>(v) };
	}
};
template <>
struct js_traits<godot::CompressedCubemapArray> {
	/// @throws exception
	static godot::CompressedCubemapArray unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CompressedCubemapArray *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CompressedCubemapArray v) noexcept {
		return Value{ ctx, std::forward<godot::CompressedCubemapArray>(v) };
	}
};
template <>
struct js_traits<godot::CompressedCubemapArray &> {
	/// @throws exception
	static godot::CompressedCubemapArray &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CompressedCubemapArray *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CompressedCubemapArray &v) noexcept {
		return Value{ ctx, std::forward<godot::CompressedCubemapArray>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::CompressedCubemapArray>> {
	/// @throws exception
	static godot::Ref<godot::CompressedCubemapArray> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::CompressedCubemapArray>((godot::CompressedCubemapArray *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::CompressedCubemapArray> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::CompressedCubemapArray>>(v) };
	}
};
template <>
struct js_traits<godot::CompressedTexture2D> {
	/// @throws exception
	static godot::CompressedTexture2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CompressedTexture2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CompressedTexture2D v) noexcept {
		return Value{ ctx, std::forward<godot::CompressedTexture2D>(v) };
	}
};
template <>
struct js_traits<godot::CompressedTexture2D &> {
	/// @throws exception
	static godot::CompressedTexture2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CompressedTexture2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CompressedTexture2D &v) noexcept {
		return Value{ ctx, std::forward<godot::CompressedTexture2D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::CompressedTexture2D>> {
	/// @throws exception
	static godot::Ref<godot::CompressedTexture2D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::CompressedTexture2D>((godot::CompressedTexture2D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::CompressedTexture2D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::CompressedTexture2D>>(v) };
	}
};
template <>
struct js_traits<godot::CompressedTexture2DArray> {
	/// @throws exception
	static godot::CompressedTexture2DArray unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CompressedTexture2DArray *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CompressedTexture2DArray v) noexcept {
		return Value{ ctx, std::forward<godot::CompressedTexture2DArray>(v) };
	}
};
template <>
struct js_traits<godot::CompressedTexture2DArray &> {
	/// @throws exception
	static godot::CompressedTexture2DArray &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CompressedTexture2DArray *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CompressedTexture2DArray &v) noexcept {
		return Value{ ctx, std::forward<godot::CompressedTexture2DArray>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::CompressedTexture2DArray>> {
	/// @throws exception
	static godot::Ref<godot::CompressedTexture2DArray> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::CompressedTexture2DArray>((godot::CompressedTexture2DArray *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::CompressedTexture2DArray> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::CompressedTexture2DArray>>(v) };
	}
};
template <>
struct js_traits<godot::CompressedTexture3D> {
	/// @throws exception
	static godot::CompressedTexture3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CompressedTexture3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CompressedTexture3D v) noexcept {
		return Value{ ctx, std::forward<godot::CompressedTexture3D>(v) };
	}
};
template <>
struct js_traits<godot::CompressedTexture3D &> {
	/// @throws exception
	static godot::CompressedTexture3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CompressedTexture3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CompressedTexture3D &v) noexcept {
		return Value{ ctx, std::forward<godot::CompressedTexture3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::CompressedTexture3D>> {
	/// @throws exception
	static godot::Ref<godot::CompressedTexture3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::CompressedTexture3D>((godot::CompressedTexture3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::CompressedTexture3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::CompressedTexture3D>>(v) };
	}
};
template <>
struct js_traits<godot::CompressedTextureLayered> {
	/// @throws exception
	static godot::CompressedTextureLayered unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CompressedTextureLayered *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CompressedTextureLayered v) noexcept {
		return Value{ ctx, std::forward<godot::CompressedTextureLayered>(v) };
	}
};
template <>
struct js_traits<godot::CompressedTextureLayered &> {
	/// @throws exception
	static godot::CompressedTextureLayered &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CompressedTextureLayered *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CompressedTextureLayered &v) noexcept {
		return Value{ ctx, std::forward<godot::CompressedTextureLayered>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::CompressedTextureLayered>> {
	/// @throws exception
	static godot::Ref<godot::CompressedTextureLayered> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::CompressedTextureLayered>((godot::CompressedTextureLayered *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::CompressedTextureLayered> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::CompressedTextureLayered>>(v) };
	}
};
template <>
struct js_traits<godot::ConcavePolygonShape2D> {
	/// @throws exception
	static godot::ConcavePolygonShape2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ConcavePolygonShape2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ConcavePolygonShape2D v) noexcept {
		return Value{ ctx, std::forward<godot::ConcavePolygonShape2D>(v) };
	}
};
template <>
struct js_traits<godot::ConcavePolygonShape2D &> {
	/// @throws exception
	static godot::ConcavePolygonShape2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ConcavePolygonShape2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ConcavePolygonShape2D &v) noexcept {
		return Value{ ctx, std::forward<godot::ConcavePolygonShape2D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ConcavePolygonShape2D>> {
	/// @throws exception
	static godot::Ref<godot::ConcavePolygonShape2D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ConcavePolygonShape2D>((godot::ConcavePolygonShape2D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ConcavePolygonShape2D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ConcavePolygonShape2D>>(v) };
	}
};
template <>
struct js_traits<godot::ConcavePolygonShape3D> {
	/// @throws exception
	static godot::ConcavePolygonShape3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ConcavePolygonShape3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ConcavePolygonShape3D v) noexcept {
		return Value{ ctx, std::forward<godot::ConcavePolygonShape3D>(v) };
	}
};
template <>
struct js_traits<godot::ConcavePolygonShape3D &> {
	/// @throws exception
	static godot::ConcavePolygonShape3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ConcavePolygonShape3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ConcavePolygonShape3D &v) noexcept {
		return Value{ ctx, std::forward<godot::ConcavePolygonShape3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ConcavePolygonShape3D>> {
	/// @throws exception
	static godot::Ref<godot::ConcavePolygonShape3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ConcavePolygonShape3D>((godot::ConcavePolygonShape3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ConcavePolygonShape3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ConcavePolygonShape3D>>(v) };
	}
};
template <>
struct js_traits<godot::ConeTwistJoint3D> {
	/// @throws exception
	static godot::ConeTwistJoint3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ConeTwistJoint3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ConeTwistJoint3D v) noexcept {
		return Value{ ctx, std::forward<godot::ConeTwistJoint3D>(v) };
	}
};
template <>
struct js_traits<godot::ConeTwistJoint3D &> {
	/// @throws exception
	static godot::ConeTwistJoint3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ConeTwistJoint3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ConeTwistJoint3D &v) noexcept {
		return Value{ ctx, std::forward<godot::ConeTwistJoint3D>(v) };
	}
};
template <>
struct js_traits<godot::ConfigFile> {
	/// @throws exception
	static godot::ConfigFile unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ConfigFile *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ConfigFile v) noexcept {
		return Value{ ctx, std::forward<godot::ConfigFile>(v) };
	}
};
template <>
struct js_traits<godot::ConfigFile &> {
	/// @throws exception
	static godot::ConfigFile &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ConfigFile *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ConfigFile &v) noexcept {
		return Value{ ctx, std::forward<godot::ConfigFile>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ConfigFile>> {
	/// @throws exception
	static godot::Ref<godot::ConfigFile> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ConfigFile>((godot::ConfigFile *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ConfigFile> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ConfigFile>>(v) };
	}
};
template <>
struct js_traits<godot::ConfirmationDialog> {
	/// @throws exception
	static godot::ConfirmationDialog unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ConfirmationDialog *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ConfirmationDialog v) noexcept {
		return Value{ ctx, std::forward<godot::ConfirmationDialog>(v) };
	}
};
template <>
struct js_traits<godot::ConfirmationDialog &> {
	/// @throws exception
	static godot::ConfirmationDialog &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ConfirmationDialog *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ConfirmationDialog &v) noexcept {
		return Value{ ctx, std::forward<godot::ConfirmationDialog>(v) };
	}
};
template <>
struct js_traits<godot::Container> {
	/// @throws exception
	static godot::Container unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Container *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Container v) noexcept {
		return Value{ ctx, std::forward<godot::Container>(v) };
	}
};
template <>
struct js_traits<godot::Container &> {
	/// @throws exception
	static godot::Container &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Container *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Container &v) noexcept {
		return Value{ ctx, std::forward<godot::Container>(v) };
	}
};
template <>
struct js_traits<godot::Control> {
	/// @throws exception
	static godot::Control unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Control *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Control v) noexcept {
		return Value{ ctx, std::forward<godot::Control>(v) };
	}
};
template <>
struct js_traits<godot::Control &> {
	/// @throws exception
	static godot::Control &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Control *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Control &v) noexcept {
		return Value{ ctx, std::forward<godot::Control>(v) };
	}
};
template <>
struct js_traits<godot::ConvexPolygonShape2D> {
	/// @throws exception
	static godot::ConvexPolygonShape2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ConvexPolygonShape2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ConvexPolygonShape2D v) noexcept {
		return Value{ ctx, std::forward<godot::ConvexPolygonShape2D>(v) };
	}
};
template <>
struct js_traits<godot::ConvexPolygonShape2D &> {
	/// @throws exception
	static godot::ConvexPolygonShape2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ConvexPolygonShape2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ConvexPolygonShape2D &v) noexcept {
		return Value{ ctx, std::forward<godot::ConvexPolygonShape2D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ConvexPolygonShape2D>> {
	/// @throws exception
	static godot::Ref<godot::ConvexPolygonShape2D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ConvexPolygonShape2D>((godot::ConvexPolygonShape2D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ConvexPolygonShape2D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ConvexPolygonShape2D>>(v) };
	}
};
template <>
struct js_traits<godot::ConvexPolygonShape3D> {
	/// @throws exception
	static godot::ConvexPolygonShape3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ConvexPolygonShape3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ConvexPolygonShape3D v) noexcept {
		return Value{ ctx, std::forward<godot::ConvexPolygonShape3D>(v) };
	}
};
template <>
struct js_traits<godot::ConvexPolygonShape3D &> {
	/// @throws exception
	static godot::ConvexPolygonShape3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ConvexPolygonShape3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ConvexPolygonShape3D &v) noexcept {
		return Value{ ctx, std::forward<godot::ConvexPolygonShape3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ConvexPolygonShape3D>> {
	/// @throws exception
	static godot::Ref<godot::ConvexPolygonShape3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ConvexPolygonShape3D>((godot::ConvexPolygonShape3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ConvexPolygonShape3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ConvexPolygonShape3D>>(v) };
	}
};
template <>
struct js_traits<godot::Crypto> {
	/// @throws exception
	static godot::Crypto unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Crypto *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Crypto v) noexcept {
		return Value{ ctx, std::forward<godot::Crypto>(v) };
	}
};
template <>
struct js_traits<godot::Crypto &> {
	/// @throws exception
	static godot::Crypto &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Crypto *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Crypto &v) noexcept {
		return Value{ ctx, std::forward<godot::Crypto>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Crypto>> {
	/// @throws exception
	static godot::Ref<godot::Crypto> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Crypto>((godot::Crypto *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Crypto> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Crypto>>(v) };
	}
};
template <>
struct js_traits<godot::CryptoKey> {
	/// @throws exception
	static godot::CryptoKey unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CryptoKey *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CryptoKey v) noexcept {
		return Value{ ctx, std::forward<godot::CryptoKey>(v) };
	}
};
template <>
struct js_traits<godot::CryptoKey &> {
	/// @throws exception
	static godot::CryptoKey &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CryptoKey *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CryptoKey &v) noexcept {
		return Value{ ctx, std::forward<godot::CryptoKey>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::CryptoKey>> {
	/// @throws exception
	static godot::Ref<godot::CryptoKey> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::CryptoKey>((godot::CryptoKey *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::CryptoKey> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::CryptoKey>>(v) };
	}
};
template <>
struct js_traits<godot::Cubemap> {
	/// @throws exception
	static godot::Cubemap unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Cubemap *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Cubemap v) noexcept {
		return Value{ ctx, std::forward<godot::Cubemap>(v) };
	}
};
template <>
struct js_traits<godot::Cubemap &> {
	/// @throws exception
	static godot::Cubemap &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Cubemap *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Cubemap &v) noexcept {
		return Value{ ctx, std::forward<godot::Cubemap>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Cubemap>> {
	/// @throws exception
	static godot::Ref<godot::Cubemap> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Cubemap>((godot::Cubemap *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Cubemap> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Cubemap>>(v) };
	}
};
template <>
struct js_traits<godot::CubemapArray> {
	/// @throws exception
	static godot::CubemapArray unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CubemapArray *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CubemapArray v) noexcept {
		return Value{ ctx, std::forward<godot::CubemapArray>(v) };
	}
};
template <>
struct js_traits<godot::CubemapArray &> {
	/// @throws exception
	static godot::CubemapArray &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CubemapArray *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CubemapArray &v) noexcept {
		return Value{ ctx, std::forward<godot::CubemapArray>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::CubemapArray>> {
	/// @throws exception
	static godot::Ref<godot::CubemapArray> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::CubemapArray>((godot::CubemapArray *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::CubemapArray> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::CubemapArray>>(v) };
	}
};
template <>
struct js_traits<godot::Curve> {
	/// @throws exception
	static godot::Curve unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Curve *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Curve v) noexcept {
		return Value{ ctx, std::forward<godot::Curve>(v) };
	}
};
template <>
struct js_traits<godot::Curve &> {
	/// @throws exception
	static godot::Curve &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Curve *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Curve &v) noexcept {
		return Value{ ctx, std::forward<godot::Curve>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Curve>> {
	/// @throws exception
	static godot::Ref<godot::Curve> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Curve>((godot::Curve *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Curve> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Curve>>(v) };
	}
};
template <>
struct js_traits<godot::Curve2D> {
	/// @throws exception
	static godot::Curve2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Curve2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Curve2D v) noexcept {
		return Value{ ctx, std::forward<godot::Curve2D>(v) };
	}
};
template <>
struct js_traits<godot::Curve2D &> {
	/// @throws exception
	static godot::Curve2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Curve2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Curve2D &v) noexcept {
		return Value{ ctx, std::forward<godot::Curve2D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Curve2D>> {
	/// @throws exception
	static godot::Ref<godot::Curve2D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Curve2D>((godot::Curve2D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Curve2D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Curve2D>>(v) };
	}
};
template <>
struct js_traits<godot::Curve3D> {
	/// @throws exception
	static godot::Curve3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Curve3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Curve3D v) noexcept {
		return Value{ ctx, std::forward<godot::Curve3D>(v) };
	}
};
template <>
struct js_traits<godot::Curve3D &> {
	/// @throws exception
	static godot::Curve3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Curve3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Curve3D &v) noexcept {
		return Value{ ctx, std::forward<godot::Curve3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Curve3D>> {
	/// @throws exception
	static godot::Ref<godot::Curve3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Curve3D>((godot::Curve3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Curve3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Curve3D>>(v) };
	}
};
template <>
struct js_traits<godot::CurveTexture> {
	/// @throws exception
	static godot::CurveTexture unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CurveTexture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CurveTexture v) noexcept {
		return Value{ ctx, std::forward<godot::CurveTexture>(v) };
	}
};
template <>
struct js_traits<godot::CurveTexture &> {
	/// @throws exception
	static godot::CurveTexture &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CurveTexture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CurveTexture &v) noexcept {
		return Value{ ctx, std::forward<godot::CurveTexture>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::CurveTexture>> {
	/// @throws exception
	static godot::Ref<godot::CurveTexture> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::CurveTexture>((godot::CurveTexture *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::CurveTexture> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::CurveTexture>>(v) };
	}
};
template <>
struct js_traits<godot::CurveXYZTexture> {
	/// @throws exception
	static godot::CurveXYZTexture unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CurveXYZTexture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CurveXYZTexture v) noexcept {
		return Value{ ctx, std::forward<godot::CurveXYZTexture>(v) };
	}
};
template <>
struct js_traits<godot::CurveXYZTexture &> {
	/// @throws exception
	static godot::CurveXYZTexture &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CurveXYZTexture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CurveXYZTexture &v) noexcept {
		return Value{ ctx, std::forward<godot::CurveXYZTexture>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::CurveXYZTexture>> {
	/// @throws exception
	static godot::Ref<godot::CurveXYZTexture> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::CurveXYZTexture>((godot::CurveXYZTexture *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::CurveXYZTexture> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::CurveXYZTexture>>(v) };
	}
};
template <>
struct js_traits<godot::CylinderMesh> {
	/// @throws exception
	static godot::CylinderMesh unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CylinderMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CylinderMesh v) noexcept {
		return Value{ ctx, std::forward<godot::CylinderMesh>(v) };
	}
};
template <>
struct js_traits<godot::CylinderMesh &> {
	/// @throws exception
	static godot::CylinderMesh &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CylinderMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CylinderMesh &v) noexcept {
		return Value{ ctx, std::forward<godot::CylinderMesh>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::CylinderMesh>> {
	/// @throws exception
	static godot::Ref<godot::CylinderMesh> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::CylinderMesh>((godot::CylinderMesh *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::CylinderMesh> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::CylinderMesh>>(v) };
	}
};
template <>
struct js_traits<godot::CylinderShape3D> {
	/// @throws exception
	static godot::CylinderShape3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CylinderShape3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CylinderShape3D v) noexcept {
		return Value{ ctx, std::forward<godot::CylinderShape3D>(v) };
	}
};
template <>
struct js_traits<godot::CylinderShape3D &> {
	/// @throws exception
	static godot::CylinderShape3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::CylinderShape3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::CylinderShape3D &v) noexcept {
		return Value{ ctx, std::forward<godot::CylinderShape3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::CylinderShape3D>> {
	/// @throws exception
	static godot::Ref<godot::CylinderShape3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::CylinderShape3D>((godot::CylinderShape3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::CylinderShape3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::CylinderShape3D>>(v) };
	}
};
template <>
struct js_traits<godot::DTLSServer> {
	/// @throws exception
	static godot::DTLSServer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::DTLSServer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::DTLSServer v) noexcept {
		return Value{ ctx, std::forward<godot::DTLSServer>(v) };
	}
};
template <>
struct js_traits<godot::DTLSServer &> {
	/// @throws exception
	static godot::DTLSServer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::DTLSServer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::DTLSServer &v) noexcept {
		return Value{ ctx, std::forward<godot::DTLSServer>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::DTLSServer>> {
	/// @throws exception
	static godot::Ref<godot::DTLSServer> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::DTLSServer>((godot::DTLSServer *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::DTLSServer> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::DTLSServer>>(v) };
	}
};
template <>
struct js_traits<godot::DampedSpringJoint2D> {
	/// @throws exception
	static godot::DampedSpringJoint2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::DampedSpringJoint2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::DampedSpringJoint2D v) noexcept {
		return Value{ ctx, std::forward<godot::DampedSpringJoint2D>(v) };
	}
};
template <>
struct js_traits<godot::DampedSpringJoint2D &> {
	/// @throws exception
	static godot::DampedSpringJoint2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::DampedSpringJoint2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::DampedSpringJoint2D &v) noexcept {
		return Value{ ctx, std::forward<godot::DampedSpringJoint2D>(v) };
	}
};
template <>
struct js_traits<godot::Decal> {
	/// @throws exception
	static godot::Decal unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Decal *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Decal v) noexcept {
		return Value{ ctx, std::forward<godot::Decal>(v) };
	}
};
template <>
struct js_traits<godot::Decal &> {
	/// @throws exception
	static godot::Decal &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Decal *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Decal &v) noexcept {
		return Value{ ctx, std::forward<godot::Decal>(v) };
	}
};
template <>
struct js_traits<godot::DirAccess> {
	/// @throws exception
	static godot::DirAccess unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::DirAccess *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::DirAccess v) noexcept {
		return Value{ ctx, std::forward<godot::DirAccess>(v) };
	}
};
template <>
struct js_traits<godot::DirAccess &> {
	/// @throws exception
	static godot::DirAccess &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::DirAccess *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::DirAccess &v) noexcept {
		return Value{ ctx, std::forward<godot::DirAccess>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::DirAccess>> {
	/// @throws exception
	static godot::Ref<godot::DirAccess> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::DirAccess>((godot::DirAccess *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::DirAccess> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::DirAccess>>(v) };
	}
};
template <>
struct js_traits<godot::DirectionalLight2D> {
	/// @throws exception
	static godot::DirectionalLight2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::DirectionalLight2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::DirectionalLight2D v) noexcept {
		return Value{ ctx, std::forward<godot::DirectionalLight2D>(v) };
	}
};
template <>
struct js_traits<godot::DirectionalLight2D &> {
	/// @throws exception
	static godot::DirectionalLight2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::DirectionalLight2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::DirectionalLight2D &v) noexcept {
		return Value{ ctx, std::forward<godot::DirectionalLight2D>(v) };
	}
};
template <>
struct js_traits<godot::DirectionalLight3D> {
	/// @throws exception
	static godot::DirectionalLight3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::DirectionalLight3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::DirectionalLight3D v) noexcept {
		return Value{ ctx, std::forward<godot::DirectionalLight3D>(v) };
	}
};
template <>
struct js_traits<godot::DirectionalLight3D &> {
	/// @throws exception
	static godot::DirectionalLight3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::DirectionalLight3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::DirectionalLight3D &v) noexcept {
		return Value{ ctx, std::forward<godot::DirectionalLight3D>(v) };
	}
};
template <>
struct js_traits<godot::DisplayServer> {
	/// @throws exception
	static godot::DisplayServer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::DisplayServer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::DisplayServer v) noexcept {
		return Value{ ctx, std::forward<godot::DisplayServer>(v) };
	}
};
template <>
struct js_traits<godot::DisplayServer &> {
	/// @throws exception
	static godot::DisplayServer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::DisplayServer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::DisplayServer &v) noexcept {
		return Value{ ctx, std::forward<godot::DisplayServer>(v) };
	}
};
template <>
struct js_traits<godot::ENetConnection> {
	/// @throws exception
	static godot::ENetConnection unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ENetConnection *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ENetConnection v) noexcept {
		return Value{ ctx, std::forward<godot::ENetConnection>(v) };
	}
};
template <>
struct js_traits<godot::ENetConnection &> {
	/// @throws exception
	static godot::ENetConnection &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ENetConnection *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ENetConnection &v) noexcept {
		return Value{ ctx, std::forward<godot::ENetConnection>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ENetConnection>> {
	/// @throws exception
	static godot::Ref<godot::ENetConnection> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ENetConnection>((godot::ENetConnection *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ENetConnection> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ENetConnection>>(v) };
	}
};
template <>
struct js_traits<godot::ENetMultiplayerPeer> {
	/// @throws exception
	static godot::ENetMultiplayerPeer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ENetMultiplayerPeer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ENetMultiplayerPeer v) noexcept {
		return Value{ ctx, std::forward<godot::ENetMultiplayerPeer>(v) };
	}
};
template <>
struct js_traits<godot::ENetMultiplayerPeer &> {
	/// @throws exception
	static godot::ENetMultiplayerPeer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ENetMultiplayerPeer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ENetMultiplayerPeer &v) noexcept {
		return Value{ ctx, std::forward<godot::ENetMultiplayerPeer>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ENetMultiplayerPeer>> {
	/// @throws exception
	static godot::Ref<godot::ENetMultiplayerPeer> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ENetMultiplayerPeer>((godot::ENetMultiplayerPeer *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ENetMultiplayerPeer> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ENetMultiplayerPeer>>(v) };
	}
};
template <>
struct js_traits<godot::ENetPacketPeer> {
	/// @throws exception
	static godot::ENetPacketPeer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ENetPacketPeer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ENetPacketPeer v) noexcept {
		return Value{ ctx, std::forward<godot::ENetPacketPeer>(v) };
	}
};
template <>
struct js_traits<godot::ENetPacketPeer &> {
	/// @throws exception
	static godot::ENetPacketPeer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ENetPacketPeer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ENetPacketPeer &v) noexcept {
		return Value{ ctx, std::forward<godot::ENetPacketPeer>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ENetPacketPeer>> {
	/// @throws exception
	static godot::Ref<godot::ENetPacketPeer> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ENetPacketPeer>((godot::ENetPacketPeer *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ENetPacketPeer> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ENetPacketPeer>>(v) };
	}
};
template <>
struct js_traits<godot::EditorCommandPalette> {
	/// @throws exception
	static godot::EditorCommandPalette unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorCommandPalette *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorCommandPalette v) noexcept {
		return Value{ ctx, std::forward<godot::EditorCommandPalette>(v) };
	}
};
template <>
struct js_traits<godot::EditorCommandPalette &> {
	/// @throws exception
	static godot::EditorCommandPalette &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorCommandPalette *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorCommandPalette &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorCommandPalette>(v) };
	}
};
template <>
struct js_traits<godot::EditorDebuggerPlugin> {
	/// @throws exception
	static godot::EditorDebuggerPlugin unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorDebuggerPlugin *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorDebuggerPlugin v) noexcept {
		return Value{ ctx, std::forward<godot::EditorDebuggerPlugin>(v) };
	}
};
template <>
struct js_traits<godot::EditorDebuggerPlugin &> {
	/// @throws exception
	static godot::EditorDebuggerPlugin &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorDebuggerPlugin *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorDebuggerPlugin &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorDebuggerPlugin>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::EditorDebuggerPlugin>> {
	/// @throws exception
	static godot::Ref<godot::EditorDebuggerPlugin> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::EditorDebuggerPlugin>((godot::EditorDebuggerPlugin *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::EditorDebuggerPlugin> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::EditorDebuggerPlugin>>(v) };
	}
};
template <>
struct js_traits<godot::EditorDebuggerSession> {
	/// @throws exception
	static godot::EditorDebuggerSession unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorDebuggerSession *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorDebuggerSession v) noexcept {
		return Value{ ctx, std::forward<godot::EditorDebuggerSession>(v) };
	}
};
template <>
struct js_traits<godot::EditorDebuggerSession &> {
	/// @throws exception
	static godot::EditorDebuggerSession &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorDebuggerSession *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorDebuggerSession &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorDebuggerSession>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::EditorDebuggerSession>> {
	/// @throws exception
	static godot::Ref<godot::EditorDebuggerSession> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::EditorDebuggerSession>((godot::EditorDebuggerSession *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::EditorDebuggerSession> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::EditorDebuggerSession>>(v) };
	}
};
template <>
struct js_traits<godot::EditorExportPlatform> {
	/// @throws exception
	static godot::EditorExportPlatform unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorExportPlatform *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorExportPlatform v) noexcept {
		return Value{ ctx, std::forward<godot::EditorExportPlatform>(v) };
	}
};
template <>
struct js_traits<godot::EditorExportPlatform &> {
	/// @throws exception
	static godot::EditorExportPlatform &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorExportPlatform *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorExportPlatform &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorExportPlatform>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::EditorExportPlatform>> {
	/// @throws exception
	static godot::Ref<godot::EditorExportPlatform> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::EditorExportPlatform>((godot::EditorExportPlatform *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::EditorExportPlatform> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::EditorExportPlatform>>(v) };
	}
};
template <>
struct js_traits<godot::EditorExportPlatformAndroid> {
	/// @throws exception
	static godot::EditorExportPlatformAndroid unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorExportPlatformAndroid *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorExportPlatformAndroid v) noexcept {
		return Value{ ctx, std::forward<godot::EditorExportPlatformAndroid>(v) };
	}
};
template <>
struct js_traits<godot::EditorExportPlatformAndroid &> {
	/// @throws exception
	static godot::EditorExportPlatformAndroid &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorExportPlatformAndroid *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorExportPlatformAndroid &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorExportPlatformAndroid>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::EditorExportPlatformAndroid>> {
	/// @throws exception
	static godot::Ref<godot::EditorExportPlatformAndroid> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::EditorExportPlatformAndroid>((godot::EditorExportPlatformAndroid *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::EditorExportPlatformAndroid> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::EditorExportPlatformAndroid>>(v) };
	}
};
template <>
struct js_traits<godot::EditorExportPlatformIOS> {
	/// @throws exception
	static godot::EditorExportPlatformIOS unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorExportPlatformIOS *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorExportPlatformIOS v) noexcept {
		return Value{ ctx, std::forward<godot::EditorExportPlatformIOS>(v) };
	}
};
template <>
struct js_traits<godot::EditorExportPlatformIOS &> {
	/// @throws exception
	static godot::EditorExportPlatformIOS &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorExportPlatformIOS *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorExportPlatformIOS &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorExportPlatformIOS>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::EditorExportPlatformIOS>> {
	/// @throws exception
	static godot::Ref<godot::EditorExportPlatformIOS> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::EditorExportPlatformIOS>((godot::EditorExportPlatformIOS *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::EditorExportPlatformIOS> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::EditorExportPlatformIOS>>(v) };
	}
};
template <>
struct js_traits<godot::EditorExportPlatformLinuxBSD> {
	/// @throws exception
	static godot::EditorExportPlatformLinuxBSD unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorExportPlatformLinuxBSD *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorExportPlatformLinuxBSD v) noexcept {
		return Value{ ctx, std::forward<godot::EditorExportPlatformLinuxBSD>(v) };
	}
};
template <>
struct js_traits<godot::EditorExportPlatformLinuxBSD &> {
	/// @throws exception
	static godot::EditorExportPlatformLinuxBSD &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorExportPlatformLinuxBSD *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorExportPlatformLinuxBSD &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorExportPlatformLinuxBSD>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::EditorExportPlatformLinuxBSD>> {
	/// @throws exception
	static godot::Ref<godot::EditorExportPlatformLinuxBSD> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::EditorExportPlatformLinuxBSD>((godot::EditorExportPlatformLinuxBSD *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::EditorExportPlatformLinuxBSD> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::EditorExportPlatformLinuxBSD>>(v) };
	}
};
template <>
struct js_traits<godot::EditorExportPlatformMacOS> {
	/// @throws exception
	static godot::EditorExportPlatformMacOS unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorExportPlatformMacOS *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorExportPlatformMacOS v) noexcept {
		return Value{ ctx, std::forward<godot::EditorExportPlatformMacOS>(v) };
	}
};
template <>
struct js_traits<godot::EditorExportPlatformMacOS &> {
	/// @throws exception
	static godot::EditorExportPlatformMacOS &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorExportPlatformMacOS *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorExportPlatformMacOS &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorExportPlatformMacOS>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::EditorExportPlatformMacOS>> {
	/// @throws exception
	static godot::Ref<godot::EditorExportPlatformMacOS> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::EditorExportPlatformMacOS>((godot::EditorExportPlatformMacOS *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::EditorExportPlatformMacOS> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::EditorExportPlatformMacOS>>(v) };
	}
};
template <>
struct js_traits<godot::EditorExportPlatformPC> {
	/// @throws exception
	static godot::EditorExportPlatformPC unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorExportPlatformPC *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorExportPlatformPC v) noexcept {
		return Value{ ctx, std::forward<godot::EditorExportPlatformPC>(v) };
	}
};
template <>
struct js_traits<godot::EditorExportPlatformPC &> {
	/// @throws exception
	static godot::EditorExportPlatformPC &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorExportPlatformPC *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorExportPlatformPC &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorExportPlatformPC>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::EditorExportPlatformPC>> {
	/// @throws exception
	static godot::Ref<godot::EditorExportPlatformPC> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::EditorExportPlatformPC>((godot::EditorExportPlatformPC *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::EditorExportPlatformPC> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::EditorExportPlatformPC>>(v) };
	}
};
template <>
struct js_traits<godot::EditorExportPlatformWeb> {
	/// @throws exception
	static godot::EditorExportPlatformWeb unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorExportPlatformWeb *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorExportPlatformWeb v) noexcept {
		return Value{ ctx, std::forward<godot::EditorExportPlatformWeb>(v) };
	}
};
template <>
struct js_traits<godot::EditorExportPlatformWeb &> {
	/// @throws exception
	static godot::EditorExportPlatformWeb &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorExportPlatformWeb *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorExportPlatformWeb &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorExportPlatformWeb>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::EditorExportPlatformWeb>> {
	/// @throws exception
	static godot::Ref<godot::EditorExportPlatformWeb> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::EditorExportPlatformWeb>((godot::EditorExportPlatformWeb *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::EditorExportPlatformWeb> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::EditorExportPlatformWeb>>(v) };
	}
};
template <>
struct js_traits<godot::EditorExportPlatformWindows> {
	/// @throws exception
	static godot::EditorExportPlatformWindows unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorExportPlatformWindows *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorExportPlatformWindows v) noexcept {
		return Value{ ctx, std::forward<godot::EditorExportPlatformWindows>(v) };
	}
};
template <>
struct js_traits<godot::EditorExportPlatformWindows &> {
	/// @throws exception
	static godot::EditorExportPlatformWindows &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorExportPlatformWindows *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorExportPlatformWindows &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorExportPlatformWindows>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::EditorExportPlatformWindows>> {
	/// @throws exception
	static godot::Ref<godot::EditorExportPlatformWindows> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::EditorExportPlatformWindows>((godot::EditorExportPlatformWindows *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::EditorExportPlatformWindows> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::EditorExportPlatformWindows>>(v) };
	}
};
template <>
struct js_traits<godot::EditorExportPlugin> {
	/// @throws exception
	static godot::EditorExportPlugin unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorExportPlugin *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorExportPlugin v) noexcept {
		return Value{ ctx, std::forward<godot::EditorExportPlugin>(v) };
	}
};
template <>
struct js_traits<godot::EditorExportPlugin &> {
	/// @throws exception
	static godot::EditorExportPlugin &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorExportPlugin *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorExportPlugin &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorExportPlugin>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::EditorExportPlugin>> {
	/// @throws exception
	static godot::Ref<godot::EditorExportPlugin> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::EditorExportPlugin>((godot::EditorExportPlugin *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::EditorExportPlugin> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::EditorExportPlugin>>(v) };
	}
};
template <>
struct js_traits<godot::EditorFeatureProfile> {
	/// @throws exception
	static godot::EditorFeatureProfile unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorFeatureProfile *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorFeatureProfile v) noexcept {
		return Value{ ctx, std::forward<godot::EditorFeatureProfile>(v) };
	}
};
template <>
struct js_traits<godot::EditorFeatureProfile &> {
	/// @throws exception
	static godot::EditorFeatureProfile &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorFeatureProfile *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorFeatureProfile &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorFeatureProfile>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::EditorFeatureProfile>> {
	/// @throws exception
	static godot::Ref<godot::EditorFeatureProfile> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::EditorFeatureProfile>((godot::EditorFeatureProfile *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::EditorFeatureProfile> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::EditorFeatureProfile>>(v) };
	}
};
template <>
struct js_traits<godot::EditorFileDialog> {
	/// @throws exception
	static godot::EditorFileDialog unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorFileDialog *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorFileDialog v) noexcept {
		return Value{ ctx, std::forward<godot::EditorFileDialog>(v) };
	}
};
template <>
struct js_traits<godot::EditorFileDialog &> {
	/// @throws exception
	static godot::EditorFileDialog &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorFileDialog *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorFileDialog &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorFileDialog>(v) };
	}
};
template <>
struct js_traits<godot::EditorFileSystem> {
	/// @throws exception
	static godot::EditorFileSystem unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorFileSystem *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorFileSystem v) noexcept {
		return Value{ ctx, std::forward<godot::EditorFileSystem>(v) };
	}
};
template <>
struct js_traits<godot::EditorFileSystem &> {
	/// @throws exception
	static godot::EditorFileSystem &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorFileSystem *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorFileSystem &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorFileSystem>(v) };
	}
};
template <>
struct js_traits<godot::EditorFileSystemDirectory> {
	/// @throws exception
	static godot::EditorFileSystemDirectory unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorFileSystemDirectory *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorFileSystemDirectory v) noexcept {
		return Value{ ctx, std::forward<godot::EditorFileSystemDirectory>(v) };
	}
};
template <>
struct js_traits<godot::EditorFileSystemDirectory &> {
	/// @throws exception
	static godot::EditorFileSystemDirectory &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorFileSystemDirectory *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorFileSystemDirectory &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorFileSystemDirectory>(v) };
	}
};
template <>
struct js_traits<godot::EditorFileSystemImportFormatSupportQuery> {
	/// @throws exception
	static godot::EditorFileSystemImportFormatSupportQuery unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorFileSystemImportFormatSupportQuery *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorFileSystemImportFormatSupportQuery v) noexcept {
		return Value{ ctx, std::forward<godot::EditorFileSystemImportFormatSupportQuery>(v) };
	}
};
template <>
struct js_traits<godot::EditorFileSystemImportFormatSupportQuery &> {
	/// @throws exception
	static godot::EditorFileSystemImportFormatSupportQuery &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorFileSystemImportFormatSupportQuery *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorFileSystemImportFormatSupportQuery &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorFileSystemImportFormatSupportQuery>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::EditorFileSystemImportFormatSupportQuery>> {
	/// @throws exception
	static godot::Ref<godot::EditorFileSystemImportFormatSupportQuery> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::EditorFileSystemImportFormatSupportQuery>((godot::EditorFileSystemImportFormatSupportQuery *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::EditorFileSystemImportFormatSupportQuery> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::EditorFileSystemImportFormatSupportQuery>>(v) };
	}
};
template <>
struct js_traits<godot::EditorImportPlugin> {
	/// @throws exception
	static godot::EditorImportPlugin unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorImportPlugin *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorImportPlugin v) noexcept {
		return Value{ ctx, std::forward<godot::EditorImportPlugin>(v) };
	}
};
template <>
struct js_traits<godot::EditorImportPlugin &> {
	/// @throws exception
	static godot::EditorImportPlugin &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorImportPlugin *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorImportPlugin &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorImportPlugin>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::EditorImportPlugin>> {
	/// @throws exception
	static godot::Ref<godot::EditorImportPlugin> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::EditorImportPlugin>((godot::EditorImportPlugin *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::EditorImportPlugin> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::EditorImportPlugin>>(v) };
	}
};
template <>
struct js_traits<godot::EditorInspector> {
	/// @throws exception
	static godot::EditorInspector unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorInspector *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorInspector v) noexcept {
		return Value{ ctx, std::forward<godot::EditorInspector>(v) };
	}
};
template <>
struct js_traits<godot::EditorInspector &> {
	/// @throws exception
	static godot::EditorInspector &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorInspector *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorInspector &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorInspector>(v) };
	}
};
template <>
struct js_traits<godot::EditorInspectorPlugin> {
	/// @throws exception
	static godot::EditorInspectorPlugin unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorInspectorPlugin *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorInspectorPlugin v) noexcept {
		return Value{ ctx, std::forward<godot::EditorInspectorPlugin>(v) };
	}
};
template <>
struct js_traits<godot::EditorInspectorPlugin &> {
	/// @throws exception
	static godot::EditorInspectorPlugin &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorInspectorPlugin *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorInspectorPlugin &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorInspectorPlugin>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::EditorInspectorPlugin>> {
	/// @throws exception
	static godot::Ref<godot::EditorInspectorPlugin> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::EditorInspectorPlugin>((godot::EditorInspectorPlugin *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::EditorInspectorPlugin> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::EditorInspectorPlugin>>(v) };
	}
};
template <>
struct js_traits<godot::EditorInterface> {
	/// @throws exception
	static godot::EditorInterface unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorInterface *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorInterface v) noexcept {
		return Value{ ctx, std::forward<godot::EditorInterface>(v) };
	}
};
template <>
struct js_traits<godot::EditorInterface &> {
	/// @throws exception
	static godot::EditorInterface &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorInterface *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorInterface &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorInterface>(v) };
	}
};
template <>
struct js_traits<godot::EditorNode3DGizmo> {
	/// @throws exception
	static godot::EditorNode3DGizmo unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorNode3DGizmo *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorNode3DGizmo v) noexcept {
		return Value{ ctx, std::forward<godot::EditorNode3DGizmo>(v) };
	}
};
template <>
struct js_traits<godot::EditorNode3DGizmo &> {
	/// @throws exception
	static godot::EditorNode3DGizmo &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorNode3DGizmo *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorNode3DGizmo &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorNode3DGizmo>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::EditorNode3DGizmo>> {
	/// @throws exception
	static godot::Ref<godot::EditorNode3DGizmo> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::EditorNode3DGizmo>((godot::EditorNode3DGizmo *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::EditorNode3DGizmo> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::EditorNode3DGizmo>>(v) };
	}
};
template <>
struct js_traits<godot::EditorNode3DGizmoPlugin> {
	/// @throws exception
	static godot::EditorNode3DGizmoPlugin unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorNode3DGizmoPlugin *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorNode3DGizmoPlugin v) noexcept {
		return Value{ ctx, std::forward<godot::EditorNode3DGizmoPlugin>(v) };
	}
};
template <>
struct js_traits<godot::EditorNode3DGizmoPlugin &> {
	/// @throws exception
	static godot::EditorNode3DGizmoPlugin &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorNode3DGizmoPlugin *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorNode3DGizmoPlugin &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorNode3DGizmoPlugin>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::EditorNode3DGizmoPlugin>> {
	/// @throws exception
	static godot::Ref<godot::EditorNode3DGizmoPlugin> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::EditorNode3DGizmoPlugin>((godot::EditorNode3DGizmoPlugin *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::EditorNode3DGizmoPlugin> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::EditorNode3DGizmoPlugin>>(v) };
	}
};
template <>
struct js_traits<godot::EditorPaths> {
	/// @throws exception
	static godot::EditorPaths unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorPaths *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorPaths v) noexcept {
		return Value{ ctx, std::forward<godot::EditorPaths>(v) };
	}
};
template <>
struct js_traits<godot::EditorPaths &> {
	/// @throws exception
	static godot::EditorPaths &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorPaths *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorPaths &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorPaths>(v) };
	}
};
template <>
struct js_traits<godot::EditorPlugin> {
	/// @throws exception
	static godot::EditorPlugin unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorPlugin *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorPlugin v) noexcept {
		return Value{ ctx, std::forward<godot::EditorPlugin>(v) };
	}
};
template <>
struct js_traits<godot::EditorPlugin &> {
	/// @throws exception
	static godot::EditorPlugin &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorPlugin *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorPlugin &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorPlugin>(v) };
	}
};
template <>
struct js_traits<godot::EditorProperty> {
	/// @throws exception
	static godot::EditorProperty unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorProperty *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorProperty v) noexcept {
		return Value{ ctx, std::forward<godot::EditorProperty>(v) };
	}
};
template <>
struct js_traits<godot::EditorProperty &> {
	/// @throws exception
	static godot::EditorProperty &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorProperty *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorProperty &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorProperty>(v) };
	}
};
template <>
struct js_traits<godot::EditorResourceConversionPlugin> {
	/// @throws exception
	static godot::EditorResourceConversionPlugin unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorResourceConversionPlugin *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorResourceConversionPlugin v) noexcept {
		return Value{ ctx, std::forward<godot::EditorResourceConversionPlugin>(v) };
	}
};
template <>
struct js_traits<godot::EditorResourceConversionPlugin &> {
	/// @throws exception
	static godot::EditorResourceConversionPlugin &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorResourceConversionPlugin *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorResourceConversionPlugin &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorResourceConversionPlugin>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::EditorResourceConversionPlugin>> {
	/// @throws exception
	static godot::Ref<godot::EditorResourceConversionPlugin> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::EditorResourceConversionPlugin>((godot::EditorResourceConversionPlugin *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::EditorResourceConversionPlugin> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::EditorResourceConversionPlugin>>(v) };
	}
};
template <>
struct js_traits<godot::EditorResourcePicker> {
	/// @throws exception
	static godot::EditorResourcePicker unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorResourcePicker *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorResourcePicker v) noexcept {
		return Value{ ctx, std::forward<godot::EditorResourcePicker>(v) };
	}
};
template <>
struct js_traits<godot::EditorResourcePicker &> {
	/// @throws exception
	static godot::EditorResourcePicker &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorResourcePicker *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorResourcePicker &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorResourcePicker>(v) };
	}
};
template <>
struct js_traits<godot::EditorResourcePreview> {
	/// @throws exception
	static godot::EditorResourcePreview unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorResourcePreview *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorResourcePreview v) noexcept {
		return Value{ ctx, std::forward<godot::EditorResourcePreview>(v) };
	}
};
template <>
struct js_traits<godot::EditorResourcePreview &> {
	/// @throws exception
	static godot::EditorResourcePreview &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorResourcePreview *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorResourcePreview &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorResourcePreview>(v) };
	}
};
template <>
struct js_traits<godot::EditorResourcePreviewGenerator> {
	/// @throws exception
	static godot::EditorResourcePreviewGenerator unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorResourcePreviewGenerator *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorResourcePreviewGenerator v) noexcept {
		return Value{ ctx, std::forward<godot::EditorResourcePreviewGenerator>(v) };
	}
};
template <>
struct js_traits<godot::EditorResourcePreviewGenerator &> {
	/// @throws exception
	static godot::EditorResourcePreviewGenerator &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorResourcePreviewGenerator *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorResourcePreviewGenerator &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorResourcePreviewGenerator>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::EditorResourcePreviewGenerator>> {
	/// @throws exception
	static godot::Ref<godot::EditorResourcePreviewGenerator> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::EditorResourcePreviewGenerator>((godot::EditorResourcePreviewGenerator *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::EditorResourcePreviewGenerator> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::EditorResourcePreviewGenerator>>(v) };
	}
};
template <>
struct js_traits<godot::EditorResourceTooltipPlugin> {
	/// @throws exception
	static godot::EditorResourceTooltipPlugin unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorResourceTooltipPlugin *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorResourceTooltipPlugin v) noexcept {
		return Value{ ctx, std::forward<godot::EditorResourceTooltipPlugin>(v) };
	}
};
template <>
struct js_traits<godot::EditorResourceTooltipPlugin &> {
	/// @throws exception
	static godot::EditorResourceTooltipPlugin &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorResourceTooltipPlugin *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorResourceTooltipPlugin &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorResourceTooltipPlugin>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::EditorResourceTooltipPlugin>> {
	/// @throws exception
	static godot::Ref<godot::EditorResourceTooltipPlugin> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::EditorResourceTooltipPlugin>((godot::EditorResourceTooltipPlugin *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::EditorResourceTooltipPlugin> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::EditorResourceTooltipPlugin>>(v) };
	}
};
template <>
struct js_traits<godot::EditorSceneFormatImporter> {
	/// @throws exception
	static godot::EditorSceneFormatImporter unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorSceneFormatImporter *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorSceneFormatImporter v) noexcept {
		return Value{ ctx, std::forward<godot::EditorSceneFormatImporter>(v) };
	}
};
template <>
struct js_traits<godot::EditorSceneFormatImporter &> {
	/// @throws exception
	static godot::EditorSceneFormatImporter &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorSceneFormatImporter *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorSceneFormatImporter &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorSceneFormatImporter>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::EditorSceneFormatImporter>> {
	/// @throws exception
	static godot::Ref<godot::EditorSceneFormatImporter> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::EditorSceneFormatImporter>((godot::EditorSceneFormatImporter *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::EditorSceneFormatImporter> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::EditorSceneFormatImporter>>(v) };
	}
};
template <>
struct js_traits<godot::EditorSceneFormatImporterBlend> {
	/// @throws exception
	static godot::EditorSceneFormatImporterBlend unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorSceneFormatImporterBlend *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorSceneFormatImporterBlend v) noexcept {
		return Value{ ctx, std::forward<godot::EditorSceneFormatImporterBlend>(v) };
	}
};
template <>
struct js_traits<godot::EditorSceneFormatImporterBlend &> {
	/// @throws exception
	static godot::EditorSceneFormatImporterBlend &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorSceneFormatImporterBlend *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorSceneFormatImporterBlend &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorSceneFormatImporterBlend>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::EditorSceneFormatImporterBlend>> {
	/// @throws exception
	static godot::Ref<godot::EditorSceneFormatImporterBlend> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::EditorSceneFormatImporterBlend>((godot::EditorSceneFormatImporterBlend *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::EditorSceneFormatImporterBlend> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::EditorSceneFormatImporterBlend>>(v) };
	}
};
template <>
struct js_traits<godot::EditorSceneFormatImporterFBX> {
	/// @throws exception
	static godot::EditorSceneFormatImporterFBX unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorSceneFormatImporterFBX *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorSceneFormatImporterFBX v) noexcept {
		return Value{ ctx, std::forward<godot::EditorSceneFormatImporterFBX>(v) };
	}
};
template <>
struct js_traits<godot::EditorSceneFormatImporterFBX &> {
	/// @throws exception
	static godot::EditorSceneFormatImporterFBX &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorSceneFormatImporterFBX *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorSceneFormatImporterFBX &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorSceneFormatImporterFBX>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::EditorSceneFormatImporterFBX>> {
	/// @throws exception
	static godot::Ref<godot::EditorSceneFormatImporterFBX> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::EditorSceneFormatImporterFBX>((godot::EditorSceneFormatImporterFBX *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::EditorSceneFormatImporterFBX> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::EditorSceneFormatImporterFBX>>(v) };
	}
};
template <>
struct js_traits<godot::EditorSceneFormatImporterGLTF> {
	/// @throws exception
	static godot::EditorSceneFormatImporterGLTF unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorSceneFormatImporterGLTF *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorSceneFormatImporterGLTF v) noexcept {
		return Value{ ctx, std::forward<godot::EditorSceneFormatImporterGLTF>(v) };
	}
};
template <>
struct js_traits<godot::EditorSceneFormatImporterGLTF &> {
	/// @throws exception
	static godot::EditorSceneFormatImporterGLTF &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorSceneFormatImporterGLTF *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorSceneFormatImporterGLTF &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorSceneFormatImporterGLTF>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::EditorSceneFormatImporterGLTF>> {
	/// @throws exception
	static godot::Ref<godot::EditorSceneFormatImporterGLTF> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::EditorSceneFormatImporterGLTF>((godot::EditorSceneFormatImporterGLTF *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::EditorSceneFormatImporterGLTF> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::EditorSceneFormatImporterGLTF>>(v) };
	}
};
template <>
struct js_traits<godot::EditorScenePostImport> {
	/// @throws exception
	static godot::EditorScenePostImport unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorScenePostImport *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorScenePostImport v) noexcept {
		return Value{ ctx, std::forward<godot::EditorScenePostImport>(v) };
	}
};
template <>
struct js_traits<godot::EditorScenePostImport &> {
	/// @throws exception
	static godot::EditorScenePostImport &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorScenePostImport *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorScenePostImport &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorScenePostImport>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::EditorScenePostImport>> {
	/// @throws exception
	static godot::Ref<godot::EditorScenePostImport> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::EditorScenePostImport>((godot::EditorScenePostImport *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::EditorScenePostImport> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::EditorScenePostImport>>(v) };
	}
};
template <>
struct js_traits<godot::EditorScenePostImportPlugin> {
	/// @throws exception
	static godot::EditorScenePostImportPlugin unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorScenePostImportPlugin *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorScenePostImportPlugin v) noexcept {
		return Value{ ctx, std::forward<godot::EditorScenePostImportPlugin>(v) };
	}
};
template <>
struct js_traits<godot::EditorScenePostImportPlugin &> {
	/// @throws exception
	static godot::EditorScenePostImportPlugin &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorScenePostImportPlugin *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorScenePostImportPlugin &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorScenePostImportPlugin>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::EditorScenePostImportPlugin>> {
	/// @throws exception
	static godot::Ref<godot::EditorScenePostImportPlugin> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::EditorScenePostImportPlugin>((godot::EditorScenePostImportPlugin *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::EditorScenePostImportPlugin> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::EditorScenePostImportPlugin>>(v) };
	}
};
template <>
struct js_traits<godot::EditorScript> {
	/// @throws exception
	static godot::EditorScript unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorScript *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorScript v) noexcept {
		return Value{ ctx, std::forward<godot::EditorScript>(v) };
	}
};
template <>
struct js_traits<godot::EditorScript &> {
	/// @throws exception
	static godot::EditorScript &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorScript *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorScript &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorScript>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::EditorScript>> {
	/// @throws exception
	static godot::Ref<godot::EditorScript> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::EditorScript>((godot::EditorScript *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::EditorScript> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::EditorScript>>(v) };
	}
};
template <>
struct js_traits<godot::EditorScriptPicker> {
	/// @throws exception
	static godot::EditorScriptPicker unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorScriptPicker *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorScriptPicker v) noexcept {
		return Value{ ctx, std::forward<godot::EditorScriptPicker>(v) };
	}
};
template <>
struct js_traits<godot::EditorScriptPicker &> {
	/// @throws exception
	static godot::EditorScriptPicker &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorScriptPicker *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorScriptPicker &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorScriptPicker>(v) };
	}
};
template <>
struct js_traits<godot::EditorSelection> {
	/// @throws exception
	static godot::EditorSelection unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorSelection *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorSelection v) noexcept {
		return Value{ ctx, std::forward<godot::EditorSelection>(v) };
	}
};
template <>
struct js_traits<godot::EditorSelection &> {
	/// @throws exception
	static godot::EditorSelection &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorSelection *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorSelection &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorSelection>(v) };
	}
};
template <>
struct js_traits<godot::EditorSettings> {
	/// @throws exception
	static godot::EditorSettings unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorSettings *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorSettings v) noexcept {
		return Value{ ctx, std::forward<godot::EditorSettings>(v) };
	}
};
template <>
struct js_traits<godot::EditorSettings &> {
	/// @throws exception
	static godot::EditorSettings &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorSettings *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorSettings &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorSettings>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::EditorSettings>> {
	/// @throws exception
	static godot::Ref<godot::EditorSettings> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::EditorSettings>((godot::EditorSettings *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::EditorSettings> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::EditorSettings>>(v) };
	}
};
template <>
struct js_traits<godot::EditorSpinSlider> {
	/// @throws exception
	static godot::EditorSpinSlider unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorSpinSlider *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorSpinSlider v) noexcept {
		return Value{ ctx, std::forward<godot::EditorSpinSlider>(v) };
	}
};
template <>
struct js_traits<godot::EditorSpinSlider &> {
	/// @throws exception
	static godot::EditorSpinSlider &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorSpinSlider *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorSpinSlider &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorSpinSlider>(v) };
	}
};
template <>
struct js_traits<godot::EditorSyntaxHighlighter> {
	/// @throws exception
	static godot::EditorSyntaxHighlighter unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorSyntaxHighlighter *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorSyntaxHighlighter v) noexcept {
		return Value{ ctx, std::forward<godot::EditorSyntaxHighlighter>(v) };
	}
};
template <>
struct js_traits<godot::EditorSyntaxHighlighter &> {
	/// @throws exception
	static godot::EditorSyntaxHighlighter &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorSyntaxHighlighter *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorSyntaxHighlighter &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorSyntaxHighlighter>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::EditorSyntaxHighlighter>> {
	/// @throws exception
	static godot::Ref<godot::EditorSyntaxHighlighter> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::EditorSyntaxHighlighter>((godot::EditorSyntaxHighlighter *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::EditorSyntaxHighlighter> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::EditorSyntaxHighlighter>>(v) };
	}
};
template <>
struct js_traits<godot::EditorTranslationParserPlugin> {
	/// @throws exception
	static godot::EditorTranslationParserPlugin unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorTranslationParserPlugin *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorTranslationParserPlugin v) noexcept {
		return Value{ ctx, std::forward<godot::EditorTranslationParserPlugin>(v) };
	}
};
template <>
struct js_traits<godot::EditorTranslationParserPlugin &> {
	/// @throws exception
	static godot::EditorTranslationParserPlugin &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorTranslationParserPlugin *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorTranslationParserPlugin &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorTranslationParserPlugin>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::EditorTranslationParserPlugin>> {
	/// @throws exception
	static godot::Ref<godot::EditorTranslationParserPlugin> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::EditorTranslationParserPlugin>((godot::EditorTranslationParserPlugin *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::EditorTranslationParserPlugin> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::EditorTranslationParserPlugin>>(v) };
	}
};
template <>
struct js_traits<godot::EditorUndoRedoManager> {
	/// @throws exception
	static godot::EditorUndoRedoManager unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorUndoRedoManager *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorUndoRedoManager v) noexcept {
		return Value{ ctx, std::forward<godot::EditorUndoRedoManager>(v) };
	}
};
template <>
struct js_traits<godot::EditorUndoRedoManager &> {
	/// @throws exception
	static godot::EditorUndoRedoManager &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorUndoRedoManager *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorUndoRedoManager &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorUndoRedoManager>(v) };
	}
};
template <>
struct js_traits<godot::EditorVCSInterface> {
	/// @throws exception
	static godot::EditorVCSInterface unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorVCSInterface *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorVCSInterface v) noexcept {
		return Value{ ctx, std::forward<godot::EditorVCSInterface>(v) };
	}
};
template <>
struct js_traits<godot::EditorVCSInterface &> {
	/// @throws exception
	static godot::EditorVCSInterface &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EditorVCSInterface *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EditorVCSInterface &v) noexcept {
		return Value{ ctx, std::forward<godot::EditorVCSInterface>(v) };
	}
};
template <>
struct js_traits<godot::EncodedObjectAsID> {
	/// @throws exception
	static godot::EncodedObjectAsID unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EncodedObjectAsID *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EncodedObjectAsID v) noexcept {
		return Value{ ctx, std::forward<godot::EncodedObjectAsID>(v) };
	}
};
template <>
struct js_traits<godot::EncodedObjectAsID &> {
	/// @throws exception
	static godot::EncodedObjectAsID &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EncodedObjectAsID *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EncodedObjectAsID &v) noexcept {
		return Value{ ctx, std::forward<godot::EncodedObjectAsID>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::EncodedObjectAsID>> {
	/// @throws exception
	static godot::Ref<godot::EncodedObjectAsID> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::EncodedObjectAsID>((godot::EncodedObjectAsID *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::EncodedObjectAsID> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::EncodedObjectAsID>>(v) };
	}
};
template <>
struct js_traits<godot::Engine> {
	/// @throws exception
	static godot::Engine unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Engine *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Engine v) noexcept {
		return Value{ ctx, std::forward<godot::Engine>(v) };
	}
};
template <>
struct js_traits<godot::Engine &> {
	/// @throws exception
	static godot::Engine &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Engine *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Engine &v) noexcept {
		return Value{ ctx, std::forward<godot::Engine>(v) };
	}
};
template <>
struct js_traits<godot::EngineDebugger> {
	/// @throws exception
	static godot::EngineDebugger unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EngineDebugger *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EngineDebugger v) noexcept {
		return Value{ ctx, std::forward<godot::EngineDebugger>(v) };
	}
};
template <>
struct js_traits<godot::EngineDebugger &> {
	/// @throws exception
	static godot::EngineDebugger &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EngineDebugger *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EngineDebugger &v) noexcept {
		return Value{ ctx, std::forward<godot::EngineDebugger>(v) };
	}
};
template <>
struct js_traits<godot::EngineProfiler> {
	/// @throws exception
	static godot::EngineProfiler unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EngineProfiler *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EngineProfiler v) noexcept {
		return Value{ ctx, std::forward<godot::EngineProfiler>(v) };
	}
};
template <>
struct js_traits<godot::EngineProfiler &> {
	/// @throws exception
	static godot::EngineProfiler &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::EngineProfiler *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::EngineProfiler &v) noexcept {
		return Value{ ctx, std::forward<godot::EngineProfiler>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::EngineProfiler>> {
	/// @throws exception
	static godot::Ref<godot::EngineProfiler> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::EngineProfiler>((godot::EngineProfiler *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::EngineProfiler> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::EngineProfiler>>(v) };
	}
};
template <>
struct js_traits<godot::Environment> {
	/// @throws exception
	static godot::Environment unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Environment *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Environment v) noexcept {
		return Value{ ctx, std::forward<godot::Environment>(v) };
	}
};
template <>
struct js_traits<godot::Environment &> {
	/// @throws exception
	static godot::Environment &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Environment *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Environment &v) noexcept {
		return Value{ ctx, std::forward<godot::Environment>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Environment>> {
	/// @throws exception
	static godot::Ref<godot::Environment> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Environment>((godot::Environment *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Environment> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Environment>>(v) };
	}
};
template <>
struct js_traits<godot::Expression> {
	/// @throws exception
	static godot::Expression unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Expression *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Expression v) noexcept {
		return Value{ ctx, std::forward<godot::Expression>(v) };
	}
};
template <>
struct js_traits<godot::Expression &> {
	/// @throws exception
	static godot::Expression &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Expression *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Expression &v) noexcept {
		return Value{ ctx, std::forward<godot::Expression>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Expression>> {
	/// @throws exception
	static godot::Ref<godot::Expression> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Expression>((godot::Expression *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Expression> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Expression>>(v) };
	}
};
template <>
struct js_traits<godot::FastNoiseLite> {
	/// @throws exception
	static godot::FastNoiseLite unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::FastNoiseLite *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::FastNoiseLite v) noexcept {
		return Value{ ctx, std::forward<godot::FastNoiseLite>(v) };
	}
};
template <>
struct js_traits<godot::FastNoiseLite &> {
	/// @throws exception
	static godot::FastNoiseLite &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::FastNoiseLite *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::FastNoiseLite &v) noexcept {
		return Value{ ctx, std::forward<godot::FastNoiseLite>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::FastNoiseLite>> {
	/// @throws exception
	static godot::Ref<godot::FastNoiseLite> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::FastNoiseLite>((godot::FastNoiseLite *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::FastNoiseLite> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::FastNoiseLite>>(v) };
	}
};
template <>
struct js_traits<godot::FileAccess> {
	/// @throws exception
	static godot::FileAccess unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::FileAccess *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::FileAccess v) noexcept {
		return Value{ ctx, std::forward<godot::FileAccess>(v) };
	}
};
template <>
struct js_traits<godot::FileAccess &> {
	/// @throws exception
	static godot::FileAccess &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::FileAccess *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::FileAccess &v) noexcept {
		return Value{ ctx, std::forward<godot::FileAccess>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::FileAccess>> {
	/// @throws exception
	static godot::Ref<godot::FileAccess> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::FileAccess>((godot::FileAccess *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::FileAccess> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::FileAccess>>(v) };
	}
};
template <>
struct js_traits<godot::FileDialog> {
	/// @throws exception
	static godot::FileDialog unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::FileDialog *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::FileDialog v) noexcept {
		return Value{ ctx, std::forward<godot::FileDialog>(v) };
	}
};
template <>
struct js_traits<godot::FileDialog &> {
	/// @throws exception
	static godot::FileDialog &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::FileDialog *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::FileDialog &v) noexcept {
		return Value{ ctx, std::forward<godot::FileDialog>(v) };
	}
};
template <>
struct js_traits<godot::FileSystemDock> {
	/// @throws exception
	static godot::FileSystemDock unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::FileSystemDock *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::FileSystemDock v) noexcept {
		return Value{ ctx, std::forward<godot::FileSystemDock>(v) };
	}
};
template <>
struct js_traits<godot::FileSystemDock &> {
	/// @throws exception
	static godot::FileSystemDock &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::FileSystemDock *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::FileSystemDock &v) noexcept {
		return Value{ ctx, std::forward<godot::FileSystemDock>(v) };
	}
};
template <>
struct js_traits<godot::FlowContainer> {
	/// @throws exception
	static godot::FlowContainer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::FlowContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::FlowContainer v) noexcept {
		return Value{ ctx, std::forward<godot::FlowContainer>(v) };
	}
};
template <>
struct js_traits<godot::FlowContainer &> {
	/// @throws exception
	static godot::FlowContainer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::FlowContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::FlowContainer &v) noexcept {
		return Value{ ctx, std::forward<godot::FlowContainer>(v) };
	}
};
template <>
struct js_traits<godot::FogMaterial> {
	/// @throws exception
	static godot::FogMaterial unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::FogMaterial *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::FogMaterial v) noexcept {
		return Value{ ctx, std::forward<godot::FogMaterial>(v) };
	}
};
template <>
struct js_traits<godot::FogMaterial &> {
	/// @throws exception
	static godot::FogMaterial &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::FogMaterial *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::FogMaterial &v) noexcept {
		return Value{ ctx, std::forward<godot::FogMaterial>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::FogMaterial>> {
	/// @throws exception
	static godot::Ref<godot::FogMaterial> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::FogMaterial>((godot::FogMaterial *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::FogMaterial> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::FogMaterial>>(v) };
	}
};
template <>
struct js_traits<godot::FogVolume> {
	/// @throws exception
	static godot::FogVolume unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::FogVolume *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::FogVolume v) noexcept {
		return Value{ ctx, std::forward<godot::FogVolume>(v) };
	}
};
template <>
struct js_traits<godot::FogVolume &> {
	/// @throws exception
	static godot::FogVolume &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::FogVolume *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::FogVolume &v) noexcept {
		return Value{ ctx, std::forward<godot::FogVolume>(v) };
	}
};
template <>
struct js_traits<godot::Font> {
	/// @throws exception
	static godot::Font unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Font *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Font v) noexcept {
		return Value{ ctx, std::forward<godot::Font>(v) };
	}
};
template <>
struct js_traits<godot::Font &> {
	/// @throws exception
	static godot::Font &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Font *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Font &v) noexcept {
		return Value{ ctx, std::forward<godot::Font>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Font>> {
	/// @throws exception
	static godot::Ref<godot::Font> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Font>((godot::Font *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Font> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Font>>(v) };
	}
};
template <>
struct js_traits<godot::FontFile> {
	/// @throws exception
	static godot::FontFile unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::FontFile *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::FontFile v) noexcept {
		return Value{ ctx, std::forward<godot::FontFile>(v) };
	}
};
template <>
struct js_traits<godot::FontFile &> {
	/// @throws exception
	static godot::FontFile &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::FontFile *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::FontFile &v) noexcept {
		return Value{ ctx, std::forward<godot::FontFile>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::FontFile>> {
	/// @throws exception
	static godot::Ref<godot::FontFile> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::FontFile>((godot::FontFile *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::FontFile> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::FontFile>>(v) };
	}
};
template <>
struct js_traits<godot::FontVariation> {
	/// @throws exception
	static godot::FontVariation unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::FontVariation *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::FontVariation v) noexcept {
		return Value{ ctx, std::forward<godot::FontVariation>(v) };
	}
};
template <>
struct js_traits<godot::FontVariation &> {
	/// @throws exception
	static godot::FontVariation &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::FontVariation *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::FontVariation &v) noexcept {
		return Value{ ctx, std::forward<godot::FontVariation>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::FontVariation>> {
	/// @throws exception
	static godot::Ref<godot::FontVariation> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::FontVariation>((godot::FontVariation *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::FontVariation> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::FontVariation>>(v) };
	}
};
template <>
struct js_traits<godot::GDExtension> {
	/// @throws exception
	static godot::GDExtension unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GDExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GDExtension v) noexcept {
		return Value{ ctx, std::forward<godot::GDExtension>(v) };
	}
};
template <>
struct js_traits<godot::GDExtension &> {
	/// @throws exception
	static godot::GDExtension &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GDExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GDExtension &v) noexcept {
		return Value{ ctx, std::forward<godot::GDExtension>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::GDExtension>> {
	/// @throws exception
	static godot::Ref<godot::GDExtension> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::GDExtension>((godot::GDExtension *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::GDExtension> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::GDExtension>>(v) };
	}
};
template <>
struct js_traits<godot::GDExtensionManager> {
	/// @throws exception
	static godot::GDExtensionManager unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GDExtensionManager *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GDExtensionManager v) noexcept {
		return Value{ ctx, std::forward<godot::GDExtensionManager>(v) };
	}
};
template <>
struct js_traits<godot::GDExtensionManager &> {
	/// @throws exception
	static godot::GDExtensionManager &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GDExtensionManager *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GDExtensionManager &v) noexcept {
		return Value{ ctx, std::forward<godot::GDExtensionManager>(v) };
	}
};
template <>
struct js_traits<godot::GDScript> {
	/// @throws exception
	static godot::GDScript unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GDScript *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GDScript v) noexcept {
		return Value{ ctx, std::forward<godot::GDScript>(v) };
	}
};
template <>
struct js_traits<godot::GDScript &> {
	/// @throws exception
	static godot::GDScript &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GDScript *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GDScript &v) noexcept {
		return Value{ ctx, std::forward<godot::GDScript>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::GDScript>> {
	/// @throws exception
	static godot::Ref<godot::GDScript> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::GDScript>((godot::GDScript *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::GDScript> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::GDScript>>(v) };
	}
};
template <>
struct js_traits<godot::GLTFAccessor> {
	/// @throws exception
	static godot::GLTFAccessor unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFAccessor *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFAccessor v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFAccessor>(v) };
	}
};
template <>
struct js_traits<godot::GLTFAccessor &> {
	/// @throws exception
	static godot::GLTFAccessor &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFAccessor *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFAccessor &v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFAccessor>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::GLTFAccessor>> {
	/// @throws exception
	static godot::Ref<godot::GLTFAccessor> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::GLTFAccessor>((godot::GLTFAccessor *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::GLTFAccessor> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::GLTFAccessor>>(v) };
	}
};
template <>
struct js_traits<godot::GLTFAnimation> {
	/// @throws exception
	static godot::GLTFAnimation unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFAnimation *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFAnimation v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFAnimation>(v) };
	}
};
template <>
struct js_traits<godot::GLTFAnimation &> {
	/// @throws exception
	static godot::GLTFAnimation &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFAnimation *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFAnimation &v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFAnimation>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::GLTFAnimation>> {
	/// @throws exception
	static godot::Ref<godot::GLTFAnimation> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::GLTFAnimation>((godot::GLTFAnimation *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::GLTFAnimation> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::GLTFAnimation>>(v) };
	}
};
template <>
struct js_traits<godot::GLTFBufferView> {
	/// @throws exception
	static godot::GLTFBufferView unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFBufferView *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFBufferView v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFBufferView>(v) };
	}
};
template <>
struct js_traits<godot::GLTFBufferView &> {
	/// @throws exception
	static godot::GLTFBufferView &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFBufferView *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFBufferView &v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFBufferView>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::GLTFBufferView>> {
	/// @throws exception
	static godot::Ref<godot::GLTFBufferView> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::GLTFBufferView>((godot::GLTFBufferView *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::GLTFBufferView> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::GLTFBufferView>>(v) };
	}
};
template <>
struct js_traits<godot::GLTFCamera> {
	/// @throws exception
	static godot::GLTFCamera unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFCamera *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFCamera v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFCamera>(v) };
	}
};
template <>
struct js_traits<godot::GLTFCamera &> {
	/// @throws exception
	static godot::GLTFCamera &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFCamera *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFCamera &v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFCamera>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::GLTFCamera>> {
	/// @throws exception
	static godot::Ref<godot::GLTFCamera> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::GLTFCamera>((godot::GLTFCamera *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::GLTFCamera> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::GLTFCamera>>(v) };
	}
};
template <>
struct js_traits<godot::GLTFDocument> {
	/// @throws exception
	static godot::GLTFDocument unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFDocument *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFDocument v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFDocument>(v) };
	}
};
template <>
struct js_traits<godot::GLTFDocument &> {
	/// @throws exception
	static godot::GLTFDocument &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFDocument *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFDocument &v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFDocument>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::GLTFDocument>> {
	/// @throws exception
	static godot::Ref<godot::GLTFDocument> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::GLTFDocument>((godot::GLTFDocument *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::GLTFDocument> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::GLTFDocument>>(v) };
	}
};
template <>
struct js_traits<godot::GLTFDocumentExtension> {
	/// @throws exception
	static godot::GLTFDocumentExtension unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFDocumentExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFDocumentExtension v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFDocumentExtension>(v) };
	}
};
template <>
struct js_traits<godot::GLTFDocumentExtension &> {
	/// @throws exception
	static godot::GLTFDocumentExtension &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFDocumentExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFDocumentExtension &v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFDocumentExtension>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::GLTFDocumentExtension>> {
	/// @throws exception
	static godot::Ref<godot::GLTFDocumentExtension> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::GLTFDocumentExtension>((godot::GLTFDocumentExtension *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::GLTFDocumentExtension> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::GLTFDocumentExtension>>(v) };
	}
};
template <>
struct js_traits<godot::GLTFDocumentExtensionConvertImporterMesh> {
	/// @throws exception
	static godot::GLTFDocumentExtensionConvertImporterMesh unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFDocumentExtensionConvertImporterMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFDocumentExtensionConvertImporterMesh v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFDocumentExtensionConvertImporterMesh>(v) };
	}
};
template <>
struct js_traits<godot::GLTFDocumentExtensionConvertImporterMesh &> {
	/// @throws exception
	static godot::GLTFDocumentExtensionConvertImporterMesh &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFDocumentExtensionConvertImporterMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFDocumentExtensionConvertImporterMesh &v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFDocumentExtensionConvertImporterMesh>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::GLTFDocumentExtensionConvertImporterMesh>> {
	/// @throws exception
	static godot::Ref<godot::GLTFDocumentExtensionConvertImporterMesh> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::GLTFDocumentExtensionConvertImporterMesh>((godot::GLTFDocumentExtensionConvertImporterMesh *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::GLTFDocumentExtensionConvertImporterMesh> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::GLTFDocumentExtensionConvertImporterMesh>>(v) };
	}
};
template <>
struct js_traits<godot::GLTFLight> {
	/// @throws exception
	static godot::GLTFLight unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFLight *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFLight v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFLight>(v) };
	}
};
template <>
struct js_traits<godot::GLTFLight &> {
	/// @throws exception
	static godot::GLTFLight &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFLight *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFLight &v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFLight>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::GLTFLight>> {
	/// @throws exception
	static godot::Ref<godot::GLTFLight> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::GLTFLight>((godot::GLTFLight *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::GLTFLight> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::GLTFLight>>(v) };
	}
};
template <>
struct js_traits<godot::GLTFMesh> {
	/// @throws exception
	static godot::GLTFMesh unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFMesh v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFMesh>(v) };
	}
};
template <>
struct js_traits<godot::GLTFMesh &> {
	/// @throws exception
	static godot::GLTFMesh &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFMesh &v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFMesh>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::GLTFMesh>> {
	/// @throws exception
	static godot::Ref<godot::GLTFMesh> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::GLTFMesh>((godot::GLTFMesh *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::GLTFMesh> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::GLTFMesh>>(v) };
	}
};
template <>
struct js_traits<godot::GLTFNode> {
	/// @throws exception
	static godot::GLTFNode unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFNode *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFNode v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFNode>(v) };
	}
};
template <>
struct js_traits<godot::GLTFNode &> {
	/// @throws exception
	static godot::GLTFNode &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFNode *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFNode &v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFNode>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::GLTFNode>> {
	/// @throws exception
	static godot::Ref<godot::GLTFNode> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::GLTFNode>((godot::GLTFNode *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::GLTFNode> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::GLTFNode>>(v) };
	}
};
template <>
struct js_traits<godot::GLTFPhysicsBody> {
	/// @throws exception
	static godot::GLTFPhysicsBody unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFPhysicsBody *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFPhysicsBody v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFPhysicsBody>(v) };
	}
};
template <>
struct js_traits<godot::GLTFPhysicsBody &> {
	/// @throws exception
	static godot::GLTFPhysicsBody &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFPhysicsBody *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFPhysicsBody &v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFPhysicsBody>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::GLTFPhysicsBody>> {
	/// @throws exception
	static godot::Ref<godot::GLTFPhysicsBody> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::GLTFPhysicsBody>((godot::GLTFPhysicsBody *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::GLTFPhysicsBody> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::GLTFPhysicsBody>>(v) };
	}
};
template <>
struct js_traits<godot::GLTFPhysicsShape> {
	/// @throws exception
	static godot::GLTFPhysicsShape unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFPhysicsShape *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFPhysicsShape v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFPhysicsShape>(v) };
	}
};
template <>
struct js_traits<godot::GLTFPhysicsShape &> {
	/// @throws exception
	static godot::GLTFPhysicsShape &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFPhysicsShape *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFPhysicsShape &v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFPhysicsShape>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::GLTFPhysicsShape>> {
	/// @throws exception
	static godot::Ref<godot::GLTFPhysicsShape> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::GLTFPhysicsShape>((godot::GLTFPhysicsShape *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::GLTFPhysicsShape> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::GLTFPhysicsShape>>(v) };
	}
};
template <>
struct js_traits<godot::GLTFSkeleton> {
	/// @throws exception
	static godot::GLTFSkeleton unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFSkeleton *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFSkeleton v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFSkeleton>(v) };
	}
};
template <>
struct js_traits<godot::GLTFSkeleton &> {
	/// @throws exception
	static godot::GLTFSkeleton &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFSkeleton *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFSkeleton &v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFSkeleton>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::GLTFSkeleton>> {
	/// @throws exception
	static godot::Ref<godot::GLTFSkeleton> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::GLTFSkeleton>((godot::GLTFSkeleton *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::GLTFSkeleton> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::GLTFSkeleton>>(v) };
	}
};
template <>
struct js_traits<godot::GLTFSkin> {
	/// @throws exception
	static godot::GLTFSkin unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFSkin *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFSkin v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFSkin>(v) };
	}
};
template <>
struct js_traits<godot::GLTFSkin &> {
	/// @throws exception
	static godot::GLTFSkin &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFSkin *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFSkin &v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFSkin>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::GLTFSkin>> {
	/// @throws exception
	static godot::Ref<godot::GLTFSkin> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::GLTFSkin>((godot::GLTFSkin *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::GLTFSkin> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::GLTFSkin>>(v) };
	}
};
template <>
struct js_traits<godot::GLTFSpecGloss> {
	/// @throws exception
	static godot::GLTFSpecGloss unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFSpecGloss *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFSpecGloss v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFSpecGloss>(v) };
	}
};
template <>
struct js_traits<godot::GLTFSpecGloss &> {
	/// @throws exception
	static godot::GLTFSpecGloss &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFSpecGloss *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFSpecGloss &v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFSpecGloss>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::GLTFSpecGloss>> {
	/// @throws exception
	static godot::Ref<godot::GLTFSpecGloss> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::GLTFSpecGloss>((godot::GLTFSpecGloss *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::GLTFSpecGloss> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::GLTFSpecGloss>>(v) };
	}
};
template <>
struct js_traits<godot::GLTFState> {
	/// @throws exception
	static godot::GLTFState unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFState *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFState v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFState>(v) };
	}
};
template <>
struct js_traits<godot::GLTFState &> {
	/// @throws exception
	static godot::GLTFState &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFState *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFState &v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFState>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::GLTFState>> {
	/// @throws exception
	static godot::Ref<godot::GLTFState> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::GLTFState>((godot::GLTFState *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::GLTFState> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::GLTFState>>(v) };
	}
};
template <>
struct js_traits<godot::GLTFTexture> {
	/// @throws exception
	static godot::GLTFTexture unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFTexture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFTexture v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFTexture>(v) };
	}
};
template <>
struct js_traits<godot::GLTFTexture &> {
	/// @throws exception
	static godot::GLTFTexture &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFTexture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFTexture &v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFTexture>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::GLTFTexture>> {
	/// @throws exception
	static godot::Ref<godot::GLTFTexture> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::GLTFTexture>((godot::GLTFTexture *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::GLTFTexture> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::GLTFTexture>>(v) };
	}
};
template <>
struct js_traits<godot::GLTFTextureSampler> {
	/// @throws exception
	static godot::GLTFTextureSampler unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFTextureSampler *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFTextureSampler v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFTextureSampler>(v) };
	}
};
template <>
struct js_traits<godot::GLTFTextureSampler &> {
	/// @throws exception
	static godot::GLTFTextureSampler &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GLTFTextureSampler *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GLTFTextureSampler &v) noexcept {
		return Value{ ctx, std::forward<godot::GLTFTextureSampler>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::GLTFTextureSampler>> {
	/// @throws exception
	static godot::Ref<godot::GLTFTextureSampler> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::GLTFTextureSampler>((godot::GLTFTextureSampler *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::GLTFTextureSampler> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::GLTFTextureSampler>>(v) };
	}
};
template <>
struct js_traits<godot::GPUParticles2D> {
	/// @throws exception
	static godot::GPUParticles2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GPUParticles2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GPUParticles2D v) noexcept {
		return Value{ ctx, std::forward<godot::GPUParticles2D>(v) };
	}
};
template <>
struct js_traits<godot::GPUParticles2D &> {
	/// @throws exception
	static godot::GPUParticles2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GPUParticles2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GPUParticles2D &v) noexcept {
		return Value{ ctx, std::forward<godot::GPUParticles2D>(v) };
	}
};
template <>
struct js_traits<godot::GPUParticles3D> {
	/// @throws exception
	static godot::GPUParticles3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GPUParticles3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GPUParticles3D v) noexcept {
		return Value{ ctx, std::forward<godot::GPUParticles3D>(v) };
	}
};
template <>
struct js_traits<godot::GPUParticles3D &> {
	/// @throws exception
	static godot::GPUParticles3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GPUParticles3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GPUParticles3D &v) noexcept {
		return Value{ ctx, std::forward<godot::GPUParticles3D>(v) };
	}
};
template <>
struct js_traits<godot::GPUParticlesAttractor3D> {
	/// @throws exception
	static godot::GPUParticlesAttractor3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GPUParticlesAttractor3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GPUParticlesAttractor3D v) noexcept {
		return Value{ ctx, std::forward<godot::GPUParticlesAttractor3D>(v) };
	}
};
template <>
struct js_traits<godot::GPUParticlesAttractor3D &> {
	/// @throws exception
	static godot::GPUParticlesAttractor3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GPUParticlesAttractor3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GPUParticlesAttractor3D &v) noexcept {
		return Value{ ctx, std::forward<godot::GPUParticlesAttractor3D>(v) };
	}
};
template <>
struct js_traits<godot::GPUParticlesAttractorBox3D> {
	/// @throws exception
	static godot::GPUParticlesAttractorBox3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GPUParticlesAttractorBox3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GPUParticlesAttractorBox3D v) noexcept {
		return Value{ ctx, std::forward<godot::GPUParticlesAttractorBox3D>(v) };
	}
};
template <>
struct js_traits<godot::GPUParticlesAttractorBox3D &> {
	/// @throws exception
	static godot::GPUParticlesAttractorBox3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GPUParticlesAttractorBox3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GPUParticlesAttractorBox3D &v) noexcept {
		return Value{ ctx, std::forward<godot::GPUParticlesAttractorBox3D>(v) };
	}
};
template <>
struct js_traits<godot::GPUParticlesAttractorSphere3D> {
	/// @throws exception
	static godot::GPUParticlesAttractorSphere3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GPUParticlesAttractorSphere3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GPUParticlesAttractorSphere3D v) noexcept {
		return Value{ ctx, std::forward<godot::GPUParticlesAttractorSphere3D>(v) };
	}
};
template <>
struct js_traits<godot::GPUParticlesAttractorSphere3D &> {
	/// @throws exception
	static godot::GPUParticlesAttractorSphere3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GPUParticlesAttractorSphere3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GPUParticlesAttractorSphere3D &v) noexcept {
		return Value{ ctx, std::forward<godot::GPUParticlesAttractorSphere3D>(v) };
	}
};
template <>
struct js_traits<godot::GPUParticlesAttractorVectorField3D> {
	/// @throws exception
	static godot::GPUParticlesAttractorVectorField3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GPUParticlesAttractorVectorField3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GPUParticlesAttractorVectorField3D v) noexcept {
		return Value{ ctx, std::forward<godot::GPUParticlesAttractorVectorField3D>(v) };
	}
};
template <>
struct js_traits<godot::GPUParticlesAttractorVectorField3D &> {
	/// @throws exception
	static godot::GPUParticlesAttractorVectorField3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GPUParticlesAttractorVectorField3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GPUParticlesAttractorVectorField3D &v) noexcept {
		return Value{ ctx, std::forward<godot::GPUParticlesAttractorVectorField3D>(v) };
	}
};
template <>
struct js_traits<godot::GPUParticlesCollision3D> {
	/// @throws exception
	static godot::GPUParticlesCollision3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GPUParticlesCollision3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GPUParticlesCollision3D v) noexcept {
		return Value{ ctx, std::forward<godot::GPUParticlesCollision3D>(v) };
	}
};
template <>
struct js_traits<godot::GPUParticlesCollision3D &> {
	/// @throws exception
	static godot::GPUParticlesCollision3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GPUParticlesCollision3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GPUParticlesCollision3D &v) noexcept {
		return Value{ ctx, std::forward<godot::GPUParticlesCollision3D>(v) };
	}
};
template <>
struct js_traits<godot::GPUParticlesCollisionBox3D> {
	/// @throws exception
	static godot::GPUParticlesCollisionBox3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GPUParticlesCollisionBox3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GPUParticlesCollisionBox3D v) noexcept {
		return Value{ ctx, std::forward<godot::GPUParticlesCollisionBox3D>(v) };
	}
};
template <>
struct js_traits<godot::GPUParticlesCollisionBox3D &> {
	/// @throws exception
	static godot::GPUParticlesCollisionBox3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GPUParticlesCollisionBox3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GPUParticlesCollisionBox3D &v) noexcept {
		return Value{ ctx, std::forward<godot::GPUParticlesCollisionBox3D>(v) };
	}
};
template <>
struct js_traits<godot::GPUParticlesCollisionHeightField3D> {
	/// @throws exception
	static godot::GPUParticlesCollisionHeightField3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GPUParticlesCollisionHeightField3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GPUParticlesCollisionHeightField3D v) noexcept {
		return Value{ ctx, std::forward<godot::GPUParticlesCollisionHeightField3D>(v) };
	}
};
template <>
struct js_traits<godot::GPUParticlesCollisionHeightField3D &> {
	/// @throws exception
	static godot::GPUParticlesCollisionHeightField3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GPUParticlesCollisionHeightField3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GPUParticlesCollisionHeightField3D &v) noexcept {
		return Value{ ctx, std::forward<godot::GPUParticlesCollisionHeightField3D>(v) };
	}
};
template <>
struct js_traits<godot::GPUParticlesCollisionSDF3D> {
	/// @throws exception
	static godot::GPUParticlesCollisionSDF3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GPUParticlesCollisionSDF3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GPUParticlesCollisionSDF3D v) noexcept {
		return Value{ ctx, std::forward<godot::GPUParticlesCollisionSDF3D>(v) };
	}
};
template <>
struct js_traits<godot::GPUParticlesCollisionSDF3D &> {
	/// @throws exception
	static godot::GPUParticlesCollisionSDF3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GPUParticlesCollisionSDF3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GPUParticlesCollisionSDF3D &v) noexcept {
		return Value{ ctx, std::forward<godot::GPUParticlesCollisionSDF3D>(v) };
	}
};
template <>
struct js_traits<godot::GPUParticlesCollisionSphere3D> {
	/// @throws exception
	static godot::GPUParticlesCollisionSphere3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GPUParticlesCollisionSphere3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GPUParticlesCollisionSphere3D v) noexcept {
		return Value{ ctx, std::forward<godot::GPUParticlesCollisionSphere3D>(v) };
	}
};
template <>
struct js_traits<godot::GPUParticlesCollisionSphere3D &> {
	/// @throws exception
	static godot::GPUParticlesCollisionSphere3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GPUParticlesCollisionSphere3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GPUParticlesCollisionSphere3D &v) noexcept {
		return Value{ ctx, std::forward<godot::GPUParticlesCollisionSphere3D>(v) };
	}
};
template <>
struct js_traits<godot::Generic6DOFJoint3D> {
	/// @throws exception
	static godot::Generic6DOFJoint3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Generic6DOFJoint3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Generic6DOFJoint3D v) noexcept {
		return Value{ ctx, std::forward<godot::Generic6DOFJoint3D>(v) };
	}
};
template <>
struct js_traits<godot::Generic6DOFJoint3D &> {
	/// @throws exception
	static godot::Generic6DOFJoint3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Generic6DOFJoint3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Generic6DOFJoint3D &v) noexcept {
		return Value{ ctx, std::forward<godot::Generic6DOFJoint3D>(v) };
	}
};
template <>
struct js_traits<godot::Geometry2D> {
	/// @throws exception
	static godot::Geometry2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Geometry2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Geometry2D v) noexcept {
		return Value{ ctx, std::forward<godot::Geometry2D>(v) };
	}
};
template <>
struct js_traits<godot::Geometry2D &> {
	/// @throws exception
	static godot::Geometry2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Geometry2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Geometry2D &v) noexcept {
		return Value{ ctx, std::forward<godot::Geometry2D>(v) };
	}
};
template <>
struct js_traits<godot::Geometry3D> {
	/// @throws exception
	static godot::Geometry3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Geometry3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Geometry3D v) noexcept {
		return Value{ ctx, std::forward<godot::Geometry3D>(v) };
	}
};
template <>
struct js_traits<godot::Geometry3D &> {
	/// @throws exception
	static godot::Geometry3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Geometry3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Geometry3D &v) noexcept {
		return Value{ ctx, std::forward<godot::Geometry3D>(v) };
	}
};
template <>
struct js_traits<godot::GeometryInstance3D> {
	/// @throws exception
	static godot::GeometryInstance3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GeometryInstance3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GeometryInstance3D v) noexcept {
		return Value{ ctx, std::forward<godot::GeometryInstance3D>(v) };
	}
};
template <>
struct js_traits<godot::GeometryInstance3D &> {
	/// @throws exception
	static godot::GeometryInstance3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GeometryInstance3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GeometryInstance3D &v) noexcept {
		return Value{ ctx, std::forward<godot::GeometryInstance3D>(v) };
	}
};
template <>
struct js_traits<godot::Gradient> {
	/// @throws exception
	static godot::Gradient unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Gradient *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Gradient v) noexcept {
		return Value{ ctx, std::forward<godot::Gradient>(v) };
	}
};
template <>
struct js_traits<godot::Gradient &> {
	/// @throws exception
	static godot::Gradient &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Gradient *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Gradient &v) noexcept {
		return Value{ ctx, std::forward<godot::Gradient>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Gradient>> {
	/// @throws exception
	static godot::Ref<godot::Gradient> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Gradient>((godot::Gradient *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Gradient> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Gradient>>(v) };
	}
};
template <>
struct js_traits<godot::GradientTexture1D> {
	/// @throws exception
	static godot::GradientTexture1D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GradientTexture1D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GradientTexture1D v) noexcept {
		return Value{ ctx, std::forward<godot::GradientTexture1D>(v) };
	}
};
template <>
struct js_traits<godot::GradientTexture1D &> {
	/// @throws exception
	static godot::GradientTexture1D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GradientTexture1D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GradientTexture1D &v) noexcept {
		return Value{ ctx, std::forward<godot::GradientTexture1D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::GradientTexture1D>> {
	/// @throws exception
	static godot::Ref<godot::GradientTexture1D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::GradientTexture1D>((godot::GradientTexture1D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::GradientTexture1D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::GradientTexture1D>>(v) };
	}
};
template <>
struct js_traits<godot::GradientTexture2D> {
	/// @throws exception
	static godot::GradientTexture2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GradientTexture2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GradientTexture2D v) noexcept {
		return Value{ ctx, std::forward<godot::GradientTexture2D>(v) };
	}
};
template <>
struct js_traits<godot::GradientTexture2D &> {
	/// @throws exception
	static godot::GradientTexture2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GradientTexture2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GradientTexture2D &v) noexcept {
		return Value{ ctx, std::forward<godot::GradientTexture2D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::GradientTexture2D>> {
	/// @throws exception
	static godot::Ref<godot::GradientTexture2D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::GradientTexture2D>((godot::GradientTexture2D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::GradientTexture2D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::GradientTexture2D>>(v) };
	}
};
template <>
struct js_traits<godot::GraphEdit> {
	/// @throws exception
	static godot::GraphEdit unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GraphEdit *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GraphEdit v) noexcept {
		return Value{ ctx, std::forward<godot::GraphEdit>(v) };
	}
};
template <>
struct js_traits<godot::GraphEdit &> {
	/// @throws exception
	static godot::GraphEdit &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GraphEdit *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GraphEdit &v) noexcept {
		return Value{ ctx, std::forward<godot::GraphEdit>(v) };
	}
};
template <>
struct js_traits<godot::GraphElement> {
	/// @throws exception
	static godot::GraphElement unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GraphElement *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GraphElement v) noexcept {
		return Value{ ctx, std::forward<godot::GraphElement>(v) };
	}
};
template <>
struct js_traits<godot::GraphElement &> {
	/// @throws exception
	static godot::GraphElement &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GraphElement *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GraphElement &v) noexcept {
		return Value{ ctx, std::forward<godot::GraphElement>(v) };
	}
};
template <>
struct js_traits<godot::GraphNode> {
	/// @throws exception
	static godot::GraphNode unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GraphNode *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GraphNode v) noexcept {
		return Value{ ctx, std::forward<godot::GraphNode>(v) };
	}
};
template <>
struct js_traits<godot::GraphNode &> {
	/// @throws exception
	static godot::GraphNode &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GraphNode *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GraphNode &v) noexcept {
		return Value{ ctx, std::forward<godot::GraphNode>(v) };
	}
};
template <>
struct js_traits<godot::GridContainer> {
	/// @throws exception
	static godot::GridContainer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GridContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GridContainer v) noexcept {
		return Value{ ctx, std::forward<godot::GridContainer>(v) };
	}
};
template <>
struct js_traits<godot::GridContainer &> {
	/// @throws exception
	static godot::GridContainer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GridContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GridContainer &v) noexcept {
		return Value{ ctx, std::forward<godot::GridContainer>(v) };
	}
};
template <>
struct js_traits<godot::GridMap> {
	/// @throws exception
	static godot::GridMap unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GridMap *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GridMap v) noexcept {
		return Value{ ctx, std::forward<godot::GridMap>(v) };
	}
};
template <>
struct js_traits<godot::GridMap &> {
	/// @throws exception
	static godot::GridMap &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GridMap *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GridMap &v) noexcept {
		return Value{ ctx, std::forward<godot::GridMap>(v) };
	}
};
template <>
struct js_traits<godot::GrooveJoint2D> {
	/// @throws exception
	static godot::GrooveJoint2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GrooveJoint2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GrooveJoint2D v) noexcept {
		return Value{ ctx, std::forward<godot::GrooveJoint2D>(v) };
	}
};
template <>
struct js_traits<godot::GrooveJoint2D &> {
	/// @throws exception
	static godot::GrooveJoint2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::GrooveJoint2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::GrooveJoint2D &v) noexcept {
		return Value{ ctx, std::forward<godot::GrooveJoint2D>(v) };
	}
};
template <>
struct js_traits<godot::HBoxContainer> {
	/// @throws exception
	static godot::HBoxContainer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::HBoxContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::HBoxContainer v) noexcept {
		return Value{ ctx, std::forward<godot::HBoxContainer>(v) };
	}
};
template <>
struct js_traits<godot::HBoxContainer &> {
	/// @throws exception
	static godot::HBoxContainer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::HBoxContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::HBoxContainer &v) noexcept {
		return Value{ ctx, std::forward<godot::HBoxContainer>(v) };
	}
};
template <>
struct js_traits<godot::HFlowContainer> {
	/// @throws exception
	static godot::HFlowContainer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::HFlowContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::HFlowContainer v) noexcept {
		return Value{ ctx, std::forward<godot::HFlowContainer>(v) };
	}
};
template <>
struct js_traits<godot::HFlowContainer &> {
	/// @throws exception
	static godot::HFlowContainer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::HFlowContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::HFlowContainer &v) noexcept {
		return Value{ ctx, std::forward<godot::HFlowContainer>(v) };
	}
};
template <>
struct js_traits<godot::HMACContext> {
	/// @throws exception
	static godot::HMACContext unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::HMACContext *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::HMACContext v) noexcept {
		return Value{ ctx, std::forward<godot::HMACContext>(v) };
	}
};
template <>
struct js_traits<godot::HMACContext &> {
	/// @throws exception
	static godot::HMACContext &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::HMACContext *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::HMACContext &v) noexcept {
		return Value{ ctx, std::forward<godot::HMACContext>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::HMACContext>> {
	/// @throws exception
	static godot::Ref<godot::HMACContext> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::HMACContext>((godot::HMACContext *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::HMACContext> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::HMACContext>>(v) };
	}
};
template <>
struct js_traits<godot::HScrollBar> {
	/// @throws exception
	static godot::HScrollBar unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::HScrollBar *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::HScrollBar v) noexcept {
		return Value{ ctx, std::forward<godot::HScrollBar>(v) };
	}
};
template <>
struct js_traits<godot::HScrollBar &> {
	/// @throws exception
	static godot::HScrollBar &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::HScrollBar *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::HScrollBar &v) noexcept {
		return Value{ ctx, std::forward<godot::HScrollBar>(v) };
	}
};
template <>
struct js_traits<godot::HSeparator> {
	/// @throws exception
	static godot::HSeparator unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::HSeparator *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::HSeparator v) noexcept {
		return Value{ ctx, std::forward<godot::HSeparator>(v) };
	}
};
template <>
struct js_traits<godot::HSeparator &> {
	/// @throws exception
	static godot::HSeparator &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::HSeparator *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::HSeparator &v) noexcept {
		return Value{ ctx, std::forward<godot::HSeparator>(v) };
	}
};
template <>
struct js_traits<godot::HSlider> {
	/// @throws exception
	static godot::HSlider unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::HSlider *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::HSlider v) noexcept {
		return Value{ ctx, std::forward<godot::HSlider>(v) };
	}
};
template <>
struct js_traits<godot::HSlider &> {
	/// @throws exception
	static godot::HSlider &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::HSlider *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::HSlider &v) noexcept {
		return Value{ ctx, std::forward<godot::HSlider>(v) };
	}
};
template <>
struct js_traits<godot::HSplitContainer> {
	/// @throws exception
	static godot::HSplitContainer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::HSplitContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::HSplitContainer v) noexcept {
		return Value{ ctx, std::forward<godot::HSplitContainer>(v) };
	}
};
template <>
struct js_traits<godot::HSplitContainer &> {
	/// @throws exception
	static godot::HSplitContainer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::HSplitContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::HSplitContainer &v) noexcept {
		return Value{ ctx, std::forward<godot::HSplitContainer>(v) };
	}
};
template <>
struct js_traits<godot::HTTPClient> {
	/// @throws exception
	static godot::HTTPClient unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::HTTPClient *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::HTTPClient v) noexcept {
		return Value{ ctx, std::forward<godot::HTTPClient>(v) };
	}
};
template <>
struct js_traits<godot::HTTPClient &> {
	/// @throws exception
	static godot::HTTPClient &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::HTTPClient *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::HTTPClient &v) noexcept {
		return Value{ ctx, std::forward<godot::HTTPClient>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::HTTPClient>> {
	/// @throws exception
	static godot::Ref<godot::HTTPClient> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::HTTPClient>((godot::HTTPClient *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::HTTPClient> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::HTTPClient>>(v) };
	}
};
template <>
struct js_traits<godot::HTTPRequest> {
	/// @throws exception
	static godot::HTTPRequest unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::HTTPRequest *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::HTTPRequest v) noexcept {
		return Value{ ctx, std::forward<godot::HTTPRequest>(v) };
	}
};
template <>
struct js_traits<godot::HTTPRequest &> {
	/// @throws exception
	static godot::HTTPRequest &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::HTTPRequest *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::HTTPRequest &v) noexcept {
		return Value{ ctx, std::forward<godot::HTTPRequest>(v) };
	}
};
template <>
struct js_traits<godot::HashingContext> {
	/// @throws exception
	static godot::HashingContext unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::HashingContext *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::HashingContext v) noexcept {
		return Value{ ctx, std::forward<godot::HashingContext>(v) };
	}
};
template <>
struct js_traits<godot::HashingContext &> {
	/// @throws exception
	static godot::HashingContext &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::HashingContext *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::HashingContext &v) noexcept {
		return Value{ ctx, std::forward<godot::HashingContext>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::HashingContext>> {
	/// @throws exception
	static godot::Ref<godot::HashingContext> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::HashingContext>((godot::HashingContext *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::HashingContext> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::HashingContext>>(v) };
	}
};
template <>
struct js_traits<godot::HeightMapShape3D> {
	/// @throws exception
	static godot::HeightMapShape3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::HeightMapShape3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::HeightMapShape3D v) noexcept {
		return Value{ ctx, std::forward<godot::HeightMapShape3D>(v) };
	}
};
template <>
struct js_traits<godot::HeightMapShape3D &> {
	/// @throws exception
	static godot::HeightMapShape3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::HeightMapShape3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::HeightMapShape3D &v) noexcept {
		return Value{ ctx, std::forward<godot::HeightMapShape3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::HeightMapShape3D>> {
	/// @throws exception
	static godot::Ref<godot::HeightMapShape3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::HeightMapShape3D>((godot::HeightMapShape3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::HeightMapShape3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::HeightMapShape3D>>(v) };
	}
};
template <>
struct js_traits<godot::HingeJoint3D> {
	/// @throws exception
	static godot::HingeJoint3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::HingeJoint3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::HingeJoint3D v) noexcept {
		return Value{ ctx, std::forward<godot::HingeJoint3D>(v) };
	}
};
template <>
struct js_traits<godot::HingeJoint3D &> {
	/// @throws exception
	static godot::HingeJoint3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::HingeJoint3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::HingeJoint3D &v) noexcept {
		return Value{ ctx, std::forward<godot::HingeJoint3D>(v) };
	}
};
template <>
struct js_traits<godot::IP> {
	/// @throws exception
	static godot::IP unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::IP *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::IP v) noexcept {
		return Value{ ctx, std::forward<godot::IP>(v) };
	}
};
template <>
struct js_traits<godot::IP &> {
	/// @throws exception
	static godot::IP &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::IP *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::IP &v) noexcept {
		return Value{ ctx, std::forward<godot::IP>(v) };
	}
};
template <>
struct js_traits<godot::Image> {
	/// @throws exception
	static godot::Image unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Image *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Image v) noexcept {
		return Value{ ctx, std::forward<godot::Image>(v) };
	}
};
template <>
struct js_traits<godot::Image &> {
	/// @throws exception
	static godot::Image &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Image *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Image &v) noexcept {
		return Value{ ctx, std::forward<godot::Image>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Image>> {
	/// @throws exception
	static godot::Ref<godot::Image> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Image>((godot::Image *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Image> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Image>>(v) };
	}
};
template <>
struct js_traits<godot::ImageFormatLoader> {
	/// @throws exception
	static godot::ImageFormatLoader unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ImageFormatLoader *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ImageFormatLoader v) noexcept {
		return Value{ ctx, std::forward<godot::ImageFormatLoader>(v) };
	}
};
template <>
struct js_traits<godot::ImageFormatLoader &> {
	/// @throws exception
	static godot::ImageFormatLoader &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ImageFormatLoader *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ImageFormatLoader &v) noexcept {
		return Value{ ctx, std::forward<godot::ImageFormatLoader>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ImageFormatLoader>> {
	/// @throws exception
	static godot::Ref<godot::ImageFormatLoader> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ImageFormatLoader>((godot::ImageFormatLoader *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ImageFormatLoader> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ImageFormatLoader>>(v) };
	}
};
template <>
struct js_traits<godot::ImageFormatLoaderExtension> {
	/// @throws exception
	static godot::ImageFormatLoaderExtension unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ImageFormatLoaderExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ImageFormatLoaderExtension v) noexcept {
		return Value{ ctx, std::forward<godot::ImageFormatLoaderExtension>(v) };
	}
};
template <>
struct js_traits<godot::ImageFormatLoaderExtension &> {
	/// @throws exception
	static godot::ImageFormatLoaderExtension &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ImageFormatLoaderExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ImageFormatLoaderExtension &v) noexcept {
		return Value{ ctx, std::forward<godot::ImageFormatLoaderExtension>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ImageFormatLoaderExtension>> {
	/// @throws exception
	static godot::Ref<godot::ImageFormatLoaderExtension> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ImageFormatLoaderExtension>((godot::ImageFormatLoaderExtension *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ImageFormatLoaderExtension> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ImageFormatLoaderExtension>>(v) };
	}
};
template <>
struct js_traits<godot::ImageTexture> {
	/// @throws exception
	static godot::ImageTexture unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ImageTexture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ImageTexture v) noexcept {
		return Value{ ctx, std::forward<godot::ImageTexture>(v) };
	}
};
template <>
struct js_traits<godot::ImageTexture &> {
	/// @throws exception
	static godot::ImageTexture &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ImageTexture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ImageTexture &v) noexcept {
		return Value{ ctx, std::forward<godot::ImageTexture>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ImageTexture>> {
	/// @throws exception
	static godot::Ref<godot::ImageTexture> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ImageTexture>((godot::ImageTexture *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ImageTexture> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ImageTexture>>(v) };
	}
};
template <>
struct js_traits<godot::ImageTexture3D> {
	/// @throws exception
	static godot::ImageTexture3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ImageTexture3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ImageTexture3D v) noexcept {
		return Value{ ctx, std::forward<godot::ImageTexture3D>(v) };
	}
};
template <>
struct js_traits<godot::ImageTexture3D &> {
	/// @throws exception
	static godot::ImageTexture3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ImageTexture3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ImageTexture3D &v) noexcept {
		return Value{ ctx, std::forward<godot::ImageTexture3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ImageTexture3D>> {
	/// @throws exception
	static godot::Ref<godot::ImageTexture3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ImageTexture3D>((godot::ImageTexture3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ImageTexture3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ImageTexture3D>>(v) };
	}
};
template <>
struct js_traits<godot::ImageTextureLayered> {
	/// @throws exception
	static godot::ImageTextureLayered unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ImageTextureLayered *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ImageTextureLayered v) noexcept {
		return Value{ ctx, std::forward<godot::ImageTextureLayered>(v) };
	}
};
template <>
struct js_traits<godot::ImageTextureLayered &> {
	/// @throws exception
	static godot::ImageTextureLayered &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ImageTextureLayered *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ImageTextureLayered &v) noexcept {
		return Value{ ctx, std::forward<godot::ImageTextureLayered>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ImageTextureLayered>> {
	/// @throws exception
	static godot::Ref<godot::ImageTextureLayered> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ImageTextureLayered>((godot::ImageTextureLayered *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ImageTextureLayered> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ImageTextureLayered>>(v) };
	}
};
template <>
struct js_traits<godot::ImmediateMesh> {
	/// @throws exception
	static godot::ImmediateMesh unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ImmediateMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ImmediateMesh v) noexcept {
		return Value{ ctx, std::forward<godot::ImmediateMesh>(v) };
	}
};
template <>
struct js_traits<godot::ImmediateMesh &> {
	/// @throws exception
	static godot::ImmediateMesh &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ImmediateMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ImmediateMesh &v) noexcept {
		return Value{ ctx, std::forward<godot::ImmediateMesh>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ImmediateMesh>> {
	/// @throws exception
	static godot::Ref<godot::ImmediateMesh> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ImmediateMesh>((godot::ImmediateMesh *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ImmediateMesh> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ImmediateMesh>>(v) };
	}
};
template <>
struct js_traits<godot::ImporterMesh> {
	/// @throws exception
	static godot::ImporterMesh unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ImporterMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ImporterMesh v) noexcept {
		return Value{ ctx, std::forward<godot::ImporterMesh>(v) };
	}
};
template <>
struct js_traits<godot::ImporterMesh &> {
	/// @throws exception
	static godot::ImporterMesh &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ImporterMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ImporterMesh &v) noexcept {
		return Value{ ctx, std::forward<godot::ImporterMesh>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ImporterMesh>> {
	/// @throws exception
	static godot::Ref<godot::ImporterMesh> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ImporterMesh>((godot::ImporterMesh *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ImporterMesh> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ImporterMesh>>(v) };
	}
};
template <>
struct js_traits<godot::ImporterMeshInstance3D> {
	/// @throws exception
	static godot::ImporterMeshInstance3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ImporterMeshInstance3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ImporterMeshInstance3D v) noexcept {
		return Value{ ctx, std::forward<godot::ImporterMeshInstance3D>(v) };
	}
};
template <>
struct js_traits<godot::ImporterMeshInstance3D &> {
	/// @throws exception
	static godot::ImporterMeshInstance3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ImporterMeshInstance3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ImporterMeshInstance3D &v) noexcept {
		return Value{ ctx, std::forward<godot::ImporterMeshInstance3D>(v) };
	}
};
template <>
struct js_traits<godot::Input> {
	/// @throws exception
	static godot::Input unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Input *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Input v) noexcept {
		return Value{ ctx, std::forward<godot::Input>(v) };
	}
};
template <>
struct js_traits<godot::Input &> {
	/// @throws exception
	static godot::Input &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Input *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Input &v) noexcept {
		return Value{ ctx, std::forward<godot::Input>(v) };
	}
};
template <>
struct js_traits<godot::InputEvent> {
	/// @throws exception
	static godot::InputEvent unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEvent *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEvent v) noexcept {
		return Value{ ctx, std::forward<godot::InputEvent>(v) };
	}
};
template <>
struct js_traits<godot::InputEvent &> {
	/// @throws exception
	static godot::InputEvent &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEvent *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEvent &v) noexcept {
		return Value{ ctx, std::forward<godot::InputEvent>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::InputEvent>> {
	/// @throws exception
	static godot::Ref<godot::InputEvent> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::InputEvent>((godot::InputEvent *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::InputEvent> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::InputEvent>>(v) };
	}
};
template <>
struct js_traits<godot::InputEventAction> {
	/// @throws exception
	static godot::InputEventAction unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEventAction *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEventAction v) noexcept {
		return Value{ ctx, std::forward<godot::InputEventAction>(v) };
	}
};
template <>
struct js_traits<godot::InputEventAction &> {
	/// @throws exception
	static godot::InputEventAction &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEventAction *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEventAction &v) noexcept {
		return Value{ ctx, std::forward<godot::InputEventAction>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::InputEventAction>> {
	/// @throws exception
	static godot::Ref<godot::InputEventAction> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::InputEventAction>((godot::InputEventAction *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::InputEventAction> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::InputEventAction>>(v) };
	}
};
template <>
struct js_traits<godot::InputEventFromWindow> {
	/// @throws exception
	static godot::InputEventFromWindow unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEventFromWindow *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEventFromWindow v) noexcept {
		return Value{ ctx, std::forward<godot::InputEventFromWindow>(v) };
	}
};
template <>
struct js_traits<godot::InputEventFromWindow &> {
	/// @throws exception
	static godot::InputEventFromWindow &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEventFromWindow *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEventFromWindow &v) noexcept {
		return Value{ ctx, std::forward<godot::InputEventFromWindow>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::InputEventFromWindow>> {
	/// @throws exception
	static godot::Ref<godot::InputEventFromWindow> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::InputEventFromWindow>((godot::InputEventFromWindow *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::InputEventFromWindow> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::InputEventFromWindow>>(v) };
	}
};
template <>
struct js_traits<godot::InputEventGesture> {
	/// @throws exception
	static godot::InputEventGesture unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEventGesture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEventGesture v) noexcept {
		return Value{ ctx, std::forward<godot::InputEventGesture>(v) };
	}
};
template <>
struct js_traits<godot::InputEventGesture &> {
	/// @throws exception
	static godot::InputEventGesture &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEventGesture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEventGesture &v) noexcept {
		return Value{ ctx, std::forward<godot::InputEventGesture>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::InputEventGesture>> {
	/// @throws exception
	static godot::Ref<godot::InputEventGesture> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::InputEventGesture>((godot::InputEventGesture *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::InputEventGesture> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::InputEventGesture>>(v) };
	}
};
template <>
struct js_traits<godot::InputEventJoypadButton> {
	/// @throws exception
	static godot::InputEventJoypadButton unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEventJoypadButton *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEventJoypadButton v) noexcept {
		return Value{ ctx, std::forward<godot::InputEventJoypadButton>(v) };
	}
};
template <>
struct js_traits<godot::InputEventJoypadButton &> {
	/// @throws exception
	static godot::InputEventJoypadButton &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEventJoypadButton *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEventJoypadButton &v) noexcept {
		return Value{ ctx, std::forward<godot::InputEventJoypadButton>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::InputEventJoypadButton>> {
	/// @throws exception
	static godot::Ref<godot::InputEventJoypadButton> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::InputEventJoypadButton>((godot::InputEventJoypadButton *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::InputEventJoypadButton> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::InputEventJoypadButton>>(v) };
	}
};
template <>
struct js_traits<godot::InputEventJoypadMotion> {
	/// @throws exception
	static godot::InputEventJoypadMotion unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEventJoypadMotion *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEventJoypadMotion v) noexcept {
		return Value{ ctx, std::forward<godot::InputEventJoypadMotion>(v) };
	}
};
template <>
struct js_traits<godot::InputEventJoypadMotion &> {
	/// @throws exception
	static godot::InputEventJoypadMotion &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEventJoypadMotion *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEventJoypadMotion &v) noexcept {
		return Value{ ctx, std::forward<godot::InputEventJoypadMotion>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::InputEventJoypadMotion>> {
	/// @throws exception
	static godot::Ref<godot::InputEventJoypadMotion> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::InputEventJoypadMotion>((godot::InputEventJoypadMotion *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::InputEventJoypadMotion> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::InputEventJoypadMotion>>(v) };
	}
};
template <>
struct js_traits<godot::InputEventKey> {
	/// @throws exception
	static godot::InputEventKey unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEventKey *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEventKey v) noexcept {
		return Value{ ctx, std::forward<godot::InputEventKey>(v) };
	}
};
template <>
struct js_traits<godot::InputEventKey &> {
	/// @throws exception
	static godot::InputEventKey &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEventKey *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEventKey &v) noexcept {
		return Value{ ctx, std::forward<godot::InputEventKey>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::InputEventKey>> {
	/// @throws exception
	static godot::Ref<godot::InputEventKey> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::InputEventKey>((godot::InputEventKey *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::InputEventKey> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::InputEventKey>>(v) };
	}
};
template <>
struct js_traits<godot::InputEventMIDI> {
	/// @throws exception
	static godot::InputEventMIDI unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEventMIDI *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEventMIDI v) noexcept {
		return Value{ ctx, std::forward<godot::InputEventMIDI>(v) };
	}
};
template <>
struct js_traits<godot::InputEventMIDI &> {
	/// @throws exception
	static godot::InputEventMIDI &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEventMIDI *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEventMIDI &v) noexcept {
		return Value{ ctx, std::forward<godot::InputEventMIDI>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::InputEventMIDI>> {
	/// @throws exception
	static godot::Ref<godot::InputEventMIDI> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::InputEventMIDI>((godot::InputEventMIDI *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::InputEventMIDI> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::InputEventMIDI>>(v) };
	}
};
template <>
struct js_traits<godot::InputEventMagnifyGesture> {
	/// @throws exception
	static godot::InputEventMagnifyGesture unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEventMagnifyGesture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEventMagnifyGesture v) noexcept {
		return Value{ ctx, std::forward<godot::InputEventMagnifyGesture>(v) };
	}
};
template <>
struct js_traits<godot::InputEventMagnifyGesture &> {
	/// @throws exception
	static godot::InputEventMagnifyGesture &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEventMagnifyGesture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEventMagnifyGesture &v) noexcept {
		return Value{ ctx, std::forward<godot::InputEventMagnifyGesture>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::InputEventMagnifyGesture>> {
	/// @throws exception
	static godot::Ref<godot::InputEventMagnifyGesture> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::InputEventMagnifyGesture>((godot::InputEventMagnifyGesture *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::InputEventMagnifyGesture> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::InputEventMagnifyGesture>>(v) };
	}
};
template <>
struct js_traits<godot::InputEventMouse> {
	/// @throws exception
	static godot::InputEventMouse unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEventMouse *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEventMouse v) noexcept {
		return Value{ ctx, std::forward<godot::InputEventMouse>(v) };
	}
};
template <>
struct js_traits<godot::InputEventMouse &> {
	/// @throws exception
	static godot::InputEventMouse &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEventMouse *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEventMouse &v) noexcept {
		return Value{ ctx, std::forward<godot::InputEventMouse>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::InputEventMouse>> {
	/// @throws exception
	static godot::Ref<godot::InputEventMouse> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::InputEventMouse>((godot::InputEventMouse *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::InputEventMouse> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::InputEventMouse>>(v) };
	}
};
template <>
struct js_traits<godot::InputEventMouseButton> {
	/// @throws exception
	static godot::InputEventMouseButton unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEventMouseButton *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEventMouseButton v) noexcept {
		return Value{ ctx, std::forward<godot::InputEventMouseButton>(v) };
	}
};
template <>
struct js_traits<godot::InputEventMouseButton &> {
	/// @throws exception
	static godot::InputEventMouseButton &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEventMouseButton *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEventMouseButton &v) noexcept {
		return Value{ ctx, std::forward<godot::InputEventMouseButton>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::InputEventMouseButton>> {
	/// @throws exception
	static godot::Ref<godot::InputEventMouseButton> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::InputEventMouseButton>((godot::InputEventMouseButton *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::InputEventMouseButton> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::InputEventMouseButton>>(v) };
	}
};
template <>
struct js_traits<godot::InputEventMouseMotion> {
	/// @throws exception
	static godot::InputEventMouseMotion unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEventMouseMotion *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEventMouseMotion v) noexcept {
		return Value{ ctx, std::forward<godot::InputEventMouseMotion>(v) };
	}
};
template <>
struct js_traits<godot::InputEventMouseMotion &> {
	/// @throws exception
	static godot::InputEventMouseMotion &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEventMouseMotion *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEventMouseMotion &v) noexcept {
		return Value{ ctx, std::forward<godot::InputEventMouseMotion>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::InputEventMouseMotion>> {
	/// @throws exception
	static godot::Ref<godot::InputEventMouseMotion> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::InputEventMouseMotion>((godot::InputEventMouseMotion *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::InputEventMouseMotion> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::InputEventMouseMotion>>(v) };
	}
};
template <>
struct js_traits<godot::InputEventPanGesture> {
	/// @throws exception
	static godot::InputEventPanGesture unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEventPanGesture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEventPanGesture v) noexcept {
		return Value{ ctx, std::forward<godot::InputEventPanGesture>(v) };
	}
};
template <>
struct js_traits<godot::InputEventPanGesture &> {
	/// @throws exception
	static godot::InputEventPanGesture &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEventPanGesture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEventPanGesture &v) noexcept {
		return Value{ ctx, std::forward<godot::InputEventPanGesture>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::InputEventPanGesture>> {
	/// @throws exception
	static godot::Ref<godot::InputEventPanGesture> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::InputEventPanGesture>((godot::InputEventPanGesture *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::InputEventPanGesture> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::InputEventPanGesture>>(v) };
	}
};
template <>
struct js_traits<godot::InputEventScreenDrag> {
	/// @throws exception
	static godot::InputEventScreenDrag unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEventScreenDrag *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEventScreenDrag v) noexcept {
		return Value{ ctx, std::forward<godot::InputEventScreenDrag>(v) };
	}
};
template <>
struct js_traits<godot::InputEventScreenDrag &> {
	/// @throws exception
	static godot::InputEventScreenDrag &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEventScreenDrag *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEventScreenDrag &v) noexcept {
		return Value{ ctx, std::forward<godot::InputEventScreenDrag>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::InputEventScreenDrag>> {
	/// @throws exception
	static godot::Ref<godot::InputEventScreenDrag> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::InputEventScreenDrag>((godot::InputEventScreenDrag *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::InputEventScreenDrag> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::InputEventScreenDrag>>(v) };
	}
};
template <>
struct js_traits<godot::InputEventScreenTouch> {
	/// @throws exception
	static godot::InputEventScreenTouch unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEventScreenTouch *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEventScreenTouch v) noexcept {
		return Value{ ctx, std::forward<godot::InputEventScreenTouch>(v) };
	}
};
template <>
struct js_traits<godot::InputEventScreenTouch &> {
	/// @throws exception
	static godot::InputEventScreenTouch &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEventScreenTouch *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEventScreenTouch &v) noexcept {
		return Value{ ctx, std::forward<godot::InputEventScreenTouch>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::InputEventScreenTouch>> {
	/// @throws exception
	static godot::Ref<godot::InputEventScreenTouch> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::InputEventScreenTouch>((godot::InputEventScreenTouch *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::InputEventScreenTouch> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::InputEventScreenTouch>>(v) };
	}
};
template <>
struct js_traits<godot::InputEventShortcut> {
	/// @throws exception
	static godot::InputEventShortcut unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEventShortcut *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEventShortcut v) noexcept {
		return Value{ ctx, std::forward<godot::InputEventShortcut>(v) };
	}
};
template <>
struct js_traits<godot::InputEventShortcut &> {
	/// @throws exception
	static godot::InputEventShortcut &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEventShortcut *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEventShortcut &v) noexcept {
		return Value{ ctx, std::forward<godot::InputEventShortcut>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::InputEventShortcut>> {
	/// @throws exception
	static godot::Ref<godot::InputEventShortcut> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::InputEventShortcut>((godot::InputEventShortcut *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::InputEventShortcut> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::InputEventShortcut>>(v) };
	}
};
template <>
struct js_traits<godot::InputEventWithModifiers> {
	/// @throws exception
	static godot::InputEventWithModifiers unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEventWithModifiers *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEventWithModifiers v) noexcept {
		return Value{ ctx, std::forward<godot::InputEventWithModifiers>(v) };
	}
};
template <>
struct js_traits<godot::InputEventWithModifiers &> {
	/// @throws exception
	static godot::InputEventWithModifiers &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputEventWithModifiers *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputEventWithModifiers &v) noexcept {
		return Value{ ctx, std::forward<godot::InputEventWithModifiers>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::InputEventWithModifiers>> {
	/// @throws exception
	static godot::Ref<godot::InputEventWithModifiers> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::InputEventWithModifiers>((godot::InputEventWithModifiers *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::InputEventWithModifiers> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::InputEventWithModifiers>>(v) };
	}
};
template <>
struct js_traits<godot::InputMap> {
	/// @throws exception
	static godot::InputMap unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputMap *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputMap v) noexcept {
		return Value{ ctx, std::forward<godot::InputMap>(v) };
	}
};
template <>
struct js_traits<godot::InputMap &> {
	/// @throws exception
	static godot::InputMap &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InputMap *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InputMap &v) noexcept {
		return Value{ ctx, std::forward<godot::InputMap>(v) };
	}
};
template <>
struct js_traits<godot::InstancePlaceholder> {
	/// @throws exception
	static godot::InstancePlaceholder unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InstancePlaceholder *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InstancePlaceholder v) noexcept {
		return Value{ ctx, std::forward<godot::InstancePlaceholder>(v) };
	}
};
template <>
struct js_traits<godot::InstancePlaceholder &> {
	/// @throws exception
	static godot::InstancePlaceholder &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::InstancePlaceholder *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::InstancePlaceholder &v) noexcept {
		return Value{ ctx, std::forward<godot::InstancePlaceholder>(v) };
	}
};
template <>
struct js_traits<godot::IntervalTweener> {
	/// @throws exception
	static godot::IntervalTweener unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::IntervalTweener *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::IntervalTweener v) noexcept {
		return Value{ ctx, std::forward<godot::IntervalTweener>(v) };
	}
};
template <>
struct js_traits<godot::IntervalTweener &> {
	/// @throws exception
	static godot::IntervalTweener &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::IntervalTweener *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::IntervalTweener &v) noexcept {
		return Value{ ctx, std::forward<godot::IntervalTweener>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::IntervalTweener>> {
	/// @throws exception
	static godot::Ref<godot::IntervalTweener> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::IntervalTweener>((godot::IntervalTweener *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::IntervalTweener> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::IntervalTweener>>(v) };
	}
};
template <>
struct js_traits<godot::ItemList> {
	/// @throws exception
	static godot::ItemList unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ItemList *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ItemList v) noexcept {
		return Value{ ctx, std::forward<godot::ItemList>(v) };
	}
};
template <>
struct js_traits<godot::ItemList &> {
	/// @throws exception
	static godot::ItemList &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ItemList *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ItemList &v) noexcept {
		return Value{ ctx, std::forward<godot::ItemList>(v) };
	}
};
template <>
struct js_traits<godot::JNISingleton> {
	/// @throws exception
	static godot::JNISingleton unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::JNISingleton *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::JNISingleton v) noexcept {
		return Value{ ctx, std::forward<godot::JNISingleton>(v) };
	}
};
template <>
struct js_traits<godot::JNISingleton &> {
	/// @throws exception
	static godot::JNISingleton &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::JNISingleton *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::JNISingleton &v) noexcept {
		return Value{ ctx, std::forward<godot::JNISingleton>(v) };
	}
};
template <>
struct js_traits<godot::JSON> {
	/// @throws exception
	static godot::JSON unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::JSON *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::JSON v) noexcept {
		return Value{ ctx, std::forward<godot::JSON>(v) };
	}
};
template <>
struct js_traits<godot::JSON &> {
	/// @throws exception
	static godot::JSON &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::JSON *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::JSON &v) noexcept {
		return Value{ ctx, std::forward<godot::JSON>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::JSON>> {
	/// @throws exception
	static godot::Ref<godot::JSON> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::JSON>((godot::JSON *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::JSON> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::JSON>>(v) };
	}
};
template <>
struct js_traits<godot::JSONRPC> {
	/// @throws exception
	static godot::JSONRPC unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::JSONRPC *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::JSONRPC v) noexcept {
		return Value{ ctx, std::forward<godot::JSONRPC>(v) };
	}
};
template <>
struct js_traits<godot::JSONRPC &> {
	/// @throws exception
	static godot::JSONRPC &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::JSONRPC *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::JSONRPC &v) noexcept {
		return Value{ ctx, std::forward<godot::JSONRPC>(v) };
	}
};
template <>
struct js_traits<godot::JavaClass> {
	/// @throws exception
	static godot::JavaClass unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::JavaClass *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::JavaClass v) noexcept {
		return Value{ ctx, std::forward<godot::JavaClass>(v) };
	}
};
template <>
struct js_traits<godot::JavaClass &> {
	/// @throws exception
	static godot::JavaClass &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::JavaClass *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::JavaClass &v) noexcept {
		return Value{ ctx, std::forward<godot::JavaClass>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::JavaClass>> {
	/// @throws exception
	static godot::Ref<godot::JavaClass> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::JavaClass>((godot::JavaClass *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::JavaClass> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::JavaClass>>(v) };
	}
};
template <>
struct js_traits<godot::JavaClassWrapper> {
	/// @throws exception
	static godot::JavaClassWrapper unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::JavaClassWrapper *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::JavaClassWrapper v) noexcept {
		return Value{ ctx, std::forward<godot::JavaClassWrapper>(v) };
	}
};
template <>
struct js_traits<godot::JavaClassWrapper &> {
	/// @throws exception
	static godot::JavaClassWrapper &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::JavaClassWrapper *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::JavaClassWrapper &v) noexcept {
		return Value{ ctx, std::forward<godot::JavaClassWrapper>(v) };
	}
};
template <>
struct js_traits<godot::JavaScriptBridge> {
	/// @throws exception
	static godot::JavaScriptBridge unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::JavaScriptBridge *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::JavaScriptBridge v) noexcept {
		return Value{ ctx, std::forward<godot::JavaScriptBridge>(v) };
	}
};
template <>
struct js_traits<godot::JavaScriptBridge &> {
	/// @throws exception
	static godot::JavaScriptBridge &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::JavaScriptBridge *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::JavaScriptBridge &v) noexcept {
		return Value{ ctx, std::forward<godot::JavaScriptBridge>(v) };
	}
};
template <>
struct js_traits<godot::JavaScriptObject> {
	/// @throws exception
	static godot::JavaScriptObject unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::JavaScriptObject *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::JavaScriptObject v) noexcept {
		return Value{ ctx, std::forward<godot::JavaScriptObject>(v) };
	}
};
template <>
struct js_traits<godot::JavaScriptObject &> {
	/// @throws exception
	static godot::JavaScriptObject &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::JavaScriptObject *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::JavaScriptObject &v) noexcept {
		return Value{ ctx, std::forward<godot::JavaScriptObject>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::JavaScriptObject>> {
	/// @throws exception
	static godot::Ref<godot::JavaScriptObject> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::JavaScriptObject>((godot::JavaScriptObject *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::JavaScriptObject> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::JavaScriptObject>>(v) };
	}
};
template <>
struct js_traits<godot::Joint2D> {
	/// @throws exception
	static godot::Joint2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Joint2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Joint2D v) noexcept {
		return Value{ ctx, std::forward<godot::Joint2D>(v) };
	}
};
template <>
struct js_traits<godot::Joint2D &> {
	/// @throws exception
	static godot::Joint2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Joint2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Joint2D &v) noexcept {
		return Value{ ctx, std::forward<godot::Joint2D>(v) };
	}
};
template <>
struct js_traits<godot::Joint3D> {
	/// @throws exception
	static godot::Joint3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Joint3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Joint3D v) noexcept {
		return Value{ ctx, std::forward<godot::Joint3D>(v) };
	}
};
template <>
struct js_traits<godot::Joint3D &> {
	/// @throws exception
	static godot::Joint3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Joint3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Joint3D &v) noexcept {
		return Value{ ctx, std::forward<godot::Joint3D>(v) };
	}
};
template <>
struct js_traits<godot::KinematicCollision2D> {
	/// @throws exception
	static godot::KinematicCollision2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::KinematicCollision2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::KinematicCollision2D v) noexcept {
		return Value{ ctx, std::forward<godot::KinematicCollision2D>(v) };
	}
};
template <>
struct js_traits<godot::KinematicCollision2D &> {
	/// @throws exception
	static godot::KinematicCollision2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::KinematicCollision2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::KinematicCollision2D &v) noexcept {
		return Value{ ctx, std::forward<godot::KinematicCollision2D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::KinematicCollision2D>> {
	/// @throws exception
	static godot::Ref<godot::KinematicCollision2D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::KinematicCollision2D>((godot::KinematicCollision2D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::KinematicCollision2D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::KinematicCollision2D>>(v) };
	}
};
template <>
struct js_traits<godot::KinematicCollision3D> {
	/// @throws exception
	static godot::KinematicCollision3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::KinematicCollision3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::KinematicCollision3D v) noexcept {
		return Value{ ctx, std::forward<godot::KinematicCollision3D>(v) };
	}
};
template <>
struct js_traits<godot::KinematicCollision3D &> {
	/// @throws exception
	static godot::KinematicCollision3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::KinematicCollision3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::KinematicCollision3D &v) noexcept {
		return Value{ ctx, std::forward<godot::KinematicCollision3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::KinematicCollision3D>> {
	/// @throws exception
	static godot::Ref<godot::KinematicCollision3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::KinematicCollision3D>((godot::KinematicCollision3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::KinematicCollision3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::KinematicCollision3D>>(v) };
	}
};
template <>
struct js_traits<godot::Label> {
	/// @throws exception
	static godot::Label unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Label *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Label v) noexcept {
		return Value{ ctx, std::forward<godot::Label>(v) };
	}
};
template <>
struct js_traits<godot::Label &> {
	/// @throws exception
	static godot::Label &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Label *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Label &v) noexcept {
		return Value{ ctx, std::forward<godot::Label>(v) };
	}
};
template <>
struct js_traits<godot::Label3D> {
	/// @throws exception
	static godot::Label3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Label3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Label3D v) noexcept {
		return Value{ ctx, std::forward<godot::Label3D>(v) };
	}
};
template <>
struct js_traits<godot::Label3D &> {
	/// @throws exception
	static godot::Label3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Label3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Label3D &v) noexcept {
		return Value{ ctx, std::forward<godot::Label3D>(v) };
	}
};
template <>
struct js_traits<godot::LabelSettings> {
	/// @throws exception
	static godot::LabelSettings unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::LabelSettings *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::LabelSettings v) noexcept {
		return Value{ ctx, std::forward<godot::LabelSettings>(v) };
	}
};
template <>
struct js_traits<godot::LabelSettings &> {
	/// @throws exception
	static godot::LabelSettings &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::LabelSettings *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::LabelSettings &v) noexcept {
		return Value{ ctx, std::forward<godot::LabelSettings>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::LabelSettings>> {
	/// @throws exception
	static godot::Ref<godot::LabelSettings> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::LabelSettings>((godot::LabelSettings *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::LabelSettings> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::LabelSettings>>(v) };
	}
};
template <>
struct js_traits<godot::Light2D> {
	/// @throws exception
	static godot::Light2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Light2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Light2D v) noexcept {
		return Value{ ctx, std::forward<godot::Light2D>(v) };
	}
};
template <>
struct js_traits<godot::Light2D &> {
	/// @throws exception
	static godot::Light2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Light2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Light2D &v) noexcept {
		return Value{ ctx, std::forward<godot::Light2D>(v) };
	}
};
template <>
struct js_traits<godot::Light3D> {
	/// @throws exception
	static godot::Light3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Light3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Light3D v) noexcept {
		return Value{ ctx, std::forward<godot::Light3D>(v) };
	}
};
template <>
struct js_traits<godot::Light3D &> {
	/// @throws exception
	static godot::Light3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Light3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Light3D &v) noexcept {
		return Value{ ctx, std::forward<godot::Light3D>(v) };
	}
};
template <>
struct js_traits<godot::LightOccluder2D> {
	/// @throws exception
	static godot::LightOccluder2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::LightOccluder2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::LightOccluder2D v) noexcept {
		return Value{ ctx, std::forward<godot::LightOccluder2D>(v) };
	}
};
template <>
struct js_traits<godot::LightOccluder2D &> {
	/// @throws exception
	static godot::LightOccluder2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::LightOccluder2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::LightOccluder2D &v) noexcept {
		return Value{ ctx, std::forward<godot::LightOccluder2D>(v) };
	}
};
template <>
struct js_traits<godot::LightmapGI> {
	/// @throws exception
	static godot::LightmapGI unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::LightmapGI *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::LightmapGI v) noexcept {
		return Value{ ctx, std::forward<godot::LightmapGI>(v) };
	}
};
template <>
struct js_traits<godot::LightmapGI &> {
	/// @throws exception
	static godot::LightmapGI &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::LightmapGI *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::LightmapGI &v) noexcept {
		return Value{ ctx, std::forward<godot::LightmapGI>(v) };
	}
};
template <>
struct js_traits<godot::LightmapGIData> {
	/// @throws exception
	static godot::LightmapGIData unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::LightmapGIData *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::LightmapGIData v) noexcept {
		return Value{ ctx, std::forward<godot::LightmapGIData>(v) };
	}
};
template <>
struct js_traits<godot::LightmapGIData &> {
	/// @throws exception
	static godot::LightmapGIData &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::LightmapGIData *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::LightmapGIData &v) noexcept {
		return Value{ ctx, std::forward<godot::LightmapGIData>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::LightmapGIData>> {
	/// @throws exception
	static godot::Ref<godot::LightmapGIData> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::LightmapGIData>((godot::LightmapGIData *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::LightmapGIData> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::LightmapGIData>>(v) };
	}
};
template <>
struct js_traits<godot::LightmapProbe> {
	/// @throws exception
	static godot::LightmapProbe unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::LightmapProbe *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::LightmapProbe v) noexcept {
		return Value{ ctx, std::forward<godot::LightmapProbe>(v) };
	}
};
template <>
struct js_traits<godot::LightmapProbe &> {
	/// @throws exception
	static godot::LightmapProbe &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::LightmapProbe *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::LightmapProbe &v) noexcept {
		return Value{ ctx, std::forward<godot::LightmapProbe>(v) };
	}
};
template <>
struct js_traits<godot::Lightmapper> {
	/// @throws exception
	static godot::Lightmapper unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Lightmapper *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Lightmapper v) noexcept {
		return Value{ ctx, std::forward<godot::Lightmapper>(v) };
	}
};
template <>
struct js_traits<godot::Lightmapper &> {
	/// @throws exception
	static godot::Lightmapper &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Lightmapper *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Lightmapper &v) noexcept {
		return Value{ ctx, std::forward<godot::Lightmapper>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Lightmapper>> {
	/// @throws exception
	static godot::Ref<godot::Lightmapper> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Lightmapper>((godot::Lightmapper *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Lightmapper> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Lightmapper>>(v) };
	}
};
template <>
struct js_traits<godot::LightmapperRD> {
	/// @throws exception
	static godot::LightmapperRD unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::LightmapperRD *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::LightmapperRD v) noexcept {
		return Value{ ctx, std::forward<godot::LightmapperRD>(v) };
	}
};
template <>
struct js_traits<godot::LightmapperRD &> {
	/// @throws exception
	static godot::LightmapperRD &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::LightmapperRD *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::LightmapperRD &v) noexcept {
		return Value{ ctx, std::forward<godot::LightmapperRD>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::LightmapperRD>> {
	/// @throws exception
	static godot::Ref<godot::LightmapperRD> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::LightmapperRD>((godot::LightmapperRD *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::LightmapperRD> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::LightmapperRD>>(v) };
	}
};
template <>
struct js_traits<godot::Line2D> {
	/// @throws exception
	static godot::Line2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Line2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Line2D v) noexcept {
		return Value{ ctx, std::forward<godot::Line2D>(v) };
	}
};
template <>
struct js_traits<godot::Line2D &> {
	/// @throws exception
	static godot::Line2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Line2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Line2D &v) noexcept {
		return Value{ ctx, std::forward<godot::Line2D>(v) };
	}
};
template <>
struct js_traits<godot::LineEdit> {
	/// @throws exception
	static godot::LineEdit unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::LineEdit *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::LineEdit v) noexcept {
		return Value{ ctx, std::forward<godot::LineEdit>(v) };
	}
};
template <>
struct js_traits<godot::LineEdit &> {
	/// @throws exception
	static godot::LineEdit &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::LineEdit *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::LineEdit &v) noexcept {
		return Value{ ctx, std::forward<godot::LineEdit>(v) };
	}
};
template <>
struct js_traits<godot::LinkButton> {
	/// @throws exception
	static godot::LinkButton unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::LinkButton *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::LinkButton v) noexcept {
		return Value{ ctx, std::forward<godot::LinkButton>(v) };
	}
};
template <>
struct js_traits<godot::LinkButton &> {
	/// @throws exception
	static godot::LinkButton &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::LinkButton *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::LinkButton &v) noexcept {
		return Value{ ctx, std::forward<godot::LinkButton>(v) };
	}
};
template <>
struct js_traits<godot::MainLoop> {
	/// @throws exception
	static godot::MainLoop unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MainLoop *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MainLoop v) noexcept {
		return Value{ ctx, std::forward<godot::MainLoop>(v) };
	}
};
template <>
struct js_traits<godot::MainLoop &> {
	/// @throws exception
	static godot::MainLoop &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MainLoop *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MainLoop &v) noexcept {
		return Value{ ctx, std::forward<godot::MainLoop>(v) };
	}
};
template <>
struct js_traits<godot::MarginContainer> {
	/// @throws exception
	static godot::MarginContainer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MarginContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MarginContainer v) noexcept {
		return Value{ ctx, std::forward<godot::MarginContainer>(v) };
	}
};
template <>
struct js_traits<godot::MarginContainer &> {
	/// @throws exception
	static godot::MarginContainer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MarginContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MarginContainer &v) noexcept {
		return Value{ ctx, std::forward<godot::MarginContainer>(v) };
	}
};
template <>
struct js_traits<godot::Marker2D> {
	/// @throws exception
	static godot::Marker2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Marker2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Marker2D v) noexcept {
		return Value{ ctx, std::forward<godot::Marker2D>(v) };
	}
};
template <>
struct js_traits<godot::Marker2D &> {
	/// @throws exception
	static godot::Marker2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Marker2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Marker2D &v) noexcept {
		return Value{ ctx, std::forward<godot::Marker2D>(v) };
	}
};
template <>
struct js_traits<godot::Marker3D> {
	/// @throws exception
	static godot::Marker3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Marker3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Marker3D v) noexcept {
		return Value{ ctx, std::forward<godot::Marker3D>(v) };
	}
};
template <>
struct js_traits<godot::Marker3D &> {
	/// @throws exception
	static godot::Marker3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Marker3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Marker3D &v) noexcept {
		return Value{ ctx, std::forward<godot::Marker3D>(v) };
	}
};
template <>
struct js_traits<godot::Marshalls> {
	/// @throws exception
	static godot::Marshalls unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Marshalls *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Marshalls v) noexcept {
		return Value{ ctx, std::forward<godot::Marshalls>(v) };
	}
};
template <>
struct js_traits<godot::Marshalls &> {
	/// @throws exception
	static godot::Marshalls &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Marshalls *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Marshalls &v) noexcept {
		return Value{ ctx, std::forward<godot::Marshalls>(v) };
	}
};
template <>
struct js_traits<godot::Material> {
	/// @throws exception
	static godot::Material unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Material *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Material v) noexcept {
		return Value{ ctx, std::forward<godot::Material>(v) };
	}
};
template <>
struct js_traits<godot::Material &> {
	/// @throws exception
	static godot::Material &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Material *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Material &v) noexcept {
		return Value{ ctx, std::forward<godot::Material>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Material>> {
	/// @throws exception
	static godot::Ref<godot::Material> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Material>((godot::Material *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Material> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Material>>(v) };
	}
};
template <>
struct js_traits<godot::MenuBar> {
	/// @throws exception
	static godot::MenuBar unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MenuBar *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MenuBar v) noexcept {
		return Value{ ctx, std::forward<godot::MenuBar>(v) };
	}
};
template <>
struct js_traits<godot::MenuBar &> {
	/// @throws exception
	static godot::MenuBar &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MenuBar *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MenuBar &v) noexcept {
		return Value{ ctx, std::forward<godot::MenuBar>(v) };
	}
};
template <>
struct js_traits<godot::MenuButton> {
	/// @throws exception
	static godot::MenuButton unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MenuButton *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MenuButton v) noexcept {
		return Value{ ctx, std::forward<godot::MenuButton>(v) };
	}
};
template <>
struct js_traits<godot::MenuButton &> {
	/// @throws exception
	static godot::MenuButton &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MenuButton *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MenuButton &v) noexcept {
		return Value{ ctx, std::forward<godot::MenuButton>(v) };
	}
};
template <>
struct js_traits<godot::Mesh> {
	/// @throws exception
	static godot::Mesh unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Mesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Mesh v) noexcept {
		return Value{ ctx, std::forward<godot::Mesh>(v) };
	}
};
template <>
struct js_traits<godot::Mesh &> {
	/// @throws exception
	static godot::Mesh &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Mesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Mesh &v) noexcept {
		return Value{ ctx, std::forward<godot::Mesh>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Mesh>> {
	/// @throws exception
	static godot::Ref<godot::Mesh> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Mesh>((godot::Mesh *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Mesh> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Mesh>>(v) };
	}
};
template <>
struct js_traits<godot::MeshConvexDecompositionSettings> {
	/// @throws exception
	static godot::MeshConvexDecompositionSettings unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MeshConvexDecompositionSettings *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MeshConvexDecompositionSettings v) noexcept {
		return Value{ ctx, std::forward<godot::MeshConvexDecompositionSettings>(v) };
	}
};
template <>
struct js_traits<godot::MeshConvexDecompositionSettings &> {
	/// @throws exception
	static godot::MeshConvexDecompositionSettings &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MeshConvexDecompositionSettings *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MeshConvexDecompositionSettings &v) noexcept {
		return Value{ ctx, std::forward<godot::MeshConvexDecompositionSettings>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::MeshConvexDecompositionSettings>> {
	/// @throws exception
	static godot::Ref<godot::MeshConvexDecompositionSettings> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::MeshConvexDecompositionSettings>((godot::MeshConvexDecompositionSettings *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::MeshConvexDecompositionSettings> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::MeshConvexDecompositionSettings>>(v) };
	}
};
template <>
struct js_traits<godot::MeshDataTool> {
	/// @throws exception
	static godot::MeshDataTool unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MeshDataTool *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MeshDataTool v) noexcept {
		return Value{ ctx, std::forward<godot::MeshDataTool>(v) };
	}
};
template <>
struct js_traits<godot::MeshDataTool &> {
	/// @throws exception
	static godot::MeshDataTool &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MeshDataTool *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MeshDataTool &v) noexcept {
		return Value{ ctx, std::forward<godot::MeshDataTool>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::MeshDataTool>> {
	/// @throws exception
	static godot::Ref<godot::MeshDataTool> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::MeshDataTool>((godot::MeshDataTool *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::MeshDataTool> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::MeshDataTool>>(v) };
	}
};
template <>
struct js_traits<godot::MeshInstance2D> {
	/// @throws exception
	static godot::MeshInstance2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MeshInstance2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MeshInstance2D v) noexcept {
		return Value{ ctx, std::forward<godot::MeshInstance2D>(v) };
	}
};
template <>
struct js_traits<godot::MeshInstance2D &> {
	/// @throws exception
	static godot::MeshInstance2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MeshInstance2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MeshInstance2D &v) noexcept {
		return Value{ ctx, std::forward<godot::MeshInstance2D>(v) };
	}
};
template <>
struct js_traits<godot::MeshInstance3D> {
	/// @throws exception
	static godot::MeshInstance3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MeshInstance3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MeshInstance3D v) noexcept {
		return Value{ ctx, std::forward<godot::MeshInstance3D>(v) };
	}
};
template <>
struct js_traits<godot::MeshInstance3D &> {
	/// @throws exception
	static godot::MeshInstance3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MeshInstance3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MeshInstance3D &v) noexcept {
		return Value{ ctx, std::forward<godot::MeshInstance3D>(v) };
	}
};
template <>
struct js_traits<godot::MeshLibrary> {
	/// @throws exception
	static godot::MeshLibrary unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MeshLibrary *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MeshLibrary v) noexcept {
		return Value{ ctx, std::forward<godot::MeshLibrary>(v) };
	}
};
template <>
struct js_traits<godot::MeshLibrary &> {
	/// @throws exception
	static godot::MeshLibrary &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MeshLibrary *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MeshLibrary &v) noexcept {
		return Value{ ctx, std::forward<godot::MeshLibrary>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::MeshLibrary>> {
	/// @throws exception
	static godot::Ref<godot::MeshLibrary> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::MeshLibrary>((godot::MeshLibrary *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::MeshLibrary> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::MeshLibrary>>(v) };
	}
};
template <>
struct js_traits<godot::MeshTexture> {
	/// @throws exception
	static godot::MeshTexture unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MeshTexture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MeshTexture v) noexcept {
		return Value{ ctx, std::forward<godot::MeshTexture>(v) };
	}
};
template <>
struct js_traits<godot::MeshTexture &> {
	/// @throws exception
	static godot::MeshTexture &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MeshTexture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MeshTexture &v) noexcept {
		return Value{ ctx, std::forward<godot::MeshTexture>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::MeshTexture>> {
	/// @throws exception
	static godot::Ref<godot::MeshTexture> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::MeshTexture>((godot::MeshTexture *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::MeshTexture> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::MeshTexture>>(v) };
	}
};
template <>
struct js_traits<godot::MethodTweener> {
	/// @throws exception
	static godot::MethodTweener unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MethodTweener *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MethodTweener v) noexcept {
		return Value{ ctx, std::forward<godot::MethodTweener>(v) };
	}
};
template <>
struct js_traits<godot::MethodTweener &> {
	/// @throws exception
	static godot::MethodTweener &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MethodTweener *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MethodTweener &v) noexcept {
		return Value{ ctx, std::forward<godot::MethodTweener>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::MethodTweener>> {
	/// @throws exception
	static godot::Ref<godot::MethodTweener> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::MethodTweener>((godot::MethodTweener *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::MethodTweener> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::MethodTweener>>(v) };
	}
};
template <>
struct js_traits<godot::MissingNode> {
	/// @throws exception
	static godot::MissingNode unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MissingNode *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MissingNode v) noexcept {
		return Value{ ctx, std::forward<godot::MissingNode>(v) };
	}
};
template <>
struct js_traits<godot::MissingNode &> {
	/// @throws exception
	static godot::MissingNode &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MissingNode *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MissingNode &v) noexcept {
		return Value{ ctx, std::forward<godot::MissingNode>(v) };
	}
};
template <>
struct js_traits<godot::MissingResource> {
	/// @throws exception
	static godot::MissingResource unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MissingResource *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MissingResource v) noexcept {
		return Value{ ctx, std::forward<godot::MissingResource>(v) };
	}
};
template <>
struct js_traits<godot::MissingResource &> {
	/// @throws exception
	static godot::MissingResource &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MissingResource *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MissingResource &v) noexcept {
		return Value{ ctx, std::forward<godot::MissingResource>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::MissingResource>> {
	/// @throws exception
	static godot::Ref<godot::MissingResource> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::MissingResource>((godot::MissingResource *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::MissingResource> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::MissingResource>>(v) };
	}
};
template <>
struct js_traits<godot::MobileVRInterface> {
	/// @throws exception
	static godot::MobileVRInterface unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MobileVRInterface *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MobileVRInterface v) noexcept {
		return Value{ ctx, std::forward<godot::MobileVRInterface>(v) };
	}
};
template <>
struct js_traits<godot::MobileVRInterface &> {
	/// @throws exception
	static godot::MobileVRInterface &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MobileVRInterface *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MobileVRInterface &v) noexcept {
		return Value{ ctx, std::forward<godot::MobileVRInterface>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::MobileVRInterface>> {
	/// @throws exception
	static godot::Ref<godot::MobileVRInterface> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::MobileVRInterface>((godot::MobileVRInterface *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::MobileVRInterface> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::MobileVRInterface>>(v) };
	}
};
template <>
struct js_traits<godot::MovieWriter> {
	/// @throws exception
	static godot::MovieWriter unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MovieWriter *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MovieWriter v) noexcept {
		return Value{ ctx, std::forward<godot::MovieWriter>(v) };
	}
};
template <>
struct js_traits<godot::MovieWriter &> {
	/// @throws exception
	static godot::MovieWriter &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MovieWriter *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MovieWriter &v) noexcept {
		return Value{ ctx, std::forward<godot::MovieWriter>(v) };
	}
};
template <>
struct js_traits<godot::MultiMesh> {
	/// @throws exception
	static godot::MultiMesh unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MultiMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MultiMesh v) noexcept {
		return Value{ ctx, std::forward<godot::MultiMesh>(v) };
	}
};
template <>
struct js_traits<godot::MultiMesh &> {
	/// @throws exception
	static godot::MultiMesh &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MultiMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MultiMesh &v) noexcept {
		return Value{ ctx, std::forward<godot::MultiMesh>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::MultiMesh>> {
	/// @throws exception
	static godot::Ref<godot::MultiMesh> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::MultiMesh>((godot::MultiMesh *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::MultiMesh> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::MultiMesh>>(v) };
	}
};
template <>
struct js_traits<godot::MultiMeshInstance2D> {
	/// @throws exception
	static godot::MultiMeshInstance2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MultiMeshInstance2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MultiMeshInstance2D v) noexcept {
		return Value{ ctx, std::forward<godot::MultiMeshInstance2D>(v) };
	}
};
template <>
struct js_traits<godot::MultiMeshInstance2D &> {
	/// @throws exception
	static godot::MultiMeshInstance2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MultiMeshInstance2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MultiMeshInstance2D &v) noexcept {
		return Value{ ctx, std::forward<godot::MultiMeshInstance2D>(v) };
	}
};
template <>
struct js_traits<godot::MultiMeshInstance3D> {
	/// @throws exception
	static godot::MultiMeshInstance3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MultiMeshInstance3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MultiMeshInstance3D v) noexcept {
		return Value{ ctx, std::forward<godot::MultiMeshInstance3D>(v) };
	}
};
template <>
struct js_traits<godot::MultiMeshInstance3D &> {
	/// @throws exception
	static godot::MultiMeshInstance3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MultiMeshInstance3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MultiMeshInstance3D &v) noexcept {
		return Value{ ctx, std::forward<godot::MultiMeshInstance3D>(v) };
	}
};
template <>
struct js_traits<godot::MultiplayerAPI> {
	/// @throws exception
	static godot::MultiplayerAPI unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MultiplayerAPI *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MultiplayerAPI v) noexcept {
		return Value{ ctx, std::forward<godot::MultiplayerAPI>(v) };
	}
};
template <>
struct js_traits<godot::MultiplayerAPI &> {
	/// @throws exception
	static godot::MultiplayerAPI &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MultiplayerAPI *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MultiplayerAPI &v) noexcept {
		return Value{ ctx, std::forward<godot::MultiplayerAPI>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::MultiplayerAPI>> {
	/// @throws exception
	static godot::Ref<godot::MultiplayerAPI> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::MultiplayerAPI>((godot::MultiplayerAPI *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::MultiplayerAPI> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::MultiplayerAPI>>(v) };
	}
};
template <>
struct js_traits<godot::MultiplayerAPIExtension> {
	/// @throws exception
	static godot::MultiplayerAPIExtension unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MultiplayerAPIExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MultiplayerAPIExtension v) noexcept {
		return Value{ ctx, std::forward<godot::MultiplayerAPIExtension>(v) };
	}
};
template <>
struct js_traits<godot::MultiplayerAPIExtension &> {
	/// @throws exception
	static godot::MultiplayerAPIExtension &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MultiplayerAPIExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MultiplayerAPIExtension &v) noexcept {
		return Value{ ctx, std::forward<godot::MultiplayerAPIExtension>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::MultiplayerAPIExtension>> {
	/// @throws exception
	static godot::Ref<godot::MultiplayerAPIExtension> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::MultiplayerAPIExtension>((godot::MultiplayerAPIExtension *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::MultiplayerAPIExtension> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::MultiplayerAPIExtension>>(v) };
	}
};
template <>
struct js_traits<godot::MultiplayerPeer> {
	/// @throws exception
	static godot::MultiplayerPeer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MultiplayerPeer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MultiplayerPeer v) noexcept {
		return Value{ ctx, std::forward<godot::MultiplayerPeer>(v) };
	}
};
template <>
struct js_traits<godot::MultiplayerPeer &> {
	/// @throws exception
	static godot::MultiplayerPeer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MultiplayerPeer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MultiplayerPeer &v) noexcept {
		return Value{ ctx, std::forward<godot::MultiplayerPeer>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::MultiplayerPeer>> {
	/// @throws exception
	static godot::Ref<godot::MultiplayerPeer> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::MultiplayerPeer>((godot::MultiplayerPeer *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::MultiplayerPeer> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::MultiplayerPeer>>(v) };
	}
};
template <>
struct js_traits<godot::MultiplayerPeerExtension> {
	/// @throws exception
	static godot::MultiplayerPeerExtension unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MultiplayerPeerExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MultiplayerPeerExtension v) noexcept {
		return Value{ ctx, std::forward<godot::MultiplayerPeerExtension>(v) };
	}
};
template <>
struct js_traits<godot::MultiplayerPeerExtension &> {
	/// @throws exception
	static godot::MultiplayerPeerExtension &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MultiplayerPeerExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MultiplayerPeerExtension &v) noexcept {
		return Value{ ctx, std::forward<godot::MultiplayerPeerExtension>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::MultiplayerPeerExtension>> {
	/// @throws exception
	static godot::Ref<godot::MultiplayerPeerExtension> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::MultiplayerPeerExtension>((godot::MultiplayerPeerExtension *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::MultiplayerPeerExtension> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::MultiplayerPeerExtension>>(v) };
	}
};
template <>
struct js_traits<godot::MultiplayerSpawner> {
	/// @throws exception
	static godot::MultiplayerSpawner unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MultiplayerSpawner *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MultiplayerSpawner v) noexcept {
		return Value{ ctx, std::forward<godot::MultiplayerSpawner>(v) };
	}
};
template <>
struct js_traits<godot::MultiplayerSpawner &> {
	/// @throws exception
	static godot::MultiplayerSpawner &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MultiplayerSpawner *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MultiplayerSpawner &v) noexcept {
		return Value{ ctx, std::forward<godot::MultiplayerSpawner>(v) };
	}
};
template <>
struct js_traits<godot::MultiplayerSynchronizer> {
	/// @throws exception
	static godot::MultiplayerSynchronizer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MultiplayerSynchronizer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MultiplayerSynchronizer v) noexcept {
		return Value{ ctx, std::forward<godot::MultiplayerSynchronizer>(v) };
	}
};
template <>
struct js_traits<godot::MultiplayerSynchronizer &> {
	/// @throws exception
	static godot::MultiplayerSynchronizer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::MultiplayerSynchronizer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::MultiplayerSynchronizer &v) noexcept {
		return Value{ ctx, std::forward<godot::MultiplayerSynchronizer>(v) };
	}
};
template <>
struct js_traits<godot::Mutex> {
	/// @throws exception
	static godot::Mutex unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Mutex *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Mutex v) noexcept {
		return Value{ ctx, std::forward<godot::Mutex>(v) };
	}
};
template <>
struct js_traits<godot::Mutex &> {
	/// @throws exception
	static godot::Mutex &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Mutex *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Mutex &v) noexcept {
		return Value{ ctx, std::forward<godot::Mutex>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Mutex>> {
	/// @throws exception
	static godot::Ref<godot::Mutex> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Mutex>((godot::Mutex *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Mutex> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Mutex>>(v) };
	}
};
template <>
struct js_traits<godot::NavigationAgent2D> {
	/// @throws exception
	static godot::NavigationAgent2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationAgent2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationAgent2D v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationAgent2D>(v) };
	}
};
template <>
struct js_traits<godot::NavigationAgent2D &> {
	/// @throws exception
	static godot::NavigationAgent2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationAgent2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationAgent2D &v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationAgent2D>(v) };
	}
};
template <>
struct js_traits<godot::NavigationAgent3D> {
	/// @throws exception
	static godot::NavigationAgent3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationAgent3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationAgent3D v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationAgent3D>(v) };
	}
};
template <>
struct js_traits<godot::NavigationAgent3D &> {
	/// @throws exception
	static godot::NavigationAgent3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationAgent3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationAgent3D &v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationAgent3D>(v) };
	}
};
template <>
struct js_traits<godot::NavigationLink2D> {
	/// @throws exception
	static godot::NavigationLink2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationLink2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationLink2D v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationLink2D>(v) };
	}
};
template <>
struct js_traits<godot::NavigationLink2D &> {
	/// @throws exception
	static godot::NavigationLink2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationLink2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationLink2D &v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationLink2D>(v) };
	}
};
template <>
struct js_traits<godot::NavigationLink3D> {
	/// @throws exception
	static godot::NavigationLink3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationLink3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationLink3D v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationLink3D>(v) };
	}
};
template <>
struct js_traits<godot::NavigationLink3D &> {
	/// @throws exception
	static godot::NavigationLink3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationLink3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationLink3D &v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationLink3D>(v) };
	}
};
template <>
struct js_traits<godot::NavigationMesh> {
	/// @throws exception
	static godot::NavigationMesh unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationMesh v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationMesh>(v) };
	}
};
template <>
struct js_traits<godot::NavigationMesh &> {
	/// @throws exception
	static godot::NavigationMesh &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationMesh &v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationMesh>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::NavigationMesh>> {
	/// @throws exception
	static godot::Ref<godot::NavigationMesh> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::NavigationMesh>((godot::NavigationMesh *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::NavigationMesh> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::NavigationMesh>>(v) };
	}
};
template <>
struct js_traits<godot::NavigationMeshGenerator> {
	/// @throws exception
	static godot::NavigationMeshGenerator unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationMeshGenerator *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationMeshGenerator v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationMeshGenerator>(v) };
	}
};
template <>
struct js_traits<godot::NavigationMeshGenerator &> {
	/// @throws exception
	static godot::NavigationMeshGenerator &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationMeshGenerator *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationMeshGenerator &v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationMeshGenerator>(v) };
	}
};
template <>
struct js_traits<godot::NavigationMeshSourceGeometryData2D> {
	/// @throws exception
	static godot::NavigationMeshSourceGeometryData2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationMeshSourceGeometryData2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationMeshSourceGeometryData2D v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationMeshSourceGeometryData2D>(v) };
	}
};
template <>
struct js_traits<godot::NavigationMeshSourceGeometryData2D &> {
	/// @throws exception
	static godot::NavigationMeshSourceGeometryData2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationMeshSourceGeometryData2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationMeshSourceGeometryData2D &v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationMeshSourceGeometryData2D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::NavigationMeshSourceGeometryData2D>> {
	/// @throws exception
	static godot::Ref<godot::NavigationMeshSourceGeometryData2D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::NavigationMeshSourceGeometryData2D>((godot::NavigationMeshSourceGeometryData2D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::NavigationMeshSourceGeometryData2D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::NavigationMeshSourceGeometryData2D>>(v) };
	}
};
template <>
struct js_traits<godot::NavigationMeshSourceGeometryData3D> {
	/// @throws exception
	static godot::NavigationMeshSourceGeometryData3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationMeshSourceGeometryData3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationMeshSourceGeometryData3D v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationMeshSourceGeometryData3D>(v) };
	}
};
template <>
struct js_traits<godot::NavigationMeshSourceGeometryData3D &> {
	/// @throws exception
	static godot::NavigationMeshSourceGeometryData3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationMeshSourceGeometryData3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationMeshSourceGeometryData3D &v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationMeshSourceGeometryData3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::NavigationMeshSourceGeometryData3D>> {
	/// @throws exception
	static godot::Ref<godot::NavigationMeshSourceGeometryData3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::NavigationMeshSourceGeometryData3D>((godot::NavigationMeshSourceGeometryData3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::NavigationMeshSourceGeometryData3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::NavigationMeshSourceGeometryData3D>>(v) };
	}
};
template <>
struct js_traits<godot::NavigationObstacle2D> {
	/// @throws exception
	static godot::NavigationObstacle2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationObstacle2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationObstacle2D v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationObstacle2D>(v) };
	}
};
template <>
struct js_traits<godot::NavigationObstacle2D &> {
	/// @throws exception
	static godot::NavigationObstacle2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationObstacle2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationObstacle2D &v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationObstacle2D>(v) };
	}
};
template <>
struct js_traits<godot::NavigationObstacle3D> {
	/// @throws exception
	static godot::NavigationObstacle3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationObstacle3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationObstacle3D v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationObstacle3D>(v) };
	}
};
template <>
struct js_traits<godot::NavigationObstacle3D &> {
	/// @throws exception
	static godot::NavigationObstacle3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationObstacle3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationObstacle3D &v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationObstacle3D>(v) };
	}
};
template <>
struct js_traits<godot::NavigationPathQueryParameters2D> {
	/// @throws exception
	static godot::NavigationPathQueryParameters2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationPathQueryParameters2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationPathQueryParameters2D v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationPathQueryParameters2D>(v) };
	}
};
template <>
struct js_traits<godot::NavigationPathQueryParameters2D &> {
	/// @throws exception
	static godot::NavigationPathQueryParameters2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationPathQueryParameters2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationPathQueryParameters2D &v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationPathQueryParameters2D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::NavigationPathQueryParameters2D>> {
	/// @throws exception
	static godot::Ref<godot::NavigationPathQueryParameters2D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::NavigationPathQueryParameters2D>((godot::NavigationPathQueryParameters2D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::NavigationPathQueryParameters2D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::NavigationPathQueryParameters2D>>(v) };
	}
};
template <>
struct js_traits<godot::NavigationPathQueryParameters3D> {
	/// @throws exception
	static godot::NavigationPathQueryParameters3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationPathQueryParameters3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationPathQueryParameters3D v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationPathQueryParameters3D>(v) };
	}
};
template <>
struct js_traits<godot::NavigationPathQueryParameters3D &> {
	/// @throws exception
	static godot::NavigationPathQueryParameters3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationPathQueryParameters3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationPathQueryParameters3D &v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationPathQueryParameters3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::NavigationPathQueryParameters3D>> {
	/// @throws exception
	static godot::Ref<godot::NavigationPathQueryParameters3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::NavigationPathQueryParameters3D>((godot::NavigationPathQueryParameters3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::NavigationPathQueryParameters3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::NavigationPathQueryParameters3D>>(v) };
	}
};
template <>
struct js_traits<godot::NavigationPathQueryResult2D> {
	/// @throws exception
	static godot::NavigationPathQueryResult2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationPathQueryResult2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationPathQueryResult2D v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationPathQueryResult2D>(v) };
	}
};
template <>
struct js_traits<godot::NavigationPathQueryResult2D &> {
	/// @throws exception
	static godot::NavigationPathQueryResult2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationPathQueryResult2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationPathQueryResult2D &v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationPathQueryResult2D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::NavigationPathQueryResult2D>> {
	/// @throws exception
	static godot::Ref<godot::NavigationPathQueryResult2D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::NavigationPathQueryResult2D>((godot::NavigationPathQueryResult2D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::NavigationPathQueryResult2D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::NavigationPathQueryResult2D>>(v) };
	}
};
template <>
struct js_traits<godot::NavigationPathQueryResult3D> {
	/// @throws exception
	static godot::NavigationPathQueryResult3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationPathQueryResult3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationPathQueryResult3D v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationPathQueryResult3D>(v) };
	}
};
template <>
struct js_traits<godot::NavigationPathQueryResult3D &> {
	/// @throws exception
	static godot::NavigationPathQueryResult3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationPathQueryResult3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationPathQueryResult3D &v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationPathQueryResult3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::NavigationPathQueryResult3D>> {
	/// @throws exception
	static godot::Ref<godot::NavigationPathQueryResult3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::NavigationPathQueryResult3D>((godot::NavigationPathQueryResult3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::NavigationPathQueryResult3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::NavigationPathQueryResult3D>>(v) };
	}
};
template <>
struct js_traits<godot::NavigationPolygon> {
	/// @throws exception
	static godot::NavigationPolygon unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationPolygon *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationPolygon v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationPolygon>(v) };
	}
};
template <>
struct js_traits<godot::NavigationPolygon &> {
	/// @throws exception
	static godot::NavigationPolygon &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationPolygon *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationPolygon &v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationPolygon>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::NavigationPolygon>> {
	/// @throws exception
	static godot::Ref<godot::NavigationPolygon> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::NavigationPolygon>((godot::NavigationPolygon *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::NavigationPolygon> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::NavigationPolygon>>(v) };
	}
};
template <>
struct js_traits<godot::NavigationRegion2D> {
	/// @throws exception
	static godot::NavigationRegion2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationRegion2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationRegion2D v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationRegion2D>(v) };
	}
};
template <>
struct js_traits<godot::NavigationRegion2D &> {
	/// @throws exception
	static godot::NavigationRegion2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationRegion2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationRegion2D &v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationRegion2D>(v) };
	}
};
template <>
struct js_traits<godot::NavigationRegion3D> {
	/// @throws exception
	static godot::NavigationRegion3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationRegion3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationRegion3D v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationRegion3D>(v) };
	}
};
template <>
struct js_traits<godot::NavigationRegion3D &> {
	/// @throws exception
	static godot::NavigationRegion3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationRegion3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationRegion3D &v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationRegion3D>(v) };
	}
};
template <>
struct js_traits<godot::NavigationServer2D> {
	/// @throws exception
	static godot::NavigationServer2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationServer2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationServer2D v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationServer2D>(v) };
	}
};
template <>
struct js_traits<godot::NavigationServer2D &> {
	/// @throws exception
	static godot::NavigationServer2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationServer2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationServer2D &v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationServer2D>(v) };
	}
};
template <>
struct js_traits<godot::NavigationServer3D> {
	/// @throws exception
	static godot::NavigationServer3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationServer3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationServer3D v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationServer3D>(v) };
	}
};
template <>
struct js_traits<godot::NavigationServer3D &> {
	/// @throws exception
	static godot::NavigationServer3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NavigationServer3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NavigationServer3D &v) noexcept {
		return Value{ ctx, std::forward<godot::NavigationServer3D>(v) };
	}
};
template <>
struct js_traits<godot::NinePatchRect> {
	/// @throws exception
	static godot::NinePatchRect unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NinePatchRect *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NinePatchRect v) noexcept {
		return Value{ ctx, std::forward<godot::NinePatchRect>(v) };
	}
};
template <>
struct js_traits<godot::NinePatchRect &> {
	/// @throws exception
	static godot::NinePatchRect &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NinePatchRect *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NinePatchRect &v) noexcept {
		return Value{ ctx, std::forward<godot::NinePatchRect>(v) };
	}
};
template <>
struct js_traits<godot::Node> {
	/// @throws exception
	static godot::Node unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Node *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Node v) noexcept {
		return Value{ ctx, std::forward<godot::Node>(v) };
	}
};
template <>
struct js_traits<godot::Node &> {
	/// @throws exception
	static godot::Node &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Node *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Node &v) noexcept {
		return Value{ ctx, std::forward<godot::Node>(v) };
	}
};
template <>
struct js_traits<godot::Node2D> {
	/// @throws exception
	static godot::Node2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Node2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Node2D v) noexcept {
		return Value{ ctx, std::forward<godot::Node2D>(v) };
	}
};
template <>
struct js_traits<godot::Node2D &> {
	/// @throws exception
	static godot::Node2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Node2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Node2D &v) noexcept {
		return Value{ ctx, std::forward<godot::Node2D>(v) };
	}
};
template <>
struct js_traits<godot::Node3D> {
	/// @throws exception
	static godot::Node3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Node3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Node3D v) noexcept {
		return Value{ ctx, std::forward<godot::Node3D>(v) };
	}
};
template <>
struct js_traits<godot::Node3D &> {
	/// @throws exception
	static godot::Node3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Node3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Node3D &v) noexcept {
		return Value{ ctx, std::forward<godot::Node3D>(v) };
	}
};
template <>
struct js_traits<godot::Node3DGizmo> {
	/// @throws exception
	static godot::Node3DGizmo unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Node3DGizmo *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Node3DGizmo v) noexcept {
		return Value{ ctx, std::forward<godot::Node3DGizmo>(v) };
	}
};
template <>
struct js_traits<godot::Node3DGizmo &> {
	/// @throws exception
	static godot::Node3DGizmo &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Node3DGizmo *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Node3DGizmo &v) noexcept {
		return Value{ ctx, std::forward<godot::Node3DGizmo>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Node3DGizmo>> {
	/// @throws exception
	static godot::Ref<godot::Node3DGizmo> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Node3DGizmo>((godot::Node3DGizmo *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Node3DGizmo> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Node3DGizmo>>(v) };
	}
};
template <>
struct js_traits<godot::Noise> {
	/// @throws exception
	static godot::Noise unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Noise *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Noise v) noexcept {
		return Value{ ctx, std::forward<godot::Noise>(v) };
	}
};
template <>
struct js_traits<godot::Noise &> {
	/// @throws exception
	static godot::Noise &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Noise *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Noise &v) noexcept {
		return Value{ ctx, std::forward<godot::Noise>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Noise>> {
	/// @throws exception
	static godot::Ref<godot::Noise> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Noise>((godot::Noise *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Noise> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Noise>>(v) };
	}
};
template <>
struct js_traits<godot::NoiseTexture2D> {
	/// @throws exception
	static godot::NoiseTexture2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NoiseTexture2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NoiseTexture2D v) noexcept {
		return Value{ ctx, std::forward<godot::NoiseTexture2D>(v) };
	}
};
template <>
struct js_traits<godot::NoiseTexture2D &> {
	/// @throws exception
	static godot::NoiseTexture2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NoiseTexture2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NoiseTexture2D &v) noexcept {
		return Value{ ctx, std::forward<godot::NoiseTexture2D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::NoiseTexture2D>> {
	/// @throws exception
	static godot::Ref<godot::NoiseTexture2D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::NoiseTexture2D>((godot::NoiseTexture2D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::NoiseTexture2D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::NoiseTexture2D>>(v) };
	}
};
template <>
struct js_traits<godot::NoiseTexture3D> {
	/// @throws exception
	static godot::NoiseTexture3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NoiseTexture3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NoiseTexture3D v) noexcept {
		return Value{ ctx, std::forward<godot::NoiseTexture3D>(v) };
	}
};
template <>
struct js_traits<godot::NoiseTexture3D &> {
	/// @throws exception
	static godot::NoiseTexture3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NoiseTexture3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NoiseTexture3D &v) noexcept {
		return Value{ ctx, std::forward<godot::NoiseTexture3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::NoiseTexture3D>> {
	/// @throws exception
	static godot::Ref<godot::NoiseTexture3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::NoiseTexture3D>((godot::NoiseTexture3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::NoiseTexture3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::NoiseTexture3D>>(v) };
	}
};
template <>
struct js_traits<godot::ORMMaterial3D> {
	/// @throws exception
	static godot::ORMMaterial3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ORMMaterial3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ORMMaterial3D v) noexcept {
		return Value{ ctx, std::forward<godot::ORMMaterial3D>(v) };
	}
};
template <>
struct js_traits<godot::ORMMaterial3D &> {
	/// @throws exception
	static godot::ORMMaterial3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ORMMaterial3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ORMMaterial3D &v) noexcept {
		return Value{ ctx, std::forward<godot::ORMMaterial3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ORMMaterial3D>> {
	/// @throws exception
	static godot::Ref<godot::ORMMaterial3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ORMMaterial3D>((godot::ORMMaterial3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ORMMaterial3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ORMMaterial3D>>(v) };
	}
};
template <>
struct js_traits<godot::OS> {
	/// @throws exception
	static godot::OS unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OS *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OS v) noexcept {
		return Value{ ctx, std::forward<godot::OS>(v) };
	}
};
template <>
struct js_traits<godot::OS &> {
	/// @throws exception
	static godot::OS &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OS *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OS &v) noexcept {
		return Value{ ctx, std::forward<godot::OS>(v) };
	}
};
template <>
struct js_traits<godot::Object> {
	/// @throws exception
	static godot::Object unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Object *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Object v) noexcept {
		return Value{ ctx, std::forward<godot::Object>(v) };
	}
};
template <>
struct js_traits<godot::Object &> {
	/// @throws exception
	static godot::Object &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Object *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Object &v) noexcept {
		return Value{ ctx, std::forward<godot::Object>(v) };
	}
};
template <>
struct js_traits<godot::Occluder3D> {
	/// @throws exception
	static godot::Occluder3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Occluder3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Occluder3D v) noexcept {
		return Value{ ctx, std::forward<godot::Occluder3D>(v) };
	}
};
template <>
struct js_traits<godot::Occluder3D &> {
	/// @throws exception
	static godot::Occluder3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Occluder3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Occluder3D &v) noexcept {
		return Value{ ctx, std::forward<godot::Occluder3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Occluder3D>> {
	/// @throws exception
	static godot::Ref<godot::Occluder3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Occluder3D>((godot::Occluder3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Occluder3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Occluder3D>>(v) };
	}
};
template <>
struct js_traits<godot::OccluderInstance3D> {
	/// @throws exception
	static godot::OccluderInstance3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OccluderInstance3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OccluderInstance3D v) noexcept {
		return Value{ ctx, std::forward<godot::OccluderInstance3D>(v) };
	}
};
template <>
struct js_traits<godot::OccluderInstance3D &> {
	/// @throws exception
	static godot::OccluderInstance3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OccluderInstance3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OccluderInstance3D &v) noexcept {
		return Value{ ctx, std::forward<godot::OccluderInstance3D>(v) };
	}
};
template <>
struct js_traits<godot::OccluderPolygon2D> {
	/// @throws exception
	static godot::OccluderPolygon2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OccluderPolygon2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OccluderPolygon2D v) noexcept {
		return Value{ ctx, std::forward<godot::OccluderPolygon2D>(v) };
	}
};
template <>
struct js_traits<godot::OccluderPolygon2D &> {
	/// @throws exception
	static godot::OccluderPolygon2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OccluderPolygon2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OccluderPolygon2D &v) noexcept {
		return Value{ ctx, std::forward<godot::OccluderPolygon2D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::OccluderPolygon2D>> {
	/// @throws exception
	static godot::Ref<godot::OccluderPolygon2D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::OccluderPolygon2D>((godot::OccluderPolygon2D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::OccluderPolygon2D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::OccluderPolygon2D>>(v) };
	}
};
template <>
struct js_traits<godot::OfflineMultiplayerPeer> {
	/// @throws exception
	static godot::OfflineMultiplayerPeer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OfflineMultiplayerPeer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OfflineMultiplayerPeer v) noexcept {
		return Value{ ctx, std::forward<godot::OfflineMultiplayerPeer>(v) };
	}
};
template <>
struct js_traits<godot::OfflineMultiplayerPeer &> {
	/// @throws exception
	static godot::OfflineMultiplayerPeer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OfflineMultiplayerPeer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OfflineMultiplayerPeer &v) noexcept {
		return Value{ ctx, std::forward<godot::OfflineMultiplayerPeer>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::OfflineMultiplayerPeer>> {
	/// @throws exception
	static godot::Ref<godot::OfflineMultiplayerPeer> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::OfflineMultiplayerPeer>((godot::OfflineMultiplayerPeer *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::OfflineMultiplayerPeer> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::OfflineMultiplayerPeer>>(v) };
	}
};
template <>
struct js_traits<godot::OggPacketSequence> {
	/// @throws exception
	static godot::OggPacketSequence unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OggPacketSequence *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OggPacketSequence v) noexcept {
		return Value{ ctx, std::forward<godot::OggPacketSequence>(v) };
	}
};
template <>
struct js_traits<godot::OggPacketSequence &> {
	/// @throws exception
	static godot::OggPacketSequence &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OggPacketSequence *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OggPacketSequence &v) noexcept {
		return Value{ ctx, std::forward<godot::OggPacketSequence>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::OggPacketSequence>> {
	/// @throws exception
	static godot::Ref<godot::OggPacketSequence> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::OggPacketSequence>((godot::OggPacketSequence *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::OggPacketSequence> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::OggPacketSequence>>(v) };
	}
};
template <>
struct js_traits<godot::OggPacketSequencePlayback> {
	/// @throws exception
	static godot::OggPacketSequencePlayback unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OggPacketSequencePlayback *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OggPacketSequencePlayback v) noexcept {
		return Value{ ctx, std::forward<godot::OggPacketSequencePlayback>(v) };
	}
};
template <>
struct js_traits<godot::OggPacketSequencePlayback &> {
	/// @throws exception
	static godot::OggPacketSequencePlayback &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OggPacketSequencePlayback *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OggPacketSequencePlayback &v) noexcept {
		return Value{ ctx, std::forward<godot::OggPacketSequencePlayback>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::OggPacketSequencePlayback>> {
	/// @throws exception
	static godot::Ref<godot::OggPacketSequencePlayback> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::OggPacketSequencePlayback>((godot::OggPacketSequencePlayback *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::OggPacketSequencePlayback> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::OggPacketSequencePlayback>>(v) };
	}
};
template <>
struct js_traits<godot::OmniLight3D> {
	/// @throws exception
	static godot::OmniLight3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OmniLight3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OmniLight3D v) noexcept {
		return Value{ ctx, std::forward<godot::OmniLight3D>(v) };
	}
};
template <>
struct js_traits<godot::OmniLight3D &> {
	/// @throws exception
	static godot::OmniLight3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OmniLight3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OmniLight3D &v) noexcept {
		return Value{ ctx, std::forward<godot::OmniLight3D>(v) };
	}
};
template <>
struct js_traits<godot::OpenXRAPIExtension> {
	/// @throws exception
	static godot::OpenXRAPIExtension unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OpenXRAPIExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OpenXRAPIExtension v) noexcept {
		return Value{ ctx, std::forward<godot::OpenXRAPIExtension>(v) };
	}
};
template <>
struct js_traits<godot::OpenXRAPIExtension &> {
	/// @throws exception
	static godot::OpenXRAPIExtension &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OpenXRAPIExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OpenXRAPIExtension &v) noexcept {
		return Value{ ctx, std::forward<godot::OpenXRAPIExtension>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::OpenXRAPIExtension>> {
	/// @throws exception
	static godot::Ref<godot::OpenXRAPIExtension> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::OpenXRAPIExtension>((godot::OpenXRAPIExtension *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::OpenXRAPIExtension> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::OpenXRAPIExtension>>(v) };
	}
};
template <>
struct js_traits<godot::OpenXRAction> {
	/// @throws exception
	static godot::OpenXRAction unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OpenXRAction *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OpenXRAction v) noexcept {
		return Value{ ctx, std::forward<godot::OpenXRAction>(v) };
	}
};
template <>
struct js_traits<godot::OpenXRAction &> {
	/// @throws exception
	static godot::OpenXRAction &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OpenXRAction *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OpenXRAction &v) noexcept {
		return Value{ ctx, std::forward<godot::OpenXRAction>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::OpenXRAction>> {
	/// @throws exception
	static godot::Ref<godot::OpenXRAction> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::OpenXRAction>((godot::OpenXRAction *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::OpenXRAction> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::OpenXRAction>>(v) };
	}
};
template <>
struct js_traits<godot::OpenXRActionMap> {
	/// @throws exception
	static godot::OpenXRActionMap unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OpenXRActionMap *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OpenXRActionMap v) noexcept {
		return Value{ ctx, std::forward<godot::OpenXRActionMap>(v) };
	}
};
template <>
struct js_traits<godot::OpenXRActionMap &> {
	/// @throws exception
	static godot::OpenXRActionMap &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OpenXRActionMap *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OpenXRActionMap &v) noexcept {
		return Value{ ctx, std::forward<godot::OpenXRActionMap>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::OpenXRActionMap>> {
	/// @throws exception
	static godot::Ref<godot::OpenXRActionMap> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::OpenXRActionMap>((godot::OpenXRActionMap *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::OpenXRActionMap> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::OpenXRActionMap>>(v) };
	}
};
template <>
struct js_traits<godot::OpenXRActionSet> {
	/// @throws exception
	static godot::OpenXRActionSet unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OpenXRActionSet *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OpenXRActionSet v) noexcept {
		return Value{ ctx, std::forward<godot::OpenXRActionSet>(v) };
	}
};
template <>
struct js_traits<godot::OpenXRActionSet &> {
	/// @throws exception
	static godot::OpenXRActionSet &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OpenXRActionSet *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OpenXRActionSet &v) noexcept {
		return Value{ ctx, std::forward<godot::OpenXRActionSet>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::OpenXRActionSet>> {
	/// @throws exception
	static godot::Ref<godot::OpenXRActionSet> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::OpenXRActionSet>((godot::OpenXRActionSet *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::OpenXRActionSet> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::OpenXRActionSet>>(v) };
	}
};
template <>
struct js_traits<godot::OpenXRExtensionWrapperExtension> {
	/// @throws exception
	static godot::OpenXRExtensionWrapperExtension unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OpenXRExtensionWrapperExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OpenXRExtensionWrapperExtension v) noexcept {
		return Value{ ctx, std::forward<godot::OpenXRExtensionWrapperExtension>(v) };
	}
};
template <>
struct js_traits<godot::OpenXRExtensionWrapperExtension &> {
	/// @throws exception
	static godot::OpenXRExtensionWrapperExtension &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OpenXRExtensionWrapperExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OpenXRExtensionWrapperExtension &v) noexcept {
		return Value{ ctx, std::forward<godot::OpenXRExtensionWrapperExtension>(v) };
	}
};
template <>
struct js_traits<godot::OpenXRHand> {
	/// @throws exception
	static godot::OpenXRHand unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OpenXRHand *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OpenXRHand v) noexcept {
		return Value{ ctx, std::forward<godot::OpenXRHand>(v) };
	}
};
template <>
struct js_traits<godot::OpenXRHand &> {
	/// @throws exception
	static godot::OpenXRHand &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OpenXRHand *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OpenXRHand &v) noexcept {
		return Value{ ctx, std::forward<godot::OpenXRHand>(v) };
	}
};
template <>
struct js_traits<godot::OpenXRIPBinding> {
	/// @throws exception
	static godot::OpenXRIPBinding unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OpenXRIPBinding *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OpenXRIPBinding v) noexcept {
		return Value{ ctx, std::forward<godot::OpenXRIPBinding>(v) };
	}
};
template <>
struct js_traits<godot::OpenXRIPBinding &> {
	/// @throws exception
	static godot::OpenXRIPBinding &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OpenXRIPBinding *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OpenXRIPBinding &v) noexcept {
		return Value{ ctx, std::forward<godot::OpenXRIPBinding>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::OpenXRIPBinding>> {
	/// @throws exception
	static godot::Ref<godot::OpenXRIPBinding> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::OpenXRIPBinding>((godot::OpenXRIPBinding *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::OpenXRIPBinding> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::OpenXRIPBinding>>(v) };
	}
};
template <>
struct js_traits<godot::OpenXRInteractionProfile> {
	/// @throws exception
	static godot::OpenXRInteractionProfile unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OpenXRInteractionProfile *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OpenXRInteractionProfile v) noexcept {
		return Value{ ctx, std::forward<godot::OpenXRInteractionProfile>(v) };
	}
};
template <>
struct js_traits<godot::OpenXRInteractionProfile &> {
	/// @throws exception
	static godot::OpenXRInteractionProfile &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OpenXRInteractionProfile *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OpenXRInteractionProfile &v) noexcept {
		return Value{ ctx, std::forward<godot::OpenXRInteractionProfile>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::OpenXRInteractionProfile>> {
	/// @throws exception
	static godot::Ref<godot::OpenXRInteractionProfile> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::OpenXRInteractionProfile>((godot::OpenXRInteractionProfile *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::OpenXRInteractionProfile> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::OpenXRInteractionProfile>>(v) };
	}
};
template <>
struct js_traits<godot::OpenXRInteractionProfileMetadata> {
	/// @throws exception
	static godot::OpenXRInteractionProfileMetadata unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OpenXRInteractionProfileMetadata *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OpenXRInteractionProfileMetadata v) noexcept {
		return Value{ ctx, std::forward<godot::OpenXRInteractionProfileMetadata>(v) };
	}
};
template <>
struct js_traits<godot::OpenXRInteractionProfileMetadata &> {
	/// @throws exception
	static godot::OpenXRInteractionProfileMetadata &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OpenXRInteractionProfileMetadata *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OpenXRInteractionProfileMetadata &v) noexcept {
		return Value{ ctx, std::forward<godot::OpenXRInteractionProfileMetadata>(v) };
	}
};
template <>
struct js_traits<godot::OpenXRInterface> {
	/// @throws exception
	static godot::OpenXRInterface unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OpenXRInterface *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OpenXRInterface v) noexcept {
		return Value{ ctx, std::forward<godot::OpenXRInterface>(v) };
	}
};
template <>
struct js_traits<godot::OpenXRInterface &> {
	/// @throws exception
	static godot::OpenXRInterface &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OpenXRInterface *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OpenXRInterface &v) noexcept {
		return Value{ ctx, std::forward<godot::OpenXRInterface>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::OpenXRInterface>> {
	/// @throws exception
	static godot::Ref<godot::OpenXRInterface> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::OpenXRInterface>((godot::OpenXRInterface *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::OpenXRInterface> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::OpenXRInterface>>(v) };
	}
};
template <>
struct js_traits<godot::OptimizedTranslation> {
	/// @throws exception
	static godot::OptimizedTranslation unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OptimizedTranslation *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OptimizedTranslation v) noexcept {
		return Value{ ctx, std::forward<godot::OptimizedTranslation>(v) };
	}
};
template <>
struct js_traits<godot::OptimizedTranslation &> {
	/// @throws exception
	static godot::OptimizedTranslation &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OptimizedTranslation *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OptimizedTranslation &v) noexcept {
		return Value{ ctx, std::forward<godot::OptimizedTranslation>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::OptimizedTranslation>> {
	/// @throws exception
	static godot::Ref<godot::OptimizedTranslation> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::OptimizedTranslation>((godot::OptimizedTranslation *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::OptimizedTranslation> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::OptimizedTranslation>>(v) };
	}
};
template <>
struct js_traits<godot::OptionButton> {
	/// @throws exception
	static godot::OptionButton unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OptionButton *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OptionButton v) noexcept {
		return Value{ ctx, std::forward<godot::OptionButton>(v) };
	}
};
template <>
struct js_traits<godot::OptionButton &> {
	/// @throws exception
	static godot::OptionButton &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::OptionButton *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::OptionButton &v) noexcept {
		return Value{ ctx, std::forward<godot::OptionButton>(v) };
	}
};
template <>
struct js_traits<godot::PCKPacker> {
	/// @throws exception
	static godot::PCKPacker unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PCKPacker *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PCKPacker v) noexcept {
		return Value{ ctx, std::forward<godot::PCKPacker>(v) };
	}
};
template <>
struct js_traits<godot::PCKPacker &> {
	/// @throws exception
	static godot::PCKPacker &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PCKPacker *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PCKPacker &v) noexcept {
		return Value{ ctx, std::forward<godot::PCKPacker>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PCKPacker>> {
	/// @throws exception
	static godot::Ref<godot::PCKPacker> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PCKPacker>((godot::PCKPacker *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PCKPacker> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PCKPacker>>(v) };
	}
};
template <>
struct js_traits<godot::PackedDataContainer> {
	/// @throws exception
	static godot::PackedDataContainer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PackedDataContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PackedDataContainer v) noexcept {
		return Value{ ctx, std::forward<godot::PackedDataContainer>(v) };
	}
};
template <>
struct js_traits<godot::PackedDataContainer &> {
	/// @throws exception
	static godot::PackedDataContainer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PackedDataContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PackedDataContainer &v) noexcept {
		return Value{ ctx, std::forward<godot::PackedDataContainer>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PackedDataContainer>> {
	/// @throws exception
	static godot::Ref<godot::PackedDataContainer> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PackedDataContainer>((godot::PackedDataContainer *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PackedDataContainer> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PackedDataContainer>>(v) };
	}
};
template <>
struct js_traits<godot::PackedDataContainerRef> {
	/// @throws exception
	static godot::PackedDataContainerRef unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PackedDataContainerRef *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PackedDataContainerRef v) noexcept {
		return Value{ ctx, std::forward<godot::PackedDataContainerRef>(v) };
	}
};
template <>
struct js_traits<godot::PackedDataContainerRef &> {
	/// @throws exception
	static godot::PackedDataContainerRef &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PackedDataContainerRef *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PackedDataContainerRef &v) noexcept {
		return Value{ ctx, std::forward<godot::PackedDataContainerRef>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PackedDataContainerRef>> {
	/// @throws exception
	static godot::Ref<godot::PackedDataContainerRef> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PackedDataContainerRef>((godot::PackedDataContainerRef *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PackedDataContainerRef> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PackedDataContainerRef>>(v) };
	}
};
template <>
struct js_traits<godot::PackedScene> {
	/// @throws exception
	static godot::PackedScene unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PackedScene *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PackedScene v) noexcept {
		return Value{ ctx, std::forward<godot::PackedScene>(v) };
	}
};
template <>
struct js_traits<godot::PackedScene &> {
	/// @throws exception
	static godot::PackedScene &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PackedScene *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PackedScene &v) noexcept {
		return Value{ ctx, std::forward<godot::PackedScene>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PackedScene>> {
	/// @throws exception
	static godot::Ref<godot::PackedScene> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PackedScene>((godot::PackedScene *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PackedScene> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PackedScene>>(v) };
	}
};
template <>
struct js_traits<godot::PacketPeer> {
	/// @throws exception
	static godot::PacketPeer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PacketPeer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PacketPeer v) noexcept {
		return Value{ ctx, std::forward<godot::PacketPeer>(v) };
	}
};
template <>
struct js_traits<godot::PacketPeer &> {
	/// @throws exception
	static godot::PacketPeer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PacketPeer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PacketPeer &v) noexcept {
		return Value{ ctx, std::forward<godot::PacketPeer>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PacketPeer>> {
	/// @throws exception
	static godot::Ref<godot::PacketPeer> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PacketPeer>((godot::PacketPeer *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PacketPeer> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PacketPeer>>(v) };
	}
};
template <>
struct js_traits<godot::PacketPeerDTLS> {
	/// @throws exception
	static godot::PacketPeerDTLS unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PacketPeerDTLS *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PacketPeerDTLS v) noexcept {
		return Value{ ctx, std::forward<godot::PacketPeerDTLS>(v) };
	}
};
template <>
struct js_traits<godot::PacketPeerDTLS &> {
	/// @throws exception
	static godot::PacketPeerDTLS &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PacketPeerDTLS *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PacketPeerDTLS &v) noexcept {
		return Value{ ctx, std::forward<godot::PacketPeerDTLS>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PacketPeerDTLS>> {
	/// @throws exception
	static godot::Ref<godot::PacketPeerDTLS> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PacketPeerDTLS>((godot::PacketPeerDTLS *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PacketPeerDTLS> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PacketPeerDTLS>>(v) };
	}
};
template <>
struct js_traits<godot::PacketPeerExtension> {
	/// @throws exception
	static godot::PacketPeerExtension unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PacketPeerExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PacketPeerExtension v) noexcept {
		return Value{ ctx, std::forward<godot::PacketPeerExtension>(v) };
	}
};
template <>
struct js_traits<godot::PacketPeerExtension &> {
	/// @throws exception
	static godot::PacketPeerExtension &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PacketPeerExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PacketPeerExtension &v) noexcept {
		return Value{ ctx, std::forward<godot::PacketPeerExtension>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PacketPeerExtension>> {
	/// @throws exception
	static godot::Ref<godot::PacketPeerExtension> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PacketPeerExtension>((godot::PacketPeerExtension *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PacketPeerExtension> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PacketPeerExtension>>(v) };
	}
};
template <>
struct js_traits<godot::PacketPeerStream> {
	/// @throws exception
	static godot::PacketPeerStream unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PacketPeerStream *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PacketPeerStream v) noexcept {
		return Value{ ctx, std::forward<godot::PacketPeerStream>(v) };
	}
};
template <>
struct js_traits<godot::PacketPeerStream &> {
	/// @throws exception
	static godot::PacketPeerStream &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PacketPeerStream *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PacketPeerStream &v) noexcept {
		return Value{ ctx, std::forward<godot::PacketPeerStream>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PacketPeerStream>> {
	/// @throws exception
	static godot::Ref<godot::PacketPeerStream> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PacketPeerStream>((godot::PacketPeerStream *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PacketPeerStream> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PacketPeerStream>>(v) };
	}
};
template <>
struct js_traits<godot::PacketPeerUDP> {
	/// @throws exception
	static godot::PacketPeerUDP unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PacketPeerUDP *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PacketPeerUDP v) noexcept {
		return Value{ ctx, std::forward<godot::PacketPeerUDP>(v) };
	}
};
template <>
struct js_traits<godot::PacketPeerUDP &> {
	/// @throws exception
	static godot::PacketPeerUDP &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PacketPeerUDP *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PacketPeerUDP &v) noexcept {
		return Value{ ctx, std::forward<godot::PacketPeerUDP>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PacketPeerUDP>> {
	/// @throws exception
	static godot::Ref<godot::PacketPeerUDP> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PacketPeerUDP>((godot::PacketPeerUDP *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PacketPeerUDP> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PacketPeerUDP>>(v) };
	}
};
template <>
struct js_traits<godot::Panel> {
	/// @throws exception
	static godot::Panel unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Panel *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Panel v) noexcept {
		return Value{ ctx, std::forward<godot::Panel>(v) };
	}
};
template <>
struct js_traits<godot::Panel &> {
	/// @throws exception
	static godot::Panel &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Panel *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Panel &v) noexcept {
		return Value{ ctx, std::forward<godot::Panel>(v) };
	}
};
template <>
struct js_traits<godot::PanelContainer> {
	/// @throws exception
	static godot::PanelContainer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PanelContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PanelContainer v) noexcept {
		return Value{ ctx, std::forward<godot::PanelContainer>(v) };
	}
};
template <>
struct js_traits<godot::PanelContainer &> {
	/// @throws exception
	static godot::PanelContainer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PanelContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PanelContainer &v) noexcept {
		return Value{ ctx, std::forward<godot::PanelContainer>(v) };
	}
};
template <>
struct js_traits<godot::PanoramaSkyMaterial> {
	/// @throws exception
	static godot::PanoramaSkyMaterial unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PanoramaSkyMaterial *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PanoramaSkyMaterial v) noexcept {
		return Value{ ctx, std::forward<godot::PanoramaSkyMaterial>(v) };
	}
};
template <>
struct js_traits<godot::PanoramaSkyMaterial &> {
	/// @throws exception
	static godot::PanoramaSkyMaterial &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PanoramaSkyMaterial *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PanoramaSkyMaterial &v) noexcept {
		return Value{ ctx, std::forward<godot::PanoramaSkyMaterial>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PanoramaSkyMaterial>> {
	/// @throws exception
	static godot::Ref<godot::PanoramaSkyMaterial> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PanoramaSkyMaterial>((godot::PanoramaSkyMaterial *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PanoramaSkyMaterial> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PanoramaSkyMaterial>>(v) };
	}
};
template <>
struct js_traits<godot::ParallaxBackground> {
	/// @throws exception
	static godot::ParallaxBackground unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ParallaxBackground *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ParallaxBackground v) noexcept {
		return Value{ ctx, std::forward<godot::ParallaxBackground>(v) };
	}
};
template <>
struct js_traits<godot::ParallaxBackground &> {
	/// @throws exception
	static godot::ParallaxBackground &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ParallaxBackground *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ParallaxBackground &v) noexcept {
		return Value{ ctx, std::forward<godot::ParallaxBackground>(v) };
	}
};
template <>
struct js_traits<godot::ParallaxLayer> {
	/// @throws exception
	static godot::ParallaxLayer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ParallaxLayer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ParallaxLayer v) noexcept {
		return Value{ ctx, std::forward<godot::ParallaxLayer>(v) };
	}
};
template <>
struct js_traits<godot::ParallaxLayer &> {
	/// @throws exception
	static godot::ParallaxLayer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ParallaxLayer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ParallaxLayer &v) noexcept {
		return Value{ ctx, std::forward<godot::ParallaxLayer>(v) };
	}
};
template <>
struct js_traits<godot::ParticleProcessMaterial> {
	/// @throws exception
	static godot::ParticleProcessMaterial unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ParticleProcessMaterial *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ParticleProcessMaterial v) noexcept {
		return Value{ ctx, std::forward<godot::ParticleProcessMaterial>(v) };
	}
};
template <>
struct js_traits<godot::ParticleProcessMaterial &> {
	/// @throws exception
	static godot::ParticleProcessMaterial &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ParticleProcessMaterial *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ParticleProcessMaterial &v) noexcept {
		return Value{ ctx, std::forward<godot::ParticleProcessMaterial>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ParticleProcessMaterial>> {
	/// @throws exception
	static godot::Ref<godot::ParticleProcessMaterial> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ParticleProcessMaterial>((godot::ParticleProcessMaterial *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ParticleProcessMaterial> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ParticleProcessMaterial>>(v) };
	}
};
template <>
struct js_traits<godot::Path2D> {
	/// @throws exception
	static godot::Path2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Path2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Path2D v) noexcept {
		return Value{ ctx, std::forward<godot::Path2D>(v) };
	}
};
template <>
struct js_traits<godot::Path2D &> {
	/// @throws exception
	static godot::Path2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Path2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Path2D &v) noexcept {
		return Value{ ctx, std::forward<godot::Path2D>(v) };
	}
};
template <>
struct js_traits<godot::Path3D> {
	/// @throws exception
	static godot::Path3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Path3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Path3D v) noexcept {
		return Value{ ctx, std::forward<godot::Path3D>(v) };
	}
};
template <>
struct js_traits<godot::Path3D &> {
	/// @throws exception
	static godot::Path3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Path3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Path3D &v) noexcept {
		return Value{ ctx, std::forward<godot::Path3D>(v) };
	}
};
template <>
struct js_traits<godot::PathFollow2D> {
	/// @throws exception
	static godot::PathFollow2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PathFollow2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PathFollow2D v) noexcept {
		return Value{ ctx, std::forward<godot::PathFollow2D>(v) };
	}
};
template <>
struct js_traits<godot::PathFollow2D &> {
	/// @throws exception
	static godot::PathFollow2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PathFollow2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PathFollow2D &v) noexcept {
		return Value{ ctx, std::forward<godot::PathFollow2D>(v) };
	}
};
template <>
struct js_traits<godot::PathFollow3D> {
	/// @throws exception
	static godot::PathFollow3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PathFollow3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PathFollow3D v) noexcept {
		return Value{ ctx, std::forward<godot::PathFollow3D>(v) };
	}
};
template <>
struct js_traits<godot::PathFollow3D &> {
	/// @throws exception
	static godot::PathFollow3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PathFollow3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PathFollow3D &v) noexcept {
		return Value{ ctx, std::forward<godot::PathFollow3D>(v) };
	}
};
template <>
struct js_traits<godot::Performance> {
	/// @throws exception
	static godot::Performance unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Performance *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Performance v) noexcept {
		return Value{ ctx, std::forward<godot::Performance>(v) };
	}
};
template <>
struct js_traits<godot::Performance &> {
	/// @throws exception
	static godot::Performance &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Performance *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Performance &v) noexcept {
		return Value{ ctx, std::forward<godot::Performance>(v) };
	}
};
template <>
struct js_traits<godot::PhysicalBone2D> {
	/// @throws exception
	static godot::PhysicalBone2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicalBone2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicalBone2D v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicalBone2D>(v) };
	}
};
template <>
struct js_traits<godot::PhysicalBone2D &> {
	/// @throws exception
	static godot::PhysicalBone2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicalBone2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicalBone2D &v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicalBone2D>(v) };
	}
};
template <>
struct js_traits<godot::PhysicalBone3D> {
	/// @throws exception
	static godot::PhysicalBone3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicalBone3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicalBone3D v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicalBone3D>(v) };
	}
};
template <>
struct js_traits<godot::PhysicalBone3D &> {
	/// @throws exception
	static godot::PhysicalBone3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicalBone3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicalBone3D &v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicalBone3D>(v) };
	}
};
template <>
struct js_traits<godot::PhysicalSkyMaterial> {
	/// @throws exception
	static godot::PhysicalSkyMaterial unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicalSkyMaterial *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicalSkyMaterial v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicalSkyMaterial>(v) };
	}
};
template <>
struct js_traits<godot::PhysicalSkyMaterial &> {
	/// @throws exception
	static godot::PhysicalSkyMaterial &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicalSkyMaterial *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicalSkyMaterial &v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicalSkyMaterial>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PhysicalSkyMaterial>> {
	/// @throws exception
	static godot::Ref<godot::PhysicalSkyMaterial> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PhysicalSkyMaterial>((godot::PhysicalSkyMaterial *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PhysicalSkyMaterial> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PhysicalSkyMaterial>>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsBody2D> {
	/// @throws exception
	static godot::PhysicsBody2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsBody2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsBody2D v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsBody2D>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsBody2D &> {
	/// @throws exception
	static godot::PhysicsBody2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsBody2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsBody2D &v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsBody2D>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsBody3D> {
	/// @throws exception
	static godot::PhysicsBody3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsBody3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsBody3D v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsBody3D>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsBody3D &> {
	/// @throws exception
	static godot::PhysicsBody3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsBody3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsBody3D &v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsBody3D>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsDirectBodyState2D> {
	/// @throws exception
	static godot::PhysicsDirectBodyState2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsDirectBodyState2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsDirectBodyState2D v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsDirectBodyState2D>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsDirectBodyState2D &> {
	/// @throws exception
	static godot::PhysicsDirectBodyState2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsDirectBodyState2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsDirectBodyState2D &v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsDirectBodyState2D>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsDirectBodyState2DExtension> {
	/// @throws exception
	static godot::PhysicsDirectBodyState2DExtension unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsDirectBodyState2DExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsDirectBodyState2DExtension v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsDirectBodyState2DExtension>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsDirectBodyState2DExtension &> {
	/// @throws exception
	static godot::PhysicsDirectBodyState2DExtension &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsDirectBodyState2DExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsDirectBodyState2DExtension &v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsDirectBodyState2DExtension>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsDirectBodyState3D> {
	/// @throws exception
	static godot::PhysicsDirectBodyState3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsDirectBodyState3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsDirectBodyState3D v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsDirectBodyState3D>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsDirectBodyState3D &> {
	/// @throws exception
	static godot::PhysicsDirectBodyState3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsDirectBodyState3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsDirectBodyState3D &v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsDirectBodyState3D>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsDirectBodyState3DExtension> {
	/// @throws exception
	static godot::PhysicsDirectBodyState3DExtension unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsDirectBodyState3DExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsDirectBodyState3DExtension v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsDirectBodyState3DExtension>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsDirectBodyState3DExtension &> {
	/// @throws exception
	static godot::PhysicsDirectBodyState3DExtension &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsDirectBodyState3DExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsDirectBodyState3DExtension &v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsDirectBodyState3DExtension>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsDirectSpaceState2D> {
	/// @throws exception
	static godot::PhysicsDirectSpaceState2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsDirectSpaceState2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsDirectSpaceState2D v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsDirectSpaceState2D>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsDirectSpaceState2D &> {
	/// @throws exception
	static godot::PhysicsDirectSpaceState2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsDirectSpaceState2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsDirectSpaceState2D &v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsDirectSpaceState2D>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsDirectSpaceState2DExtension> {
	/// @throws exception
	static godot::PhysicsDirectSpaceState2DExtension unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsDirectSpaceState2DExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsDirectSpaceState2DExtension v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsDirectSpaceState2DExtension>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsDirectSpaceState2DExtension &> {
	/// @throws exception
	static godot::PhysicsDirectSpaceState2DExtension &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsDirectSpaceState2DExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsDirectSpaceState2DExtension &v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsDirectSpaceState2DExtension>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsDirectSpaceState3D> {
	/// @throws exception
	static godot::PhysicsDirectSpaceState3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsDirectSpaceState3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsDirectSpaceState3D v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsDirectSpaceState3D>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsDirectSpaceState3D &> {
	/// @throws exception
	static godot::PhysicsDirectSpaceState3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsDirectSpaceState3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsDirectSpaceState3D &v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsDirectSpaceState3D>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsDirectSpaceState3DExtension> {
	/// @throws exception
	static godot::PhysicsDirectSpaceState3DExtension unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsDirectSpaceState3DExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsDirectSpaceState3DExtension v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsDirectSpaceState3DExtension>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsDirectSpaceState3DExtension &> {
	/// @throws exception
	static godot::PhysicsDirectSpaceState3DExtension &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsDirectSpaceState3DExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsDirectSpaceState3DExtension &v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsDirectSpaceState3DExtension>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsMaterial> {
	/// @throws exception
	static godot::PhysicsMaterial unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsMaterial *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsMaterial v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsMaterial>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsMaterial &> {
	/// @throws exception
	static godot::PhysicsMaterial &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsMaterial *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsMaterial &v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsMaterial>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PhysicsMaterial>> {
	/// @throws exception
	static godot::Ref<godot::PhysicsMaterial> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PhysicsMaterial>((godot::PhysicsMaterial *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PhysicsMaterial> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PhysicsMaterial>>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsPointQueryParameters2D> {
	/// @throws exception
	static godot::PhysicsPointQueryParameters2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsPointQueryParameters2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsPointQueryParameters2D v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsPointQueryParameters2D>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsPointQueryParameters2D &> {
	/// @throws exception
	static godot::PhysicsPointQueryParameters2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsPointQueryParameters2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsPointQueryParameters2D &v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsPointQueryParameters2D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PhysicsPointQueryParameters2D>> {
	/// @throws exception
	static godot::Ref<godot::PhysicsPointQueryParameters2D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PhysicsPointQueryParameters2D>((godot::PhysicsPointQueryParameters2D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PhysicsPointQueryParameters2D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PhysicsPointQueryParameters2D>>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsPointQueryParameters3D> {
	/// @throws exception
	static godot::PhysicsPointQueryParameters3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsPointQueryParameters3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsPointQueryParameters3D v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsPointQueryParameters3D>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsPointQueryParameters3D &> {
	/// @throws exception
	static godot::PhysicsPointQueryParameters3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsPointQueryParameters3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsPointQueryParameters3D &v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsPointQueryParameters3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PhysicsPointQueryParameters3D>> {
	/// @throws exception
	static godot::Ref<godot::PhysicsPointQueryParameters3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PhysicsPointQueryParameters3D>((godot::PhysicsPointQueryParameters3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PhysicsPointQueryParameters3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PhysicsPointQueryParameters3D>>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsRayQueryParameters2D> {
	/// @throws exception
	static godot::PhysicsRayQueryParameters2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsRayQueryParameters2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsRayQueryParameters2D v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsRayQueryParameters2D>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsRayQueryParameters2D &> {
	/// @throws exception
	static godot::PhysicsRayQueryParameters2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsRayQueryParameters2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsRayQueryParameters2D &v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsRayQueryParameters2D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PhysicsRayQueryParameters2D>> {
	/// @throws exception
	static godot::Ref<godot::PhysicsRayQueryParameters2D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PhysicsRayQueryParameters2D>((godot::PhysicsRayQueryParameters2D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PhysicsRayQueryParameters2D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PhysicsRayQueryParameters2D>>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsRayQueryParameters3D> {
	/// @throws exception
	static godot::PhysicsRayQueryParameters3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsRayQueryParameters3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsRayQueryParameters3D v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsRayQueryParameters3D>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsRayQueryParameters3D &> {
	/// @throws exception
	static godot::PhysicsRayQueryParameters3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsRayQueryParameters3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsRayQueryParameters3D &v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsRayQueryParameters3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PhysicsRayQueryParameters3D>> {
	/// @throws exception
	static godot::Ref<godot::PhysicsRayQueryParameters3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PhysicsRayQueryParameters3D>((godot::PhysicsRayQueryParameters3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PhysicsRayQueryParameters3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PhysicsRayQueryParameters3D>>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsServer2D> {
	/// @throws exception
	static godot::PhysicsServer2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsServer2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsServer2D v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsServer2D>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsServer2D &> {
	/// @throws exception
	static godot::PhysicsServer2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsServer2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsServer2D &v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsServer2D>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsServer2DExtension> {
	/// @throws exception
	static godot::PhysicsServer2DExtension unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsServer2DExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsServer2DExtension v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsServer2DExtension>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsServer2DExtension &> {
	/// @throws exception
	static godot::PhysicsServer2DExtension &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsServer2DExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsServer2DExtension &v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsServer2DExtension>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsServer2DManager> {
	/// @throws exception
	static godot::PhysicsServer2DManager unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsServer2DManager *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsServer2DManager v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsServer2DManager>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsServer2DManager &> {
	/// @throws exception
	static godot::PhysicsServer2DManager &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsServer2DManager *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsServer2DManager &v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsServer2DManager>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsServer3D> {
	/// @throws exception
	static godot::PhysicsServer3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsServer3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsServer3D v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsServer3D>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsServer3D &> {
	/// @throws exception
	static godot::PhysicsServer3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsServer3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsServer3D &v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsServer3D>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsServer3DExtension> {
	/// @throws exception
	static godot::PhysicsServer3DExtension unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsServer3DExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsServer3DExtension v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsServer3DExtension>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsServer3DExtension &> {
	/// @throws exception
	static godot::PhysicsServer3DExtension &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsServer3DExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsServer3DExtension &v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsServer3DExtension>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsServer3DManager> {
	/// @throws exception
	static godot::PhysicsServer3DManager unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsServer3DManager *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsServer3DManager v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsServer3DManager>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsServer3DManager &> {
	/// @throws exception
	static godot::PhysicsServer3DManager &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsServer3DManager *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsServer3DManager &v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsServer3DManager>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsServer3DRenderingServerHandler> {
	/// @throws exception
	static godot::PhysicsServer3DRenderingServerHandler unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsServer3DRenderingServerHandler *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsServer3DRenderingServerHandler v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsServer3DRenderingServerHandler>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsServer3DRenderingServerHandler &> {
	/// @throws exception
	static godot::PhysicsServer3DRenderingServerHandler &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsServer3DRenderingServerHandler *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsServer3DRenderingServerHandler &v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsServer3DRenderingServerHandler>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsShapeQueryParameters2D> {
	/// @throws exception
	static godot::PhysicsShapeQueryParameters2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsShapeQueryParameters2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsShapeQueryParameters2D v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsShapeQueryParameters2D>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsShapeQueryParameters2D &> {
	/// @throws exception
	static godot::PhysicsShapeQueryParameters2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsShapeQueryParameters2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsShapeQueryParameters2D &v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsShapeQueryParameters2D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PhysicsShapeQueryParameters2D>> {
	/// @throws exception
	static godot::Ref<godot::PhysicsShapeQueryParameters2D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PhysicsShapeQueryParameters2D>((godot::PhysicsShapeQueryParameters2D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PhysicsShapeQueryParameters2D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PhysicsShapeQueryParameters2D>>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsShapeQueryParameters3D> {
	/// @throws exception
	static godot::PhysicsShapeQueryParameters3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsShapeQueryParameters3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsShapeQueryParameters3D v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsShapeQueryParameters3D>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsShapeQueryParameters3D &> {
	/// @throws exception
	static godot::PhysicsShapeQueryParameters3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsShapeQueryParameters3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsShapeQueryParameters3D &v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsShapeQueryParameters3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PhysicsShapeQueryParameters3D>> {
	/// @throws exception
	static godot::Ref<godot::PhysicsShapeQueryParameters3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PhysicsShapeQueryParameters3D>((godot::PhysicsShapeQueryParameters3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PhysicsShapeQueryParameters3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PhysicsShapeQueryParameters3D>>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsTestMotionParameters2D> {
	/// @throws exception
	static godot::PhysicsTestMotionParameters2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsTestMotionParameters2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsTestMotionParameters2D v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsTestMotionParameters2D>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsTestMotionParameters2D &> {
	/// @throws exception
	static godot::PhysicsTestMotionParameters2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsTestMotionParameters2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsTestMotionParameters2D &v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsTestMotionParameters2D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PhysicsTestMotionParameters2D>> {
	/// @throws exception
	static godot::Ref<godot::PhysicsTestMotionParameters2D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PhysicsTestMotionParameters2D>((godot::PhysicsTestMotionParameters2D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PhysicsTestMotionParameters2D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PhysicsTestMotionParameters2D>>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsTestMotionParameters3D> {
	/// @throws exception
	static godot::PhysicsTestMotionParameters3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsTestMotionParameters3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsTestMotionParameters3D v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsTestMotionParameters3D>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsTestMotionParameters3D &> {
	/// @throws exception
	static godot::PhysicsTestMotionParameters3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsTestMotionParameters3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsTestMotionParameters3D &v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsTestMotionParameters3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PhysicsTestMotionParameters3D>> {
	/// @throws exception
	static godot::Ref<godot::PhysicsTestMotionParameters3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PhysicsTestMotionParameters3D>((godot::PhysicsTestMotionParameters3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PhysicsTestMotionParameters3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PhysicsTestMotionParameters3D>>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsTestMotionResult2D> {
	/// @throws exception
	static godot::PhysicsTestMotionResult2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsTestMotionResult2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsTestMotionResult2D v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsTestMotionResult2D>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsTestMotionResult2D &> {
	/// @throws exception
	static godot::PhysicsTestMotionResult2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsTestMotionResult2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsTestMotionResult2D &v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsTestMotionResult2D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PhysicsTestMotionResult2D>> {
	/// @throws exception
	static godot::Ref<godot::PhysicsTestMotionResult2D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PhysicsTestMotionResult2D>((godot::PhysicsTestMotionResult2D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PhysicsTestMotionResult2D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PhysicsTestMotionResult2D>>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsTestMotionResult3D> {
	/// @throws exception
	static godot::PhysicsTestMotionResult3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsTestMotionResult3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsTestMotionResult3D v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsTestMotionResult3D>(v) };
	}
};
template <>
struct js_traits<godot::PhysicsTestMotionResult3D &> {
	/// @throws exception
	static godot::PhysicsTestMotionResult3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PhysicsTestMotionResult3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PhysicsTestMotionResult3D &v) noexcept {
		return Value{ ctx, std::forward<godot::PhysicsTestMotionResult3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PhysicsTestMotionResult3D>> {
	/// @throws exception
	static godot::Ref<godot::PhysicsTestMotionResult3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PhysicsTestMotionResult3D>((godot::PhysicsTestMotionResult3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PhysicsTestMotionResult3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PhysicsTestMotionResult3D>>(v) };
	}
};
template <>
struct js_traits<godot::PinJoint2D> {
	/// @throws exception
	static godot::PinJoint2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PinJoint2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PinJoint2D v) noexcept {
		return Value{ ctx, std::forward<godot::PinJoint2D>(v) };
	}
};
template <>
struct js_traits<godot::PinJoint2D &> {
	/// @throws exception
	static godot::PinJoint2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PinJoint2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PinJoint2D &v) noexcept {
		return Value{ ctx, std::forward<godot::PinJoint2D>(v) };
	}
};
template <>
struct js_traits<godot::PinJoint3D> {
	/// @throws exception
	static godot::PinJoint3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PinJoint3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PinJoint3D v) noexcept {
		return Value{ ctx, std::forward<godot::PinJoint3D>(v) };
	}
};
template <>
struct js_traits<godot::PinJoint3D &> {
	/// @throws exception
	static godot::PinJoint3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PinJoint3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PinJoint3D &v) noexcept {
		return Value{ ctx, std::forward<godot::PinJoint3D>(v) };
	}
};
template <>
struct js_traits<godot::PlaceholderCubemap> {
	/// @throws exception
	static godot::PlaceholderCubemap unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PlaceholderCubemap *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PlaceholderCubemap v) noexcept {
		return Value{ ctx, std::forward<godot::PlaceholderCubemap>(v) };
	}
};
template <>
struct js_traits<godot::PlaceholderCubemap &> {
	/// @throws exception
	static godot::PlaceholderCubemap &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PlaceholderCubemap *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PlaceholderCubemap &v) noexcept {
		return Value{ ctx, std::forward<godot::PlaceholderCubemap>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PlaceholderCubemap>> {
	/// @throws exception
	static godot::Ref<godot::PlaceholderCubemap> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PlaceholderCubemap>((godot::PlaceholderCubemap *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PlaceholderCubemap> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PlaceholderCubemap>>(v) };
	}
};
template <>
struct js_traits<godot::PlaceholderCubemapArray> {
	/// @throws exception
	static godot::PlaceholderCubemapArray unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PlaceholderCubemapArray *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PlaceholderCubemapArray v) noexcept {
		return Value{ ctx, std::forward<godot::PlaceholderCubemapArray>(v) };
	}
};
template <>
struct js_traits<godot::PlaceholderCubemapArray &> {
	/// @throws exception
	static godot::PlaceholderCubemapArray &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PlaceholderCubemapArray *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PlaceholderCubemapArray &v) noexcept {
		return Value{ ctx, std::forward<godot::PlaceholderCubemapArray>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PlaceholderCubemapArray>> {
	/// @throws exception
	static godot::Ref<godot::PlaceholderCubemapArray> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PlaceholderCubemapArray>((godot::PlaceholderCubemapArray *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PlaceholderCubemapArray> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PlaceholderCubemapArray>>(v) };
	}
};
template <>
struct js_traits<godot::PlaceholderMaterial> {
	/// @throws exception
	static godot::PlaceholderMaterial unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PlaceholderMaterial *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PlaceholderMaterial v) noexcept {
		return Value{ ctx, std::forward<godot::PlaceholderMaterial>(v) };
	}
};
template <>
struct js_traits<godot::PlaceholderMaterial &> {
	/// @throws exception
	static godot::PlaceholderMaterial &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PlaceholderMaterial *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PlaceholderMaterial &v) noexcept {
		return Value{ ctx, std::forward<godot::PlaceholderMaterial>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PlaceholderMaterial>> {
	/// @throws exception
	static godot::Ref<godot::PlaceholderMaterial> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PlaceholderMaterial>((godot::PlaceholderMaterial *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PlaceholderMaterial> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PlaceholderMaterial>>(v) };
	}
};
template <>
struct js_traits<godot::PlaceholderMesh> {
	/// @throws exception
	static godot::PlaceholderMesh unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PlaceholderMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PlaceholderMesh v) noexcept {
		return Value{ ctx, std::forward<godot::PlaceholderMesh>(v) };
	}
};
template <>
struct js_traits<godot::PlaceholderMesh &> {
	/// @throws exception
	static godot::PlaceholderMesh &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PlaceholderMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PlaceholderMesh &v) noexcept {
		return Value{ ctx, std::forward<godot::PlaceholderMesh>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PlaceholderMesh>> {
	/// @throws exception
	static godot::Ref<godot::PlaceholderMesh> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PlaceholderMesh>((godot::PlaceholderMesh *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PlaceholderMesh> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PlaceholderMesh>>(v) };
	}
};
template <>
struct js_traits<godot::PlaceholderTexture2D> {
	/// @throws exception
	static godot::PlaceholderTexture2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PlaceholderTexture2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PlaceholderTexture2D v) noexcept {
		return Value{ ctx, std::forward<godot::PlaceholderTexture2D>(v) };
	}
};
template <>
struct js_traits<godot::PlaceholderTexture2D &> {
	/// @throws exception
	static godot::PlaceholderTexture2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PlaceholderTexture2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PlaceholderTexture2D &v) noexcept {
		return Value{ ctx, std::forward<godot::PlaceholderTexture2D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PlaceholderTexture2D>> {
	/// @throws exception
	static godot::Ref<godot::PlaceholderTexture2D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PlaceholderTexture2D>((godot::PlaceholderTexture2D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PlaceholderTexture2D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PlaceholderTexture2D>>(v) };
	}
};
template <>
struct js_traits<godot::PlaceholderTexture2DArray> {
	/// @throws exception
	static godot::PlaceholderTexture2DArray unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PlaceholderTexture2DArray *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PlaceholderTexture2DArray v) noexcept {
		return Value{ ctx, std::forward<godot::PlaceholderTexture2DArray>(v) };
	}
};
template <>
struct js_traits<godot::PlaceholderTexture2DArray &> {
	/// @throws exception
	static godot::PlaceholderTexture2DArray &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PlaceholderTexture2DArray *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PlaceholderTexture2DArray &v) noexcept {
		return Value{ ctx, std::forward<godot::PlaceholderTexture2DArray>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PlaceholderTexture2DArray>> {
	/// @throws exception
	static godot::Ref<godot::PlaceholderTexture2DArray> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PlaceholderTexture2DArray>((godot::PlaceholderTexture2DArray *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PlaceholderTexture2DArray> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PlaceholderTexture2DArray>>(v) };
	}
};
template <>
struct js_traits<godot::PlaceholderTexture3D> {
	/// @throws exception
	static godot::PlaceholderTexture3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PlaceholderTexture3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PlaceholderTexture3D v) noexcept {
		return Value{ ctx, std::forward<godot::PlaceholderTexture3D>(v) };
	}
};
template <>
struct js_traits<godot::PlaceholderTexture3D &> {
	/// @throws exception
	static godot::PlaceholderTexture3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PlaceholderTexture3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PlaceholderTexture3D &v) noexcept {
		return Value{ ctx, std::forward<godot::PlaceholderTexture3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PlaceholderTexture3D>> {
	/// @throws exception
	static godot::Ref<godot::PlaceholderTexture3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PlaceholderTexture3D>((godot::PlaceholderTexture3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PlaceholderTexture3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PlaceholderTexture3D>>(v) };
	}
};
template <>
struct js_traits<godot::PlaceholderTextureLayered> {
	/// @throws exception
	static godot::PlaceholderTextureLayered unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PlaceholderTextureLayered *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PlaceholderTextureLayered v) noexcept {
		return Value{ ctx, std::forward<godot::PlaceholderTextureLayered>(v) };
	}
};
template <>
struct js_traits<godot::PlaceholderTextureLayered &> {
	/// @throws exception
	static godot::PlaceholderTextureLayered &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PlaceholderTextureLayered *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PlaceholderTextureLayered &v) noexcept {
		return Value{ ctx, std::forward<godot::PlaceholderTextureLayered>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PlaceholderTextureLayered>> {
	/// @throws exception
	static godot::Ref<godot::PlaceholderTextureLayered> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PlaceholderTextureLayered>((godot::PlaceholderTextureLayered *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PlaceholderTextureLayered> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PlaceholderTextureLayered>>(v) };
	}
};
template <>
struct js_traits<godot::PlaneMesh> {
	/// @throws exception
	static godot::PlaneMesh unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PlaneMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PlaneMesh v) noexcept {
		return Value{ ctx, std::forward<godot::PlaneMesh>(v) };
	}
};
template <>
struct js_traits<godot::PlaneMesh &> {
	/// @throws exception
	static godot::PlaneMesh &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PlaneMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PlaneMesh &v) noexcept {
		return Value{ ctx, std::forward<godot::PlaneMesh>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PlaneMesh>> {
	/// @throws exception
	static godot::Ref<godot::PlaneMesh> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PlaneMesh>((godot::PlaneMesh *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PlaneMesh> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PlaneMesh>>(v) };
	}
};
template <>
struct js_traits<godot::PointLight2D> {
	/// @throws exception
	static godot::PointLight2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PointLight2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PointLight2D v) noexcept {
		return Value{ ctx, std::forward<godot::PointLight2D>(v) };
	}
};
template <>
struct js_traits<godot::PointLight2D &> {
	/// @throws exception
	static godot::PointLight2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PointLight2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PointLight2D &v) noexcept {
		return Value{ ctx, std::forward<godot::PointLight2D>(v) };
	}
};
template <>
struct js_traits<godot::PointMesh> {
	/// @throws exception
	static godot::PointMesh unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PointMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PointMesh v) noexcept {
		return Value{ ctx, std::forward<godot::PointMesh>(v) };
	}
};
template <>
struct js_traits<godot::PointMesh &> {
	/// @throws exception
	static godot::PointMesh &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PointMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PointMesh &v) noexcept {
		return Value{ ctx, std::forward<godot::PointMesh>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PointMesh>> {
	/// @throws exception
	static godot::Ref<godot::PointMesh> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PointMesh>((godot::PointMesh *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PointMesh> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PointMesh>>(v) };
	}
};
template <>
struct js_traits<godot::Polygon2D> {
	/// @throws exception
	static godot::Polygon2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Polygon2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Polygon2D v) noexcept {
		return Value{ ctx, std::forward<godot::Polygon2D>(v) };
	}
};
template <>
struct js_traits<godot::Polygon2D &> {
	/// @throws exception
	static godot::Polygon2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Polygon2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Polygon2D &v) noexcept {
		return Value{ ctx, std::forward<godot::Polygon2D>(v) };
	}
};
template <>
struct js_traits<godot::PolygonOccluder3D> {
	/// @throws exception
	static godot::PolygonOccluder3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PolygonOccluder3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PolygonOccluder3D v) noexcept {
		return Value{ ctx, std::forward<godot::PolygonOccluder3D>(v) };
	}
};
template <>
struct js_traits<godot::PolygonOccluder3D &> {
	/// @throws exception
	static godot::PolygonOccluder3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PolygonOccluder3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PolygonOccluder3D &v) noexcept {
		return Value{ ctx, std::forward<godot::PolygonOccluder3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PolygonOccluder3D>> {
	/// @throws exception
	static godot::Ref<godot::PolygonOccluder3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PolygonOccluder3D>((godot::PolygonOccluder3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PolygonOccluder3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PolygonOccluder3D>>(v) };
	}
};
template <>
struct js_traits<godot::PolygonPathFinder> {
	/// @throws exception
	static godot::PolygonPathFinder unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PolygonPathFinder *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PolygonPathFinder v) noexcept {
		return Value{ ctx, std::forward<godot::PolygonPathFinder>(v) };
	}
};
template <>
struct js_traits<godot::PolygonPathFinder &> {
	/// @throws exception
	static godot::PolygonPathFinder &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PolygonPathFinder *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PolygonPathFinder &v) noexcept {
		return Value{ ctx, std::forward<godot::PolygonPathFinder>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PolygonPathFinder>> {
	/// @throws exception
	static godot::Ref<godot::PolygonPathFinder> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PolygonPathFinder>((godot::PolygonPathFinder *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PolygonPathFinder> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PolygonPathFinder>>(v) };
	}
};
template <>
struct js_traits<godot::Popup> {
	/// @throws exception
	static godot::Popup unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Popup *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Popup v) noexcept {
		return Value{ ctx, std::forward<godot::Popup>(v) };
	}
};
template <>
struct js_traits<godot::Popup &> {
	/// @throws exception
	static godot::Popup &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Popup *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Popup &v) noexcept {
		return Value{ ctx, std::forward<godot::Popup>(v) };
	}
};
template <>
struct js_traits<godot::PopupMenu> {
	/// @throws exception
	static godot::PopupMenu unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PopupMenu *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PopupMenu v) noexcept {
		return Value{ ctx, std::forward<godot::PopupMenu>(v) };
	}
};
template <>
struct js_traits<godot::PopupMenu &> {
	/// @throws exception
	static godot::PopupMenu &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PopupMenu *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PopupMenu &v) noexcept {
		return Value{ ctx, std::forward<godot::PopupMenu>(v) };
	}
};
template <>
struct js_traits<godot::PopupPanel> {
	/// @throws exception
	static godot::PopupPanel unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PopupPanel *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PopupPanel v) noexcept {
		return Value{ ctx, std::forward<godot::PopupPanel>(v) };
	}
};
template <>
struct js_traits<godot::PopupPanel &> {
	/// @throws exception
	static godot::PopupPanel &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PopupPanel *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PopupPanel &v) noexcept {
		return Value{ ctx, std::forward<godot::PopupPanel>(v) };
	}
};
template <>
struct js_traits<godot::PortableCompressedTexture2D> {
	/// @throws exception
	static godot::PortableCompressedTexture2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PortableCompressedTexture2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PortableCompressedTexture2D v) noexcept {
		return Value{ ctx, std::forward<godot::PortableCompressedTexture2D>(v) };
	}
};
template <>
struct js_traits<godot::PortableCompressedTexture2D &> {
	/// @throws exception
	static godot::PortableCompressedTexture2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PortableCompressedTexture2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PortableCompressedTexture2D &v) noexcept {
		return Value{ ctx, std::forward<godot::PortableCompressedTexture2D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PortableCompressedTexture2D>> {
	/// @throws exception
	static godot::Ref<godot::PortableCompressedTexture2D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PortableCompressedTexture2D>((godot::PortableCompressedTexture2D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PortableCompressedTexture2D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PortableCompressedTexture2D>>(v) };
	}
};
template <>
struct js_traits<godot::PrimitiveMesh> {
	/// @throws exception
	static godot::PrimitiveMesh unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PrimitiveMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PrimitiveMesh v) noexcept {
		return Value{ ctx, std::forward<godot::PrimitiveMesh>(v) };
	}
};
template <>
struct js_traits<godot::PrimitiveMesh &> {
	/// @throws exception
	static godot::PrimitiveMesh &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PrimitiveMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PrimitiveMesh &v) noexcept {
		return Value{ ctx, std::forward<godot::PrimitiveMesh>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PrimitiveMesh>> {
	/// @throws exception
	static godot::Ref<godot::PrimitiveMesh> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PrimitiveMesh>((godot::PrimitiveMesh *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PrimitiveMesh> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PrimitiveMesh>>(v) };
	}
};
template <>
struct js_traits<godot::PrismMesh> {
	/// @throws exception
	static godot::PrismMesh unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PrismMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PrismMesh v) noexcept {
		return Value{ ctx, std::forward<godot::PrismMesh>(v) };
	}
};
template <>
struct js_traits<godot::PrismMesh &> {
	/// @throws exception
	static godot::PrismMesh &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PrismMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PrismMesh &v) noexcept {
		return Value{ ctx, std::forward<godot::PrismMesh>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PrismMesh>> {
	/// @throws exception
	static godot::Ref<godot::PrismMesh> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PrismMesh>((godot::PrismMesh *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PrismMesh> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PrismMesh>>(v) };
	}
};
template <>
struct js_traits<godot::ProceduralSkyMaterial> {
	/// @throws exception
	static godot::ProceduralSkyMaterial unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ProceduralSkyMaterial *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ProceduralSkyMaterial v) noexcept {
		return Value{ ctx, std::forward<godot::ProceduralSkyMaterial>(v) };
	}
};
template <>
struct js_traits<godot::ProceduralSkyMaterial &> {
	/// @throws exception
	static godot::ProceduralSkyMaterial &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ProceduralSkyMaterial *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ProceduralSkyMaterial &v) noexcept {
		return Value{ ctx, std::forward<godot::ProceduralSkyMaterial>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ProceduralSkyMaterial>> {
	/// @throws exception
	static godot::Ref<godot::ProceduralSkyMaterial> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ProceduralSkyMaterial>((godot::ProceduralSkyMaterial *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ProceduralSkyMaterial> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ProceduralSkyMaterial>>(v) };
	}
};
template <>
struct js_traits<godot::ProgressBar> {
	/// @throws exception
	static godot::ProgressBar unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ProgressBar *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ProgressBar v) noexcept {
		return Value{ ctx, std::forward<godot::ProgressBar>(v) };
	}
};
template <>
struct js_traits<godot::ProgressBar &> {
	/// @throws exception
	static godot::ProgressBar &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ProgressBar *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ProgressBar &v) noexcept {
		return Value{ ctx, std::forward<godot::ProgressBar>(v) };
	}
};
template <>
struct js_traits<godot::ProjectSettings> {
	/// @throws exception
	static godot::ProjectSettings unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ProjectSettings *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ProjectSettings v) noexcept {
		return Value{ ctx, std::forward<godot::ProjectSettings>(v) };
	}
};
template <>
struct js_traits<godot::ProjectSettings &> {
	/// @throws exception
	static godot::ProjectSettings &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ProjectSettings *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ProjectSettings &v) noexcept {
		return Value{ ctx, std::forward<godot::ProjectSettings>(v) };
	}
};
template <>
struct js_traits<godot::PropertyTweener> {
	/// @throws exception
	static godot::PropertyTweener unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PropertyTweener *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PropertyTweener v) noexcept {
		return Value{ ctx, std::forward<godot::PropertyTweener>(v) };
	}
};
template <>
struct js_traits<godot::PropertyTweener &> {
	/// @throws exception
	static godot::PropertyTweener &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PropertyTweener *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PropertyTweener &v) noexcept {
		return Value{ ctx, std::forward<godot::PropertyTweener>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::PropertyTweener>> {
	/// @throws exception
	static godot::Ref<godot::PropertyTweener> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::PropertyTweener>((godot::PropertyTweener *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::PropertyTweener> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::PropertyTweener>>(v) };
	}
};
template <>
struct js_traits<godot::QuadMesh> {
	/// @throws exception
	static godot::QuadMesh unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::QuadMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::QuadMesh v) noexcept {
		return Value{ ctx, std::forward<godot::QuadMesh>(v) };
	}
};
template <>
struct js_traits<godot::QuadMesh &> {
	/// @throws exception
	static godot::QuadMesh &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::QuadMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::QuadMesh &v) noexcept {
		return Value{ ctx, std::forward<godot::QuadMesh>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::QuadMesh>> {
	/// @throws exception
	static godot::Ref<godot::QuadMesh> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::QuadMesh>((godot::QuadMesh *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::QuadMesh> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::QuadMesh>>(v) };
	}
};
template <>
struct js_traits<godot::QuadOccluder3D> {
	/// @throws exception
	static godot::QuadOccluder3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::QuadOccluder3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::QuadOccluder3D v) noexcept {
		return Value{ ctx, std::forward<godot::QuadOccluder3D>(v) };
	}
};
template <>
struct js_traits<godot::QuadOccluder3D &> {
	/// @throws exception
	static godot::QuadOccluder3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::QuadOccluder3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::QuadOccluder3D &v) noexcept {
		return Value{ ctx, std::forward<godot::QuadOccluder3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::QuadOccluder3D>> {
	/// @throws exception
	static godot::Ref<godot::QuadOccluder3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::QuadOccluder3D>((godot::QuadOccluder3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::QuadOccluder3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::QuadOccluder3D>>(v) };
	}
};
template <>
struct js_traits<godot::RDAttachmentFormat> {
	/// @throws exception
	static godot::RDAttachmentFormat unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RDAttachmentFormat *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RDAttachmentFormat v) noexcept {
		return Value{ ctx, std::forward<godot::RDAttachmentFormat>(v) };
	}
};
template <>
struct js_traits<godot::RDAttachmentFormat &> {
	/// @throws exception
	static godot::RDAttachmentFormat &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RDAttachmentFormat *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RDAttachmentFormat &v) noexcept {
		return Value{ ctx, std::forward<godot::RDAttachmentFormat>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::RDAttachmentFormat>> {
	/// @throws exception
	static godot::Ref<godot::RDAttachmentFormat> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::RDAttachmentFormat>((godot::RDAttachmentFormat *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::RDAttachmentFormat> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::RDAttachmentFormat>>(v) };
	}
};
template <>
struct js_traits<godot::RDFramebufferPass> {
	/// @throws exception
	static godot::RDFramebufferPass unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RDFramebufferPass *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RDFramebufferPass v) noexcept {
		return Value{ ctx, std::forward<godot::RDFramebufferPass>(v) };
	}
};
template <>
struct js_traits<godot::RDFramebufferPass &> {
	/// @throws exception
	static godot::RDFramebufferPass &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RDFramebufferPass *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RDFramebufferPass &v) noexcept {
		return Value{ ctx, std::forward<godot::RDFramebufferPass>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::RDFramebufferPass>> {
	/// @throws exception
	static godot::Ref<godot::RDFramebufferPass> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::RDFramebufferPass>((godot::RDFramebufferPass *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::RDFramebufferPass> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::RDFramebufferPass>>(v) };
	}
};
template <>
struct js_traits<godot::RDPipelineColorBlendState> {
	/// @throws exception
	static godot::RDPipelineColorBlendState unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RDPipelineColorBlendState *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RDPipelineColorBlendState v) noexcept {
		return Value{ ctx, std::forward<godot::RDPipelineColorBlendState>(v) };
	}
};
template <>
struct js_traits<godot::RDPipelineColorBlendState &> {
	/// @throws exception
	static godot::RDPipelineColorBlendState &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RDPipelineColorBlendState *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RDPipelineColorBlendState &v) noexcept {
		return Value{ ctx, std::forward<godot::RDPipelineColorBlendState>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::RDPipelineColorBlendState>> {
	/// @throws exception
	static godot::Ref<godot::RDPipelineColorBlendState> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::RDPipelineColorBlendState>((godot::RDPipelineColorBlendState *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::RDPipelineColorBlendState> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::RDPipelineColorBlendState>>(v) };
	}
};
template <>
struct js_traits<godot::RDPipelineColorBlendStateAttachment> {
	/// @throws exception
	static godot::RDPipelineColorBlendStateAttachment unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RDPipelineColorBlendStateAttachment *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RDPipelineColorBlendStateAttachment v) noexcept {
		return Value{ ctx, std::forward<godot::RDPipelineColorBlendStateAttachment>(v) };
	}
};
template <>
struct js_traits<godot::RDPipelineColorBlendStateAttachment &> {
	/// @throws exception
	static godot::RDPipelineColorBlendStateAttachment &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RDPipelineColorBlendStateAttachment *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RDPipelineColorBlendStateAttachment &v) noexcept {
		return Value{ ctx, std::forward<godot::RDPipelineColorBlendStateAttachment>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::RDPipelineColorBlendStateAttachment>> {
	/// @throws exception
	static godot::Ref<godot::RDPipelineColorBlendStateAttachment> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::RDPipelineColorBlendStateAttachment>((godot::RDPipelineColorBlendStateAttachment *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::RDPipelineColorBlendStateAttachment> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::RDPipelineColorBlendStateAttachment>>(v) };
	}
};
template <>
struct js_traits<godot::RDPipelineDepthStencilState> {
	/// @throws exception
	static godot::RDPipelineDepthStencilState unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RDPipelineDepthStencilState *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RDPipelineDepthStencilState v) noexcept {
		return Value{ ctx, std::forward<godot::RDPipelineDepthStencilState>(v) };
	}
};
template <>
struct js_traits<godot::RDPipelineDepthStencilState &> {
	/// @throws exception
	static godot::RDPipelineDepthStencilState &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RDPipelineDepthStencilState *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RDPipelineDepthStencilState &v) noexcept {
		return Value{ ctx, std::forward<godot::RDPipelineDepthStencilState>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::RDPipelineDepthStencilState>> {
	/// @throws exception
	static godot::Ref<godot::RDPipelineDepthStencilState> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::RDPipelineDepthStencilState>((godot::RDPipelineDepthStencilState *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::RDPipelineDepthStencilState> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::RDPipelineDepthStencilState>>(v) };
	}
};
template <>
struct js_traits<godot::RDPipelineMultisampleState> {
	/// @throws exception
	static godot::RDPipelineMultisampleState unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RDPipelineMultisampleState *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RDPipelineMultisampleState v) noexcept {
		return Value{ ctx, std::forward<godot::RDPipelineMultisampleState>(v) };
	}
};
template <>
struct js_traits<godot::RDPipelineMultisampleState &> {
	/// @throws exception
	static godot::RDPipelineMultisampleState &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RDPipelineMultisampleState *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RDPipelineMultisampleState &v) noexcept {
		return Value{ ctx, std::forward<godot::RDPipelineMultisampleState>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::RDPipelineMultisampleState>> {
	/// @throws exception
	static godot::Ref<godot::RDPipelineMultisampleState> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::RDPipelineMultisampleState>((godot::RDPipelineMultisampleState *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::RDPipelineMultisampleState> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::RDPipelineMultisampleState>>(v) };
	}
};
template <>
struct js_traits<godot::RDPipelineRasterizationState> {
	/// @throws exception
	static godot::RDPipelineRasterizationState unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RDPipelineRasterizationState *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RDPipelineRasterizationState v) noexcept {
		return Value{ ctx, std::forward<godot::RDPipelineRasterizationState>(v) };
	}
};
template <>
struct js_traits<godot::RDPipelineRasterizationState &> {
	/// @throws exception
	static godot::RDPipelineRasterizationState &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RDPipelineRasterizationState *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RDPipelineRasterizationState &v) noexcept {
		return Value{ ctx, std::forward<godot::RDPipelineRasterizationState>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::RDPipelineRasterizationState>> {
	/// @throws exception
	static godot::Ref<godot::RDPipelineRasterizationState> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::RDPipelineRasterizationState>((godot::RDPipelineRasterizationState *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::RDPipelineRasterizationState> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::RDPipelineRasterizationState>>(v) };
	}
};
template <>
struct js_traits<godot::RDPipelineSpecializationConstant> {
	/// @throws exception
	static godot::RDPipelineSpecializationConstant unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RDPipelineSpecializationConstant *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RDPipelineSpecializationConstant v) noexcept {
		return Value{ ctx, std::forward<godot::RDPipelineSpecializationConstant>(v) };
	}
};
template <>
struct js_traits<godot::RDPipelineSpecializationConstant &> {
	/// @throws exception
	static godot::RDPipelineSpecializationConstant &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RDPipelineSpecializationConstant *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RDPipelineSpecializationConstant &v) noexcept {
		return Value{ ctx, std::forward<godot::RDPipelineSpecializationConstant>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::RDPipelineSpecializationConstant>> {
	/// @throws exception
	static godot::Ref<godot::RDPipelineSpecializationConstant> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::RDPipelineSpecializationConstant>((godot::RDPipelineSpecializationConstant *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::RDPipelineSpecializationConstant> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::RDPipelineSpecializationConstant>>(v) };
	}
};
template <>
struct js_traits<godot::RDSamplerState> {
	/// @throws exception
	static godot::RDSamplerState unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RDSamplerState *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RDSamplerState v) noexcept {
		return Value{ ctx, std::forward<godot::RDSamplerState>(v) };
	}
};
template <>
struct js_traits<godot::RDSamplerState &> {
	/// @throws exception
	static godot::RDSamplerState &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RDSamplerState *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RDSamplerState &v) noexcept {
		return Value{ ctx, std::forward<godot::RDSamplerState>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::RDSamplerState>> {
	/// @throws exception
	static godot::Ref<godot::RDSamplerState> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::RDSamplerState>((godot::RDSamplerState *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::RDSamplerState> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::RDSamplerState>>(v) };
	}
};
template <>
struct js_traits<godot::RDShaderFile> {
	/// @throws exception
	static godot::RDShaderFile unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RDShaderFile *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RDShaderFile v) noexcept {
		return Value{ ctx, std::forward<godot::RDShaderFile>(v) };
	}
};
template <>
struct js_traits<godot::RDShaderFile &> {
	/// @throws exception
	static godot::RDShaderFile &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RDShaderFile *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RDShaderFile &v) noexcept {
		return Value{ ctx, std::forward<godot::RDShaderFile>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::RDShaderFile>> {
	/// @throws exception
	static godot::Ref<godot::RDShaderFile> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::RDShaderFile>((godot::RDShaderFile *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::RDShaderFile> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::RDShaderFile>>(v) };
	}
};
template <>
struct js_traits<godot::RDShaderSPIRV> {
	/// @throws exception
	static godot::RDShaderSPIRV unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RDShaderSPIRV *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RDShaderSPIRV v) noexcept {
		return Value{ ctx, std::forward<godot::RDShaderSPIRV>(v) };
	}
};
template <>
struct js_traits<godot::RDShaderSPIRV &> {
	/// @throws exception
	static godot::RDShaderSPIRV &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RDShaderSPIRV *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RDShaderSPIRV &v) noexcept {
		return Value{ ctx, std::forward<godot::RDShaderSPIRV>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::RDShaderSPIRV>> {
	/// @throws exception
	static godot::Ref<godot::RDShaderSPIRV> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::RDShaderSPIRV>((godot::RDShaderSPIRV *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::RDShaderSPIRV> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::RDShaderSPIRV>>(v) };
	}
};
template <>
struct js_traits<godot::RDShaderSource> {
	/// @throws exception
	static godot::RDShaderSource unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RDShaderSource *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RDShaderSource v) noexcept {
		return Value{ ctx, std::forward<godot::RDShaderSource>(v) };
	}
};
template <>
struct js_traits<godot::RDShaderSource &> {
	/// @throws exception
	static godot::RDShaderSource &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RDShaderSource *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RDShaderSource &v) noexcept {
		return Value{ ctx, std::forward<godot::RDShaderSource>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::RDShaderSource>> {
	/// @throws exception
	static godot::Ref<godot::RDShaderSource> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::RDShaderSource>((godot::RDShaderSource *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::RDShaderSource> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::RDShaderSource>>(v) };
	}
};
template <>
struct js_traits<godot::RDTextureFormat> {
	/// @throws exception
	static godot::RDTextureFormat unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RDTextureFormat *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RDTextureFormat v) noexcept {
		return Value{ ctx, std::forward<godot::RDTextureFormat>(v) };
	}
};
template <>
struct js_traits<godot::RDTextureFormat &> {
	/// @throws exception
	static godot::RDTextureFormat &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RDTextureFormat *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RDTextureFormat &v) noexcept {
		return Value{ ctx, std::forward<godot::RDTextureFormat>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::RDTextureFormat>> {
	/// @throws exception
	static godot::Ref<godot::RDTextureFormat> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::RDTextureFormat>((godot::RDTextureFormat *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::RDTextureFormat> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::RDTextureFormat>>(v) };
	}
};
template <>
struct js_traits<godot::RDTextureView> {
	/// @throws exception
	static godot::RDTextureView unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RDTextureView *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RDTextureView v) noexcept {
		return Value{ ctx, std::forward<godot::RDTextureView>(v) };
	}
};
template <>
struct js_traits<godot::RDTextureView &> {
	/// @throws exception
	static godot::RDTextureView &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RDTextureView *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RDTextureView &v) noexcept {
		return Value{ ctx, std::forward<godot::RDTextureView>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::RDTextureView>> {
	/// @throws exception
	static godot::Ref<godot::RDTextureView> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::RDTextureView>((godot::RDTextureView *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::RDTextureView> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::RDTextureView>>(v) };
	}
};
template <>
struct js_traits<godot::RDUniform> {
	/// @throws exception
	static godot::RDUniform unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RDUniform *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RDUniform v) noexcept {
		return Value{ ctx, std::forward<godot::RDUniform>(v) };
	}
};
template <>
struct js_traits<godot::RDUniform &> {
	/// @throws exception
	static godot::RDUniform &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RDUniform *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RDUniform &v) noexcept {
		return Value{ ctx, std::forward<godot::RDUniform>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::RDUniform>> {
	/// @throws exception
	static godot::Ref<godot::RDUniform> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::RDUniform>((godot::RDUniform *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::RDUniform> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::RDUniform>>(v) };
	}
};
template <>
struct js_traits<godot::RDVertexAttribute> {
	/// @throws exception
	static godot::RDVertexAttribute unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RDVertexAttribute *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RDVertexAttribute v) noexcept {
		return Value{ ctx, std::forward<godot::RDVertexAttribute>(v) };
	}
};
template <>
struct js_traits<godot::RDVertexAttribute &> {
	/// @throws exception
	static godot::RDVertexAttribute &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RDVertexAttribute *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RDVertexAttribute &v) noexcept {
		return Value{ ctx, std::forward<godot::RDVertexAttribute>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::RDVertexAttribute>> {
	/// @throws exception
	static godot::Ref<godot::RDVertexAttribute> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::RDVertexAttribute>((godot::RDVertexAttribute *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::RDVertexAttribute> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::RDVertexAttribute>>(v) };
	}
};
template <>
struct js_traits<godot::RandomNumberGenerator> {
	/// @throws exception
	static godot::RandomNumberGenerator unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RandomNumberGenerator *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RandomNumberGenerator v) noexcept {
		return Value{ ctx, std::forward<godot::RandomNumberGenerator>(v) };
	}
};
template <>
struct js_traits<godot::RandomNumberGenerator &> {
	/// @throws exception
	static godot::RandomNumberGenerator &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RandomNumberGenerator *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RandomNumberGenerator &v) noexcept {
		return Value{ ctx, std::forward<godot::RandomNumberGenerator>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::RandomNumberGenerator>> {
	/// @throws exception
	static godot::Ref<godot::RandomNumberGenerator> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::RandomNumberGenerator>((godot::RandomNumberGenerator *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::RandomNumberGenerator> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::RandomNumberGenerator>>(v) };
	}
};
template <>
struct js_traits<godot::Range> {
	/// @throws exception
	static godot::Range unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Range *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Range v) noexcept {
		return Value{ ctx, std::forward<godot::Range>(v) };
	}
};
template <>
struct js_traits<godot::Range &> {
	/// @throws exception
	static godot::Range &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Range *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Range &v) noexcept {
		return Value{ ctx, std::forward<godot::Range>(v) };
	}
};
template <>
struct js_traits<godot::RayCast2D> {
	/// @throws exception
	static godot::RayCast2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RayCast2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RayCast2D v) noexcept {
		return Value{ ctx, std::forward<godot::RayCast2D>(v) };
	}
};
template <>
struct js_traits<godot::RayCast2D &> {
	/// @throws exception
	static godot::RayCast2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RayCast2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RayCast2D &v) noexcept {
		return Value{ ctx, std::forward<godot::RayCast2D>(v) };
	}
};
template <>
struct js_traits<godot::RayCast3D> {
	/// @throws exception
	static godot::RayCast3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RayCast3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RayCast3D v) noexcept {
		return Value{ ctx, std::forward<godot::RayCast3D>(v) };
	}
};
template <>
struct js_traits<godot::RayCast3D &> {
	/// @throws exception
	static godot::RayCast3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RayCast3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RayCast3D &v) noexcept {
		return Value{ ctx, std::forward<godot::RayCast3D>(v) };
	}
};
template <>
struct js_traits<godot::RectangleShape2D> {
	/// @throws exception
	static godot::RectangleShape2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RectangleShape2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RectangleShape2D v) noexcept {
		return Value{ ctx, std::forward<godot::RectangleShape2D>(v) };
	}
};
template <>
struct js_traits<godot::RectangleShape2D &> {
	/// @throws exception
	static godot::RectangleShape2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RectangleShape2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RectangleShape2D &v) noexcept {
		return Value{ ctx, std::forward<godot::RectangleShape2D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::RectangleShape2D>> {
	/// @throws exception
	static godot::Ref<godot::RectangleShape2D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::RectangleShape2D>((godot::RectangleShape2D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::RectangleShape2D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::RectangleShape2D>>(v) };
	}
};
template <>
struct js_traits<godot::RefCounted> {
	/// @throws exception
	static godot::RefCounted unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RefCounted *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RefCounted v) noexcept {
		return Value{ ctx, std::forward<godot::RefCounted>(v) };
	}
};
template <>
struct js_traits<godot::RefCounted &> {
	/// @throws exception
	static godot::RefCounted &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RefCounted *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RefCounted &v) noexcept {
		return Value{ ctx, std::forward<godot::RefCounted>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::RefCounted>> {
	/// @throws exception
	static godot::Ref<godot::RefCounted> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::RefCounted>((godot::RefCounted *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::RefCounted> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::RefCounted>>(v) };
	}
};
template <>
struct js_traits<godot::ReferenceRect> {
	/// @throws exception
	static godot::ReferenceRect unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ReferenceRect *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ReferenceRect v) noexcept {
		return Value{ ctx, std::forward<godot::ReferenceRect>(v) };
	}
};
template <>
struct js_traits<godot::ReferenceRect &> {
	/// @throws exception
	static godot::ReferenceRect &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ReferenceRect *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ReferenceRect &v) noexcept {
		return Value{ ctx, std::forward<godot::ReferenceRect>(v) };
	}
};
template <>
struct js_traits<godot::ReflectionProbe> {
	/// @throws exception
	static godot::ReflectionProbe unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ReflectionProbe *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ReflectionProbe v) noexcept {
		return Value{ ctx, std::forward<godot::ReflectionProbe>(v) };
	}
};
template <>
struct js_traits<godot::ReflectionProbe &> {
	/// @throws exception
	static godot::ReflectionProbe &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ReflectionProbe *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ReflectionProbe &v) noexcept {
		return Value{ ctx, std::forward<godot::ReflectionProbe>(v) };
	}
};
template <>
struct js_traits<godot::RegEx> {
	/// @throws exception
	static godot::RegEx unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RegEx *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RegEx v) noexcept {
		return Value{ ctx, std::forward<godot::RegEx>(v) };
	}
};
template <>
struct js_traits<godot::RegEx &> {
	/// @throws exception
	static godot::RegEx &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RegEx *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RegEx &v) noexcept {
		return Value{ ctx, std::forward<godot::RegEx>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::RegEx>> {
	/// @throws exception
	static godot::Ref<godot::RegEx> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::RegEx>((godot::RegEx *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::RegEx> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::RegEx>>(v) };
	}
};
template <>
struct js_traits<godot::RegExMatch> {
	/// @throws exception
	static godot::RegExMatch unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RegExMatch *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RegExMatch v) noexcept {
		return Value{ ctx, std::forward<godot::RegExMatch>(v) };
	}
};
template <>
struct js_traits<godot::RegExMatch &> {
	/// @throws exception
	static godot::RegExMatch &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RegExMatch *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RegExMatch &v) noexcept {
		return Value{ ctx, std::forward<godot::RegExMatch>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::RegExMatch>> {
	/// @throws exception
	static godot::Ref<godot::RegExMatch> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::RegExMatch>((godot::RegExMatch *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::RegExMatch> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::RegExMatch>>(v) };
	}
};
template <>
struct js_traits<godot::RemoteTransform2D> {
	/// @throws exception
	static godot::RemoteTransform2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RemoteTransform2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RemoteTransform2D v) noexcept {
		return Value{ ctx, std::forward<godot::RemoteTransform2D>(v) };
	}
};
template <>
struct js_traits<godot::RemoteTransform2D &> {
	/// @throws exception
	static godot::RemoteTransform2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RemoteTransform2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RemoteTransform2D &v) noexcept {
		return Value{ ctx, std::forward<godot::RemoteTransform2D>(v) };
	}
};
template <>
struct js_traits<godot::RemoteTransform3D> {
	/// @throws exception
	static godot::RemoteTransform3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RemoteTransform3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RemoteTransform3D v) noexcept {
		return Value{ ctx, std::forward<godot::RemoteTransform3D>(v) };
	}
};
template <>
struct js_traits<godot::RemoteTransform3D &> {
	/// @throws exception
	static godot::RemoteTransform3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RemoteTransform3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RemoteTransform3D &v) noexcept {
		return Value{ ctx, std::forward<godot::RemoteTransform3D>(v) };
	}
};
template <>
struct js_traits<godot::RenderSceneBuffers> {
	/// @throws exception
	static godot::RenderSceneBuffers unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RenderSceneBuffers *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RenderSceneBuffers v) noexcept {
		return Value{ ctx, std::forward<godot::RenderSceneBuffers>(v) };
	}
};
template <>
struct js_traits<godot::RenderSceneBuffers &> {
	/// @throws exception
	static godot::RenderSceneBuffers &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RenderSceneBuffers *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RenderSceneBuffers &v) noexcept {
		return Value{ ctx, std::forward<godot::RenderSceneBuffers>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::RenderSceneBuffers>> {
	/// @throws exception
	static godot::Ref<godot::RenderSceneBuffers> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::RenderSceneBuffers>((godot::RenderSceneBuffers *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::RenderSceneBuffers> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::RenderSceneBuffers>>(v) };
	}
};
template <>
struct js_traits<godot::RenderSceneBuffersConfiguration> {
	/// @throws exception
	static godot::RenderSceneBuffersConfiguration unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RenderSceneBuffersConfiguration *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RenderSceneBuffersConfiguration v) noexcept {
		return Value{ ctx, std::forward<godot::RenderSceneBuffersConfiguration>(v) };
	}
};
template <>
struct js_traits<godot::RenderSceneBuffersConfiguration &> {
	/// @throws exception
	static godot::RenderSceneBuffersConfiguration &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RenderSceneBuffersConfiguration *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RenderSceneBuffersConfiguration &v) noexcept {
		return Value{ ctx, std::forward<godot::RenderSceneBuffersConfiguration>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::RenderSceneBuffersConfiguration>> {
	/// @throws exception
	static godot::Ref<godot::RenderSceneBuffersConfiguration> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::RenderSceneBuffersConfiguration>((godot::RenderSceneBuffersConfiguration *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::RenderSceneBuffersConfiguration> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::RenderSceneBuffersConfiguration>>(v) };
	}
};
template <>
struct js_traits<godot::RenderSceneBuffersExtension> {
	/// @throws exception
	static godot::RenderSceneBuffersExtension unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RenderSceneBuffersExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RenderSceneBuffersExtension v) noexcept {
		return Value{ ctx, std::forward<godot::RenderSceneBuffersExtension>(v) };
	}
};
template <>
struct js_traits<godot::RenderSceneBuffersExtension &> {
	/// @throws exception
	static godot::RenderSceneBuffersExtension &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RenderSceneBuffersExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RenderSceneBuffersExtension &v) noexcept {
		return Value{ ctx, std::forward<godot::RenderSceneBuffersExtension>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::RenderSceneBuffersExtension>> {
	/// @throws exception
	static godot::Ref<godot::RenderSceneBuffersExtension> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::RenderSceneBuffersExtension>((godot::RenderSceneBuffersExtension *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::RenderSceneBuffersExtension> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::RenderSceneBuffersExtension>>(v) };
	}
};
template <>
struct js_traits<godot::RenderSceneBuffersRD> {
	/// @throws exception
	static godot::RenderSceneBuffersRD unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RenderSceneBuffersRD *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RenderSceneBuffersRD v) noexcept {
		return Value{ ctx, std::forward<godot::RenderSceneBuffersRD>(v) };
	}
};
template <>
struct js_traits<godot::RenderSceneBuffersRD &> {
	/// @throws exception
	static godot::RenderSceneBuffersRD &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RenderSceneBuffersRD *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RenderSceneBuffersRD &v) noexcept {
		return Value{ ctx, std::forward<godot::RenderSceneBuffersRD>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::RenderSceneBuffersRD>> {
	/// @throws exception
	static godot::Ref<godot::RenderSceneBuffersRD> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::RenderSceneBuffersRD>((godot::RenderSceneBuffersRD *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::RenderSceneBuffersRD> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::RenderSceneBuffersRD>>(v) };
	}
};
template <>
struct js_traits<godot::RenderingDevice> {
	/// @throws exception
	static godot::RenderingDevice unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RenderingDevice *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RenderingDevice v) noexcept {
		return Value{ ctx, std::forward<godot::RenderingDevice>(v) };
	}
};
template <>
struct js_traits<godot::RenderingDevice &> {
	/// @throws exception
	static godot::RenderingDevice &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RenderingDevice *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RenderingDevice &v) noexcept {
		return Value{ ctx, std::forward<godot::RenderingDevice>(v) };
	}
};
template <>
struct js_traits<godot::RenderingServer> {
	/// @throws exception
	static godot::RenderingServer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RenderingServer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RenderingServer v) noexcept {
		return Value{ ctx, std::forward<godot::RenderingServer>(v) };
	}
};
template <>
struct js_traits<godot::RenderingServer &> {
	/// @throws exception
	static godot::RenderingServer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RenderingServer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RenderingServer &v) noexcept {
		return Value{ ctx, std::forward<godot::RenderingServer>(v) };
	}
};
template <>
struct js_traits<godot::Resource> {
	/// @throws exception
	static godot::Resource unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Resource *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Resource v) noexcept {
		return Value{ ctx, std::forward<godot::Resource>(v) };
	}
};
template <>
struct js_traits<godot::Resource &> {
	/// @throws exception
	static godot::Resource &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Resource *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Resource &v) noexcept {
		return Value{ ctx, std::forward<godot::Resource>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Resource>> {
	/// @throws exception
	static godot::Ref<godot::Resource> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Resource>((godot::Resource *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Resource> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Resource>>(v) };
	}
};
template <>
struct js_traits<godot::ResourceFormatLoader> {
	/// @throws exception
	static godot::ResourceFormatLoader unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceFormatLoader *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceFormatLoader v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceFormatLoader>(v) };
	}
};
template <>
struct js_traits<godot::ResourceFormatLoader &> {
	/// @throws exception
	static godot::ResourceFormatLoader &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceFormatLoader *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceFormatLoader &v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceFormatLoader>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ResourceFormatLoader>> {
	/// @throws exception
	static godot::Ref<godot::ResourceFormatLoader> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ResourceFormatLoader>((godot::ResourceFormatLoader *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ResourceFormatLoader> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ResourceFormatLoader>>(v) };
	}
};
template <>
struct js_traits<godot::ResourceFormatSaver> {
	/// @throws exception
	static godot::ResourceFormatSaver unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceFormatSaver *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceFormatSaver v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceFormatSaver>(v) };
	}
};
template <>
struct js_traits<godot::ResourceFormatSaver &> {
	/// @throws exception
	static godot::ResourceFormatSaver &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceFormatSaver *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceFormatSaver &v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceFormatSaver>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ResourceFormatSaver>> {
	/// @throws exception
	static godot::Ref<godot::ResourceFormatSaver> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ResourceFormatSaver>((godot::ResourceFormatSaver *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ResourceFormatSaver> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ResourceFormatSaver>>(v) };
	}
};
template <>
struct js_traits<godot::ResourceImporter> {
	/// @throws exception
	static godot::ResourceImporter unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceImporter *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceImporter v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceImporter>(v) };
	}
};
template <>
struct js_traits<godot::ResourceImporter &> {
	/// @throws exception
	static godot::ResourceImporter &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceImporter *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceImporter &v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceImporter>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ResourceImporter>> {
	/// @throws exception
	static godot::Ref<godot::ResourceImporter> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ResourceImporter>((godot::ResourceImporter *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ResourceImporter> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ResourceImporter>>(v) };
	}
};
template <>
struct js_traits<godot::ResourceImporterBMFont> {
	/// @throws exception
	static godot::ResourceImporterBMFont unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceImporterBMFont *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceImporterBMFont v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceImporterBMFont>(v) };
	}
};
template <>
struct js_traits<godot::ResourceImporterBMFont &> {
	/// @throws exception
	static godot::ResourceImporterBMFont &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceImporterBMFont *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceImporterBMFont &v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceImporterBMFont>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ResourceImporterBMFont>> {
	/// @throws exception
	static godot::Ref<godot::ResourceImporterBMFont> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ResourceImporterBMFont>((godot::ResourceImporterBMFont *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ResourceImporterBMFont> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ResourceImporterBMFont>>(v) };
	}
};
template <>
struct js_traits<godot::ResourceImporterBitMap> {
	/// @throws exception
	static godot::ResourceImporterBitMap unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceImporterBitMap *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceImporterBitMap v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceImporterBitMap>(v) };
	}
};
template <>
struct js_traits<godot::ResourceImporterBitMap &> {
	/// @throws exception
	static godot::ResourceImporterBitMap &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceImporterBitMap *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceImporterBitMap &v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceImporterBitMap>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ResourceImporterBitMap>> {
	/// @throws exception
	static godot::Ref<godot::ResourceImporterBitMap> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ResourceImporterBitMap>((godot::ResourceImporterBitMap *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ResourceImporterBitMap> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ResourceImporterBitMap>>(v) };
	}
};
template <>
struct js_traits<godot::ResourceImporterCSVTranslation> {
	/// @throws exception
	static godot::ResourceImporterCSVTranslation unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceImporterCSVTranslation *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceImporterCSVTranslation v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceImporterCSVTranslation>(v) };
	}
};
template <>
struct js_traits<godot::ResourceImporterCSVTranslation &> {
	/// @throws exception
	static godot::ResourceImporterCSVTranslation &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceImporterCSVTranslation *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceImporterCSVTranslation &v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceImporterCSVTranslation>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ResourceImporterCSVTranslation>> {
	/// @throws exception
	static godot::Ref<godot::ResourceImporterCSVTranslation> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ResourceImporterCSVTranslation>((godot::ResourceImporterCSVTranslation *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ResourceImporterCSVTranslation> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ResourceImporterCSVTranslation>>(v) };
	}
};
template <>
struct js_traits<godot::ResourceImporterDynamicFont> {
	/// @throws exception
	static godot::ResourceImporterDynamicFont unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceImporterDynamicFont *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceImporterDynamicFont v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceImporterDynamicFont>(v) };
	}
};
template <>
struct js_traits<godot::ResourceImporterDynamicFont &> {
	/// @throws exception
	static godot::ResourceImporterDynamicFont &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceImporterDynamicFont *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceImporterDynamicFont &v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceImporterDynamicFont>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ResourceImporterDynamicFont>> {
	/// @throws exception
	static godot::Ref<godot::ResourceImporterDynamicFont> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ResourceImporterDynamicFont>((godot::ResourceImporterDynamicFont *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ResourceImporterDynamicFont> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ResourceImporterDynamicFont>>(v) };
	}
};
template <>
struct js_traits<godot::ResourceImporterImage> {
	/// @throws exception
	static godot::ResourceImporterImage unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceImporterImage *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceImporterImage v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceImporterImage>(v) };
	}
};
template <>
struct js_traits<godot::ResourceImporterImage &> {
	/// @throws exception
	static godot::ResourceImporterImage &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceImporterImage *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceImporterImage &v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceImporterImage>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ResourceImporterImage>> {
	/// @throws exception
	static godot::Ref<godot::ResourceImporterImage> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ResourceImporterImage>((godot::ResourceImporterImage *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ResourceImporterImage> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ResourceImporterImage>>(v) };
	}
};
template <>
struct js_traits<godot::ResourceImporterImageFont> {
	/// @throws exception
	static godot::ResourceImporterImageFont unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceImporterImageFont *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceImporterImageFont v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceImporterImageFont>(v) };
	}
};
template <>
struct js_traits<godot::ResourceImporterImageFont &> {
	/// @throws exception
	static godot::ResourceImporterImageFont &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceImporterImageFont *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceImporterImageFont &v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceImporterImageFont>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ResourceImporterImageFont>> {
	/// @throws exception
	static godot::Ref<godot::ResourceImporterImageFont> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ResourceImporterImageFont>((godot::ResourceImporterImageFont *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ResourceImporterImageFont> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ResourceImporterImageFont>>(v) };
	}
};
template <>
struct js_traits<godot::ResourceImporterLayeredTexture> {
	/// @throws exception
	static godot::ResourceImporterLayeredTexture unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceImporterLayeredTexture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceImporterLayeredTexture v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceImporterLayeredTexture>(v) };
	}
};
template <>
struct js_traits<godot::ResourceImporterLayeredTexture &> {
	/// @throws exception
	static godot::ResourceImporterLayeredTexture &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceImporterLayeredTexture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceImporterLayeredTexture &v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceImporterLayeredTexture>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ResourceImporterLayeredTexture>> {
	/// @throws exception
	static godot::Ref<godot::ResourceImporterLayeredTexture> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ResourceImporterLayeredTexture>((godot::ResourceImporterLayeredTexture *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ResourceImporterLayeredTexture> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ResourceImporterLayeredTexture>>(v) };
	}
};
template <>
struct js_traits<godot::ResourceImporterMP3> {
	/// @throws exception
	static godot::ResourceImporterMP3 unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceImporterMP3 *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceImporterMP3 v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceImporterMP3>(v) };
	}
};
template <>
struct js_traits<godot::ResourceImporterMP3 &> {
	/// @throws exception
	static godot::ResourceImporterMP3 &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceImporterMP3 *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceImporterMP3 &v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceImporterMP3>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ResourceImporterMP3>> {
	/// @throws exception
	static godot::Ref<godot::ResourceImporterMP3> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ResourceImporterMP3>((godot::ResourceImporterMP3 *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ResourceImporterMP3> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ResourceImporterMP3>>(v) };
	}
};
template <>
struct js_traits<godot::ResourceImporterOBJ> {
	/// @throws exception
	static godot::ResourceImporterOBJ unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceImporterOBJ *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceImporterOBJ v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceImporterOBJ>(v) };
	}
};
template <>
struct js_traits<godot::ResourceImporterOBJ &> {
	/// @throws exception
	static godot::ResourceImporterOBJ &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceImporterOBJ *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceImporterOBJ &v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceImporterOBJ>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ResourceImporterOBJ>> {
	/// @throws exception
	static godot::Ref<godot::ResourceImporterOBJ> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ResourceImporterOBJ>((godot::ResourceImporterOBJ *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ResourceImporterOBJ> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ResourceImporterOBJ>>(v) };
	}
};
template <>
struct js_traits<godot::ResourceImporterOggVorbis> {
	/// @throws exception
	static godot::ResourceImporterOggVorbis unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceImporterOggVorbis *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceImporterOggVorbis v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceImporterOggVorbis>(v) };
	}
};
template <>
struct js_traits<godot::ResourceImporterOggVorbis &> {
	/// @throws exception
	static godot::ResourceImporterOggVorbis &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceImporterOggVorbis *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceImporterOggVorbis &v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceImporterOggVorbis>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ResourceImporterOggVorbis>> {
	/// @throws exception
	static godot::Ref<godot::ResourceImporterOggVorbis> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ResourceImporterOggVorbis>((godot::ResourceImporterOggVorbis *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ResourceImporterOggVorbis> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ResourceImporterOggVorbis>>(v) };
	}
};
template <>
struct js_traits<godot::ResourceImporterScene> {
	/// @throws exception
	static godot::ResourceImporterScene unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceImporterScene *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceImporterScene v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceImporterScene>(v) };
	}
};
template <>
struct js_traits<godot::ResourceImporterScene &> {
	/// @throws exception
	static godot::ResourceImporterScene &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceImporterScene *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceImporterScene &v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceImporterScene>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ResourceImporterScene>> {
	/// @throws exception
	static godot::Ref<godot::ResourceImporterScene> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ResourceImporterScene>((godot::ResourceImporterScene *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ResourceImporterScene> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ResourceImporterScene>>(v) };
	}
};
template <>
struct js_traits<godot::ResourceImporterShaderFile> {
	/// @throws exception
	static godot::ResourceImporterShaderFile unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceImporterShaderFile *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceImporterShaderFile v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceImporterShaderFile>(v) };
	}
};
template <>
struct js_traits<godot::ResourceImporterShaderFile &> {
	/// @throws exception
	static godot::ResourceImporterShaderFile &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceImporterShaderFile *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceImporterShaderFile &v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceImporterShaderFile>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ResourceImporterShaderFile>> {
	/// @throws exception
	static godot::Ref<godot::ResourceImporterShaderFile> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ResourceImporterShaderFile>((godot::ResourceImporterShaderFile *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ResourceImporterShaderFile> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ResourceImporterShaderFile>>(v) };
	}
};
template <>
struct js_traits<godot::ResourceImporterTexture> {
	/// @throws exception
	static godot::ResourceImporterTexture unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceImporterTexture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceImporterTexture v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceImporterTexture>(v) };
	}
};
template <>
struct js_traits<godot::ResourceImporterTexture &> {
	/// @throws exception
	static godot::ResourceImporterTexture &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceImporterTexture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceImporterTexture &v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceImporterTexture>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ResourceImporterTexture>> {
	/// @throws exception
	static godot::Ref<godot::ResourceImporterTexture> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ResourceImporterTexture>((godot::ResourceImporterTexture *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ResourceImporterTexture> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ResourceImporterTexture>>(v) };
	}
};
template <>
struct js_traits<godot::ResourceImporterTextureAtlas> {
	/// @throws exception
	static godot::ResourceImporterTextureAtlas unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceImporterTextureAtlas *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceImporterTextureAtlas v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceImporterTextureAtlas>(v) };
	}
};
template <>
struct js_traits<godot::ResourceImporterTextureAtlas &> {
	/// @throws exception
	static godot::ResourceImporterTextureAtlas &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceImporterTextureAtlas *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceImporterTextureAtlas &v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceImporterTextureAtlas>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ResourceImporterTextureAtlas>> {
	/// @throws exception
	static godot::Ref<godot::ResourceImporterTextureAtlas> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ResourceImporterTextureAtlas>((godot::ResourceImporterTextureAtlas *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ResourceImporterTextureAtlas> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ResourceImporterTextureAtlas>>(v) };
	}
};
template <>
struct js_traits<godot::ResourceImporterWAV> {
	/// @throws exception
	static godot::ResourceImporterWAV unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceImporterWAV *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceImporterWAV v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceImporterWAV>(v) };
	}
};
template <>
struct js_traits<godot::ResourceImporterWAV &> {
	/// @throws exception
	static godot::ResourceImporterWAV &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceImporterWAV *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceImporterWAV &v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceImporterWAV>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ResourceImporterWAV>> {
	/// @throws exception
	static godot::Ref<godot::ResourceImporterWAV> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ResourceImporterWAV>((godot::ResourceImporterWAV *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ResourceImporterWAV> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ResourceImporterWAV>>(v) };
	}
};
template <>
struct js_traits<godot::ResourceLoader> {
	/// @throws exception
	static godot::ResourceLoader unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceLoader *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceLoader v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceLoader>(v) };
	}
};
template <>
struct js_traits<godot::ResourceLoader &> {
	/// @throws exception
	static godot::ResourceLoader &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceLoader *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceLoader &v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceLoader>(v) };
	}
};
template <>
struct js_traits<godot::ResourcePreloader> {
	/// @throws exception
	static godot::ResourcePreloader unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourcePreloader *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourcePreloader v) noexcept {
		return Value{ ctx, std::forward<godot::ResourcePreloader>(v) };
	}
};
template <>
struct js_traits<godot::ResourcePreloader &> {
	/// @throws exception
	static godot::ResourcePreloader &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourcePreloader *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourcePreloader &v) noexcept {
		return Value{ ctx, std::forward<godot::ResourcePreloader>(v) };
	}
};
template <>
struct js_traits<godot::ResourceSaver> {
	/// @throws exception
	static godot::ResourceSaver unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceSaver *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceSaver v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceSaver>(v) };
	}
};
template <>
struct js_traits<godot::ResourceSaver &> {
	/// @throws exception
	static godot::ResourceSaver &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceSaver *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceSaver &v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceSaver>(v) };
	}
};
template <>
struct js_traits<godot::ResourceUID> {
	/// @throws exception
	static godot::ResourceUID unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceUID *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceUID v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceUID>(v) };
	}
};
template <>
struct js_traits<godot::ResourceUID &> {
	/// @throws exception
	static godot::ResourceUID &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ResourceUID *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ResourceUID &v) noexcept {
		return Value{ ctx, std::forward<godot::ResourceUID>(v) };
	}
};
template <>
struct js_traits<godot::RibbonTrailMesh> {
	/// @throws exception
	static godot::RibbonTrailMesh unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RibbonTrailMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RibbonTrailMesh v) noexcept {
		return Value{ ctx, std::forward<godot::RibbonTrailMesh>(v) };
	}
};
template <>
struct js_traits<godot::RibbonTrailMesh &> {
	/// @throws exception
	static godot::RibbonTrailMesh &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RibbonTrailMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RibbonTrailMesh &v) noexcept {
		return Value{ ctx, std::forward<godot::RibbonTrailMesh>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::RibbonTrailMesh>> {
	/// @throws exception
	static godot::Ref<godot::RibbonTrailMesh> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::RibbonTrailMesh>((godot::RibbonTrailMesh *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::RibbonTrailMesh> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::RibbonTrailMesh>>(v) };
	}
};
template <>
struct js_traits<godot::RichTextEffect> {
	/// @throws exception
	static godot::RichTextEffect unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RichTextEffect *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RichTextEffect v) noexcept {
		return Value{ ctx, std::forward<godot::RichTextEffect>(v) };
	}
};
template <>
struct js_traits<godot::RichTextEffect &> {
	/// @throws exception
	static godot::RichTextEffect &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RichTextEffect *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RichTextEffect &v) noexcept {
		return Value{ ctx, std::forward<godot::RichTextEffect>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::RichTextEffect>> {
	/// @throws exception
	static godot::Ref<godot::RichTextEffect> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::RichTextEffect>((godot::RichTextEffect *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::RichTextEffect> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::RichTextEffect>>(v) };
	}
};
template <>
struct js_traits<godot::RichTextLabel> {
	/// @throws exception
	static godot::RichTextLabel unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RichTextLabel *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RichTextLabel v) noexcept {
		return Value{ ctx, std::forward<godot::RichTextLabel>(v) };
	}
};
template <>
struct js_traits<godot::RichTextLabel &> {
	/// @throws exception
	static godot::RichTextLabel &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RichTextLabel *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RichTextLabel &v) noexcept {
		return Value{ ctx, std::forward<godot::RichTextLabel>(v) };
	}
};
template <>
struct js_traits<godot::RigidBody2D> {
	/// @throws exception
	static godot::RigidBody2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RigidBody2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RigidBody2D v) noexcept {
		return Value{ ctx, std::forward<godot::RigidBody2D>(v) };
	}
};
template <>
struct js_traits<godot::RigidBody2D &> {
	/// @throws exception
	static godot::RigidBody2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RigidBody2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RigidBody2D &v) noexcept {
		return Value{ ctx, std::forward<godot::RigidBody2D>(v) };
	}
};
template <>
struct js_traits<godot::RigidBody3D> {
	/// @throws exception
	static godot::RigidBody3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RigidBody3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RigidBody3D v) noexcept {
		return Value{ ctx, std::forward<godot::RigidBody3D>(v) };
	}
};
template <>
struct js_traits<godot::RigidBody3D &> {
	/// @throws exception
	static godot::RigidBody3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RigidBody3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RigidBody3D &v) noexcept {
		return Value{ ctx, std::forward<godot::RigidBody3D>(v) };
	}
};
template <>
struct js_traits<godot::RootMotionView> {
	/// @throws exception
	static godot::RootMotionView unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RootMotionView *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RootMotionView v) noexcept {
		return Value{ ctx, std::forward<godot::RootMotionView>(v) };
	}
};
template <>
struct js_traits<godot::RootMotionView &> {
	/// @throws exception
	static godot::RootMotionView &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RootMotionView *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RootMotionView &v) noexcept {
		return Value{ ctx, std::forward<godot::RootMotionView>(v) };
	}
};
template <>
struct js_traits<godot::SceneMultiplayer> {
	/// @throws exception
	static godot::SceneMultiplayer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SceneMultiplayer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SceneMultiplayer v) noexcept {
		return Value{ ctx, std::forward<godot::SceneMultiplayer>(v) };
	}
};
template <>
struct js_traits<godot::SceneMultiplayer &> {
	/// @throws exception
	static godot::SceneMultiplayer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SceneMultiplayer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SceneMultiplayer &v) noexcept {
		return Value{ ctx, std::forward<godot::SceneMultiplayer>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::SceneMultiplayer>> {
	/// @throws exception
	static godot::Ref<godot::SceneMultiplayer> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::SceneMultiplayer>((godot::SceneMultiplayer *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::SceneMultiplayer> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::SceneMultiplayer>>(v) };
	}
};
template <>
struct js_traits<godot::SceneReplicationConfig> {
	/// @throws exception
	static godot::SceneReplicationConfig unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SceneReplicationConfig *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SceneReplicationConfig v) noexcept {
		return Value{ ctx, std::forward<godot::SceneReplicationConfig>(v) };
	}
};
template <>
struct js_traits<godot::SceneReplicationConfig &> {
	/// @throws exception
	static godot::SceneReplicationConfig &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SceneReplicationConfig *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SceneReplicationConfig &v) noexcept {
		return Value{ ctx, std::forward<godot::SceneReplicationConfig>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::SceneReplicationConfig>> {
	/// @throws exception
	static godot::Ref<godot::SceneReplicationConfig> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::SceneReplicationConfig>((godot::SceneReplicationConfig *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::SceneReplicationConfig> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::SceneReplicationConfig>>(v) };
	}
};
template <>
struct js_traits<godot::SceneState> {
	/// @throws exception
	static godot::SceneState unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SceneState *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SceneState v) noexcept {
		return Value{ ctx, std::forward<godot::SceneState>(v) };
	}
};
template <>
struct js_traits<godot::SceneState &> {
	/// @throws exception
	static godot::SceneState &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SceneState *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SceneState &v) noexcept {
		return Value{ ctx, std::forward<godot::SceneState>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::SceneState>> {
	/// @throws exception
	static godot::Ref<godot::SceneState> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::SceneState>((godot::SceneState *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::SceneState> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::SceneState>>(v) };
	}
};
template <>
struct js_traits<godot::SceneTree> {
	/// @throws exception
	static godot::SceneTree unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SceneTree *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SceneTree v) noexcept {
		return Value{ ctx, std::forward<godot::SceneTree>(v) };
	}
};
template <>
struct js_traits<godot::SceneTree &> {
	/// @throws exception
	static godot::SceneTree &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SceneTree *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SceneTree &v) noexcept {
		return Value{ ctx, std::forward<godot::SceneTree>(v) };
	}
};
template <>
struct js_traits<godot::SceneTreeTimer> {
	/// @throws exception
	static godot::SceneTreeTimer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SceneTreeTimer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SceneTreeTimer v) noexcept {
		return Value{ ctx, std::forward<godot::SceneTreeTimer>(v) };
	}
};
template <>
struct js_traits<godot::SceneTreeTimer &> {
	/// @throws exception
	static godot::SceneTreeTimer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SceneTreeTimer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SceneTreeTimer &v) noexcept {
		return Value{ ctx, std::forward<godot::SceneTreeTimer>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::SceneTreeTimer>> {
	/// @throws exception
	static godot::Ref<godot::SceneTreeTimer> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::SceneTreeTimer>((godot::SceneTreeTimer *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::SceneTreeTimer> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::SceneTreeTimer>>(v) };
	}
};
template <>
struct js_traits<godot::Script> {
	/// @throws exception
	static godot::Script unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Script *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Script v) noexcept {
		return Value{ ctx, std::forward<godot::Script>(v) };
	}
};
template <>
struct js_traits<godot::Script &> {
	/// @throws exception
	static godot::Script &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Script *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Script &v) noexcept {
		return Value{ ctx, std::forward<godot::Script>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Script>> {
	/// @throws exception
	static godot::Ref<godot::Script> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Script>((godot::Script *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Script> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Script>>(v) };
	}
};
template <>
struct js_traits<godot::ScriptCreateDialog> {
	/// @throws exception
	static godot::ScriptCreateDialog unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ScriptCreateDialog *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ScriptCreateDialog v) noexcept {
		return Value{ ctx, std::forward<godot::ScriptCreateDialog>(v) };
	}
};
template <>
struct js_traits<godot::ScriptCreateDialog &> {
	/// @throws exception
	static godot::ScriptCreateDialog &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ScriptCreateDialog *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ScriptCreateDialog &v) noexcept {
		return Value{ ctx, std::forward<godot::ScriptCreateDialog>(v) };
	}
};
template <>
struct js_traits<godot::ScriptEditor> {
	/// @throws exception
	static godot::ScriptEditor unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ScriptEditor *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ScriptEditor v) noexcept {
		return Value{ ctx, std::forward<godot::ScriptEditor>(v) };
	}
};
template <>
struct js_traits<godot::ScriptEditor &> {
	/// @throws exception
	static godot::ScriptEditor &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ScriptEditor *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ScriptEditor &v) noexcept {
		return Value{ ctx, std::forward<godot::ScriptEditor>(v) };
	}
};
template <>
struct js_traits<godot::ScriptEditorBase> {
	/// @throws exception
	static godot::ScriptEditorBase unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ScriptEditorBase *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ScriptEditorBase v) noexcept {
		return Value{ ctx, std::forward<godot::ScriptEditorBase>(v) };
	}
};
template <>
struct js_traits<godot::ScriptEditorBase &> {
	/// @throws exception
	static godot::ScriptEditorBase &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ScriptEditorBase *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ScriptEditorBase &v) noexcept {
		return Value{ ctx, std::forward<godot::ScriptEditorBase>(v) };
	}
};
template <>
struct js_traits<godot::ScriptExtension> {
	/// @throws exception
	static godot::ScriptExtension unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ScriptExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ScriptExtension v) noexcept {
		return Value{ ctx, std::forward<godot::ScriptExtension>(v) };
	}
};
template <>
struct js_traits<godot::ScriptExtension &> {
	/// @throws exception
	static godot::ScriptExtension &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ScriptExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ScriptExtension &v) noexcept {
		return Value{ ctx, std::forward<godot::ScriptExtension>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ScriptExtension>> {
	/// @throws exception
	static godot::Ref<godot::ScriptExtension> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ScriptExtension>((godot::ScriptExtension *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ScriptExtension> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ScriptExtension>>(v) };
	}
};
template <>
struct js_traits<godot::ScriptLanguage> {
	/// @throws exception
	static godot::ScriptLanguage unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ScriptLanguage *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ScriptLanguage v) noexcept {
		return Value{ ctx, std::forward<godot::ScriptLanguage>(v) };
	}
};
template <>
struct js_traits<godot::ScriptLanguage &> {
	/// @throws exception
	static godot::ScriptLanguage &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ScriptLanguage *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ScriptLanguage &v) noexcept {
		return Value{ ctx, std::forward<godot::ScriptLanguage>(v) };
	}
};
template <>
struct js_traits<godot::ScriptLanguageExtension> {
	/// @throws exception
	static godot::ScriptLanguageExtension unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ScriptLanguageExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ScriptLanguageExtension v) noexcept {
		return Value{ ctx, std::forward<godot::ScriptLanguageExtension>(v) };
	}
};
template <>
struct js_traits<godot::ScriptLanguageExtension &> {
	/// @throws exception
	static godot::ScriptLanguageExtension &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ScriptLanguageExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ScriptLanguageExtension &v) noexcept {
		return Value{ ctx, std::forward<godot::ScriptLanguageExtension>(v) };
	}
};
template <>
struct js_traits<godot::ScrollBar> {
	/// @throws exception
	static godot::ScrollBar unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ScrollBar *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ScrollBar v) noexcept {
		return Value{ ctx, std::forward<godot::ScrollBar>(v) };
	}
};
template <>
struct js_traits<godot::ScrollBar &> {
	/// @throws exception
	static godot::ScrollBar &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ScrollBar *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ScrollBar &v) noexcept {
		return Value{ ctx, std::forward<godot::ScrollBar>(v) };
	}
};
template <>
struct js_traits<godot::ScrollContainer> {
	/// @throws exception
	static godot::ScrollContainer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ScrollContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ScrollContainer v) noexcept {
		return Value{ ctx, std::forward<godot::ScrollContainer>(v) };
	}
};
template <>
struct js_traits<godot::ScrollContainer &> {
	/// @throws exception
	static godot::ScrollContainer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ScrollContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ScrollContainer &v) noexcept {
		return Value{ ctx, std::forward<godot::ScrollContainer>(v) };
	}
};
template <>
struct js_traits<godot::SegmentShape2D> {
	/// @throws exception
	static godot::SegmentShape2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SegmentShape2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SegmentShape2D v) noexcept {
		return Value{ ctx, std::forward<godot::SegmentShape2D>(v) };
	}
};
template <>
struct js_traits<godot::SegmentShape2D &> {
	/// @throws exception
	static godot::SegmentShape2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SegmentShape2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SegmentShape2D &v) noexcept {
		return Value{ ctx, std::forward<godot::SegmentShape2D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::SegmentShape2D>> {
	/// @throws exception
	static godot::Ref<godot::SegmentShape2D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::SegmentShape2D>((godot::SegmentShape2D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::SegmentShape2D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::SegmentShape2D>>(v) };
	}
};
template <>
struct js_traits<godot::Semaphore> {
	/// @throws exception
	static godot::Semaphore unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Semaphore *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Semaphore v) noexcept {
		return Value{ ctx, std::forward<godot::Semaphore>(v) };
	}
};
template <>
struct js_traits<godot::Semaphore &> {
	/// @throws exception
	static godot::Semaphore &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Semaphore *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Semaphore &v) noexcept {
		return Value{ ctx, std::forward<godot::Semaphore>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Semaphore>> {
	/// @throws exception
	static godot::Ref<godot::Semaphore> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Semaphore>((godot::Semaphore *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Semaphore> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Semaphore>>(v) };
	}
};
template <>
struct js_traits<godot::SeparationRayShape2D> {
	/// @throws exception
	static godot::SeparationRayShape2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SeparationRayShape2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SeparationRayShape2D v) noexcept {
		return Value{ ctx, std::forward<godot::SeparationRayShape2D>(v) };
	}
};
template <>
struct js_traits<godot::SeparationRayShape2D &> {
	/// @throws exception
	static godot::SeparationRayShape2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SeparationRayShape2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SeparationRayShape2D &v) noexcept {
		return Value{ ctx, std::forward<godot::SeparationRayShape2D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::SeparationRayShape2D>> {
	/// @throws exception
	static godot::Ref<godot::SeparationRayShape2D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::SeparationRayShape2D>((godot::SeparationRayShape2D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::SeparationRayShape2D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::SeparationRayShape2D>>(v) };
	}
};
template <>
struct js_traits<godot::SeparationRayShape3D> {
	/// @throws exception
	static godot::SeparationRayShape3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SeparationRayShape3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SeparationRayShape3D v) noexcept {
		return Value{ ctx, std::forward<godot::SeparationRayShape3D>(v) };
	}
};
template <>
struct js_traits<godot::SeparationRayShape3D &> {
	/// @throws exception
	static godot::SeparationRayShape3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SeparationRayShape3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SeparationRayShape3D &v) noexcept {
		return Value{ ctx, std::forward<godot::SeparationRayShape3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::SeparationRayShape3D>> {
	/// @throws exception
	static godot::Ref<godot::SeparationRayShape3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::SeparationRayShape3D>((godot::SeparationRayShape3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::SeparationRayShape3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::SeparationRayShape3D>>(v) };
	}
};
template <>
struct js_traits<godot::Separator> {
	/// @throws exception
	static godot::Separator unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Separator *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Separator v) noexcept {
		return Value{ ctx, std::forward<godot::Separator>(v) };
	}
};
template <>
struct js_traits<godot::Separator &> {
	/// @throws exception
	static godot::Separator &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Separator *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Separator &v) noexcept {
		return Value{ ctx, std::forward<godot::Separator>(v) };
	}
};
template <>
struct js_traits<godot::Shader> {
	/// @throws exception
	static godot::Shader unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Shader *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Shader v) noexcept {
		return Value{ ctx, std::forward<godot::Shader>(v) };
	}
};
template <>
struct js_traits<godot::Shader &> {
	/// @throws exception
	static godot::Shader &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Shader *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Shader &v) noexcept {
		return Value{ ctx, std::forward<godot::Shader>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Shader>> {
	/// @throws exception
	static godot::Ref<godot::Shader> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Shader>((godot::Shader *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Shader> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Shader>>(v) };
	}
};
template <>
struct js_traits<godot::ShaderGlobalsOverride> {
	/// @throws exception
	static godot::ShaderGlobalsOverride unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ShaderGlobalsOverride *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ShaderGlobalsOverride v) noexcept {
		return Value{ ctx, std::forward<godot::ShaderGlobalsOverride>(v) };
	}
};
template <>
struct js_traits<godot::ShaderGlobalsOverride &> {
	/// @throws exception
	static godot::ShaderGlobalsOverride &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ShaderGlobalsOverride *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ShaderGlobalsOverride &v) noexcept {
		return Value{ ctx, std::forward<godot::ShaderGlobalsOverride>(v) };
	}
};
template <>
struct js_traits<godot::ShaderInclude> {
	/// @throws exception
	static godot::ShaderInclude unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ShaderInclude *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ShaderInclude v) noexcept {
		return Value{ ctx, std::forward<godot::ShaderInclude>(v) };
	}
};
template <>
struct js_traits<godot::ShaderInclude &> {
	/// @throws exception
	static godot::ShaderInclude &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ShaderInclude *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ShaderInclude &v) noexcept {
		return Value{ ctx, std::forward<godot::ShaderInclude>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ShaderInclude>> {
	/// @throws exception
	static godot::Ref<godot::ShaderInclude> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ShaderInclude>((godot::ShaderInclude *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ShaderInclude> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ShaderInclude>>(v) };
	}
};
template <>
struct js_traits<godot::ShaderMaterial> {
	/// @throws exception
	static godot::ShaderMaterial unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ShaderMaterial *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ShaderMaterial v) noexcept {
		return Value{ ctx, std::forward<godot::ShaderMaterial>(v) };
	}
};
template <>
struct js_traits<godot::ShaderMaterial &> {
	/// @throws exception
	static godot::ShaderMaterial &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ShaderMaterial *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ShaderMaterial &v) noexcept {
		return Value{ ctx, std::forward<godot::ShaderMaterial>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ShaderMaterial>> {
	/// @throws exception
	static godot::Ref<godot::ShaderMaterial> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ShaderMaterial>((godot::ShaderMaterial *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ShaderMaterial> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ShaderMaterial>>(v) };
	}
};
template <>
struct js_traits<godot::Shape2D> {
	/// @throws exception
	static godot::Shape2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Shape2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Shape2D v) noexcept {
		return Value{ ctx, std::forward<godot::Shape2D>(v) };
	}
};
template <>
struct js_traits<godot::Shape2D &> {
	/// @throws exception
	static godot::Shape2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Shape2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Shape2D &v) noexcept {
		return Value{ ctx, std::forward<godot::Shape2D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Shape2D>> {
	/// @throws exception
	static godot::Ref<godot::Shape2D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Shape2D>((godot::Shape2D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Shape2D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Shape2D>>(v) };
	}
};
template <>
struct js_traits<godot::Shape3D> {
	/// @throws exception
	static godot::Shape3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Shape3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Shape3D v) noexcept {
		return Value{ ctx, std::forward<godot::Shape3D>(v) };
	}
};
template <>
struct js_traits<godot::Shape3D &> {
	/// @throws exception
	static godot::Shape3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Shape3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Shape3D &v) noexcept {
		return Value{ ctx, std::forward<godot::Shape3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Shape3D>> {
	/// @throws exception
	static godot::Ref<godot::Shape3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Shape3D>((godot::Shape3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Shape3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Shape3D>>(v) };
	}
};
template <>
struct js_traits<godot::ShapeCast2D> {
	/// @throws exception
	static godot::ShapeCast2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ShapeCast2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ShapeCast2D v) noexcept {
		return Value{ ctx, std::forward<godot::ShapeCast2D>(v) };
	}
};
template <>
struct js_traits<godot::ShapeCast2D &> {
	/// @throws exception
	static godot::ShapeCast2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ShapeCast2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ShapeCast2D &v) noexcept {
		return Value{ ctx, std::forward<godot::ShapeCast2D>(v) };
	}
};
template <>
struct js_traits<godot::ShapeCast3D> {
	/// @throws exception
	static godot::ShapeCast3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ShapeCast3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ShapeCast3D v) noexcept {
		return Value{ ctx, std::forward<godot::ShapeCast3D>(v) };
	}
};
template <>
struct js_traits<godot::ShapeCast3D &> {
	/// @throws exception
	static godot::ShapeCast3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ShapeCast3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ShapeCast3D &v) noexcept {
		return Value{ ctx, std::forward<godot::ShapeCast3D>(v) };
	}
};
template <>
struct js_traits<godot::Shortcut> {
	/// @throws exception
	static godot::Shortcut unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Shortcut *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Shortcut v) noexcept {
		return Value{ ctx, std::forward<godot::Shortcut>(v) };
	}
};
template <>
struct js_traits<godot::Shortcut &> {
	/// @throws exception
	static godot::Shortcut &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Shortcut *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Shortcut &v) noexcept {
		return Value{ ctx, std::forward<godot::Shortcut>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Shortcut>> {
	/// @throws exception
	static godot::Ref<godot::Shortcut> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Shortcut>((godot::Shortcut *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Shortcut> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Shortcut>>(v) };
	}
};
template <>
struct js_traits<godot::Skeleton2D> {
	/// @throws exception
	static godot::Skeleton2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Skeleton2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Skeleton2D v) noexcept {
		return Value{ ctx, std::forward<godot::Skeleton2D>(v) };
	}
};
template <>
struct js_traits<godot::Skeleton2D &> {
	/// @throws exception
	static godot::Skeleton2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Skeleton2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Skeleton2D &v) noexcept {
		return Value{ ctx, std::forward<godot::Skeleton2D>(v) };
	}
};
template <>
struct js_traits<godot::Skeleton3D> {
	/// @throws exception
	static godot::Skeleton3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Skeleton3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Skeleton3D v) noexcept {
		return Value{ ctx, std::forward<godot::Skeleton3D>(v) };
	}
};
template <>
struct js_traits<godot::Skeleton3D &> {
	/// @throws exception
	static godot::Skeleton3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Skeleton3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Skeleton3D &v) noexcept {
		return Value{ ctx, std::forward<godot::Skeleton3D>(v) };
	}
};
template <>
struct js_traits<godot::SkeletonIK3D> {
	/// @throws exception
	static godot::SkeletonIK3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SkeletonIK3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SkeletonIK3D v) noexcept {
		return Value{ ctx, std::forward<godot::SkeletonIK3D>(v) };
	}
};
template <>
struct js_traits<godot::SkeletonIK3D &> {
	/// @throws exception
	static godot::SkeletonIK3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SkeletonIK3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SkeletonIK3D &v) noexcept {
		return Value{ ctx, std::forward<godot::SkeletonIK3D>(v) };
	}
};
template <>
struct js_traits<godot::SkeletonModification2D> {
	/// @throws exception
	static godot::SkeletonModification2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SkeletonModification2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SkeletonModification2D v) noexcept {
		return Value{ ctx, std::forward<godot::SkeletonModification2D>(v) };
	}
};
template <>
struct js_traits<godot::SkeletonModification2D &> {
	/// @throws exception
	static godot::SkeletonModification2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SkeletonModification2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SkeletonModification2D &v) noexcept {
		return Value{ ctx, std::forward<godot::SkeletonModification2D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::SkeletonModification2D>> {
	/// @throws exception
	static godot::Ref<godot::SkeletonModification2D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::SkeletonModification2D>((godot::SkeletonModification2D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::SkeletonModification2D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::SkeletonModification2D>>(v) };
	}
};
template <>
struct js_traits<godot::SkeletonModification2DCCDIK> {
	/// @throws exception
	static godot::SkeletonModification2DCCDIK unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SkeletonModification2DCCDIK *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SkeletonModification2DCCDIK v) noexcept {
		return Value{ ctx, std::forward<godot::SkeletonModification2DCCDIK>(v) };
	}
};
template <>
struct js_traits<godot::SkeletonModification2DCCDIK &> {
	/// @throws exception
	static godot::SkeletonModification2DCCDIK &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SkeletonModification2DCCDIK *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SkeletonModification2DCCDIK &v) noexcept {
		return Value{ ctx, std::forward<godot::SkeletonModification2DCCDIK>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::SkeletonModification2DCCDIK>> {
	/// @throws exception
	static godot::Ref<godot::SkeletonModification2DCCDIK> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::SkeletonModification2DCCDIK>((godot::SkeletonModification2DCCDIK *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::SkeletonModification2DCCDIK> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::SkeletonModification2DCCDIK>>(v) };
	}
};
template <>
struct js_traits<godot::SkeletonModification2DFABRIK> {
	/// @throws exception
	static godot::SkeletonModification2DFABRIK unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SkeletonModification2DFABRIK *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SkeletonModification2DFABRIK v) noexcept {
		return Value{ ctx, std::forward<godot::SkeletonModification2DFABRIK>(v) };
	}
};
template <>
struct js_traits<godot::SkeletonModification2DFABRIK &> {
	/// @throws exception
	static godot::SkeletonModification2DFABRIK &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SkeletonModification2DFABRIK *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SkeletonModification2DFABRIK &v) noexcept {
		return Value{ ctx, std::forward<godot::SkeletonModification2DFABRIK>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::SkeletonModification2DFABRIK>> {
	/// @throws exception
	static godot::Ref<godot::SkeletonModification2DFABRIK> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::SkeletonModification2DFABRIK>((godot::SkeletonModification2DFABRIK *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::SkeletonModification2DFABRIK> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::SkeletonModification2DFABRIK>>(v) };
	}
};
template <>
struct js_traits<godot::SkeletonModification2DJiggle> {
	/// @throws exception
	static godot::SkeletonModification2DJiggle unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SkeletonModification2DJiggle *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SkeletonModification2DJiggle v) noexcept {
		return Value{ ctx, std::forward<godot::SkeletonModification2DJiggle>(v) };
	}
};
template <>
struct js_traits<godot::SkeletonModification2DJiggle &> {
	/// @throws exception
	static godot::SkeletonModification2DJiggle &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SkeletonModification2DJiggle *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SkeletonModification2DJiggle &v) noexcept {
		return Value{ ctx, std::forward<godot::SkeletonModification2DJiggle>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::SkeletonModification2DJiggle>> {
	/// @throws exception
	static godot::Ref<godot::SkeletonModification2DJiggle> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::SkeletonModification2DJiggle>((godot::SkeletonModification2DJiggle *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::SkeletonModification2DJiggle> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::SkeletonModification2DJiggle>>(v) };
	}
};
template <>
struct js_traits<godot::SkeletonModification2DLookAt> {
	/// @throws exception
	static godot::SkeletonModification2DLookAt unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SkeletonModification2DLookAt *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SkeletonModification2DLookAt v) noexcept {
		return Value{ ctx, std::forward<godot::SkeletonModification2DLookAt>(v) };
	}
};
template <>
struct js_traits<godot::SkeletonModification2DLookAt &> {
	/// @throws exception
	static godot::SkeletonModification2DLookAt &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SkeletonModification2DLookAt *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SkeletonModification2DLookAt &v) noexcept {
		return Value{ ctx, std::forward<godot::SkeletonModification2DLookAt>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::SkeletonModification2DLookAt>> {
	/// @throws exception
	static godot::Ref<godot::SkeletonModification2DLookAt> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::SkeletonModification2DLookAt>((godot::SkeletonModification2DLookAt *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::SkeletonModification2DLookAt> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::SkeletonModification2DLookAt>>(v) };
	}
};
template <>
struct js_traits<godot::SkeletonModification2DPhysicalBones> {
	/// @throws exception
	static godot::SkeletonModification2DPhysicalBones unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SkeletonModification2DPhysicalBones *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SkeletonModification2DPhysicalBones v) noexcept {
		return Value{ ctx, std::forward<godot::SkeletonModification2DPhysicalBones>(v) };
	}
};
template <>
struct js_traits<godot::SkeletonModification2DPhysicalBones &> {
	/// @throws exception
	static godot::SkeletonModification2DPhysicalBones &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SkeletonModification2DPhysicalBones *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SkeletonModification2DPhysicalBones &v) noexcept {
		return Value{ ctx, std::forward<godot::SkeletonModification2DPhysicalBones>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::SkeletonModification2DPhysicalBones>> {
	/// @throws exception
	static godot::Ref<godot::SkeletonModification2DPhysicalBones> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::SkeletonModification2DPhysicalBones>((godot::SkeletonModification2DPhysicalBones *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::SkeletonModification2DPhysicalBones> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::SkeletonModification2DPhysicalBones>>(v) };
	}
};
template <>
struct js_traits<godot::SkeletonModification2DStackHolder> {
	/// @throws exception
	static godot::SkeletonModification2DStackHolder unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SkeletonModification2DStackHolder *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SkeletonModification2DStackHolder v) noexcept {
		return Value{ ctx, std::forward<godot::SkeletonModification2DStackHolder>(v) };
	}
};
template <>
struct js_traits<godot::SkeletonModification2DStackHolder &> {
	/// @throws exception
	static godot::SkeletonModification2DStackHolder &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SkeletonModification2DStackHolder *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SkeletonModification2DStackHolder &v) noexcept {
		return Value{ ctx, std::forward<godot::SkeletonModification2DStackHolder>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::SkeletonModification2DStackHolder>> {
	/// @throws exception
	static godot::Ref<godot::SkeletonModification2DStackHolder> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::SkeletonModification2DStackHolder>((godot::SkeletonModification2DStackHolder *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::SkeletonModification2DStackHolder> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::SkeletonModification2DStackHolder>>(v) };
	}
};
template <>
struct js_traits<godot::SkeletonModification2DTwoBoneIK> {
	/// @throws exception
	static godot::SkeletonModification2DTwoBoneIK unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SkeletonModification2DTwoBoneIK *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SkeletonModification2DTwoBoneIK v) noexcept {
		return Value{ ctx, std::forward<godot::SkeletonModification2DTwoBoneIK>(v) };
	}
};
template <>
struct js_traits<godot::SkeletonModification2DTwoBoneIK &> {
	/// @throws exception
	static godot::SkeletonModification2DTwoBoneIK &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SkeletonModification2DTwoBoneIK *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SkeletonModification2DTwoBoneIK &v) noexcept {
		return Value{ ctx, std::forward<godot::SkeletonModification2DTwoBoneIK>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::SkeletonModification2DTwoBoneIK>> {
	/// @throws exception
	static godot::Ref<godot::SkeletonModification2DTwoBoneIK> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::SkeletonModification2DTwoBoneIK>((godot::SkeletonModification2DTwoBoneIK *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::SkeletonModification2DTwoBoneIK> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::SkeletonModification2DTwoBoneIK>>(v) };
	}
};
template <>
struct js_traits<godot::SkeletonModificationStack2D> {
	/// @throws exception
	static godot::SkeletonModificationStack2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SkeletonModificationStack2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SkeletonModificationStack2D v) noexcept {
		return Value{ ctx, std::forward<godot::SkeletonModificationStack2D>(v) };
	}
};
template <>
struct js_traits<godot::SkeletonModificationStack2D &> {
	/// @throws exception
	static godot::SkeletonModificationStack2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SkeletonModificationStack2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SkeletonModificationStack2D &v) noexcept {
		return Value{ ctx, std::forward<godot::SkeletonModificationStack2D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::SkeletonModificationStack2D>> {
	/// @throws exception
	static godot::Ref<godot::SkeletonModificationStack2D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::SkeletonModificationStack2D>((godot::SkeletonModificationStack2D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::SkeletonModificationStack2D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::SkeletonModificationStack2D>>(v) };
	}
};
template <>
struct js_traits<godot::SkeletonProfile> {
	/// @throws exception
	static godot::SkeletonProfile unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SkeletonProfile *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SkeletonProfile v) noexcept {
		return Value{ ctx, std::forward<godot::SkeletonProfile>(v) };
	}
};
template <>
struct js_traits<godot::SkeletonProfile &> {
	/// @throws exception
	static godot::SkeletonProfile &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SkeletonProfile *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SkeletonProfile &v) noexcept {
		return Value{ ctx, std::forward<godot::SkeletonProfile>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::SkeletonProfile>> {
	/// @throws exception
	static godot::Ref<godot::SkeletonProfile> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::SkeletonProfile>((godot::SkeletonProfile *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::SkeletonProfile> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::SkeletonProfile>>(v) };
	}
};
template <>
struct js_traits<godot::SkeletonProfileHumanoid> {
	/// @throws exception
	static godot::SkeletonProfileHumanoid unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SkeletonProfileHumanoid *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SkeletonProfileHumanoid v) noexcept {
		return Value{ ctx, std::forward<godot::SkeletonProfileHumanoid>(v) };
	}
};
template <>
struct js_traits<godot::SkeletonProfileHumanoid &> {
	/// @throws exception
	static godot::SkeletonProfileHumanoid &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SkeletonProfileHumanoid *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SkeletonProfileHumanoid &v) noexcept {
		return Value{ ctx, std::forward<godot::SkeletonProfileHumanoid>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::SkeletonProfileHumanoid>> {
	/// @throws exception
	static godot::Ref<godot::SkeletonProfileHumanoid> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::SkeletonProfileHumanoid>((godot::SkeletonProfileHumanoid *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::SkeletonProfileHumanoid> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::SkeletonProfileHumanoid>>(v) };
	}
};
template <>
struct js_traits<godot::Skin> {
	/// @throws exception
	static godot::Skin unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Skin *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Skin v) noexcept {
		return Value{ ctx, std::forward<godot::Skin>(v) };
	}
};
template <>
struct js_traits<godot::Skin &> {
	/// @throws exception
	static godot::Skin &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Skin *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Skin &v) noexcept {
		return Value{ ctx, std::forward<godot::Skin>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Skin>> {
	/// @throws exception
	static godot::Ref<godot::Skin> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Skin>((godot::Skin *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Skin> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Skin>>(v) };
	}
};
template <>
struct js_traits<godot::SkinReference> {
	/// @throws exception
	static godot::SkinReference unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SkinReference *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SkinReference v) noexcept {
		return Value{ ctx, std::forward<godot::SkinReference>(v) };
	}
};
template <>
struct js_traits<godot::SkinReference &> {
	/// @throws exception
	static godot::SkinReference &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SkinReference *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SkinReference &v) noexcept {
		return Value{ ctx, std::forward<godot::SkinReference>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::SkinReference>> {
	/// @throws exception
	static godot::Ref<godot::SkinReference> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::SkinReference>((godot::SkinReference *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::SkinReference> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::SkinReference>>(v) };
	}
};
template <>
struct js_traits<godot::Sky> {
	/// @throws exception
	static godot::Sky unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Sky *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Sky v) noexcept {
		return Value{ ctx, std::forward<godot::Sky>(v) };
	}
};
template <>
struct js_traits<godot::Sky &> {
	/// @throws exception
	static godot::Sky &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Sky *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Sky &v) noexcept {
		return Value{ ctx, std::forward<godot::Sky>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Sky>> {
	/// @throws exception
	static godot::Ref<godot::Sky> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Sky>((godot::Sky *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Sky> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Sky>>(v) };
	}
};
template <>
struct js_traits<godot::Slider> {
	/// @throws exception
	static godot::Slider unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Slider *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Slider v) noexcept {
		return Value{ ctx, std::forward<godot::Slider>(v) };
	}
};
template <>
struct js_traits<godot::Slider &> {
	/// @throws exception
	static godot::Slider &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Slider *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Slider &v) noexcept {
		return Value{ ctx, std::forward<godot::Slider>(v) };
	}
};
template <>
struct js_traits<godot::SliderJoint3D> {
	/// @throws exception
	static godot::SliderJoint3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SliderJoint3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SliderJoint3D v) noexcept {
		return Value{ ctx, std::forward<godot::SliderJoint3D>(v) };
	}
};
template <>
struct js_traits<godot::SliderJoint3D &> {
	/// @throws exception
	static godot::SliderJoint3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SliderJoint3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SliderJoint3D &v) noexcept {
		return Value{ ctx, std::forward<godot::SliderJoint3D>(v) };
	}
};
template <>
struct js_traits<godot::SoftBody3D> {
	/// @throws exception
	static godot::SoftBody3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SoftBody3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SoftBody3D v) noexcept {
		return Value{ ctx, std::forward<godot::SoftBody3D>(v) };
	}
};
template <>
struct js_traits<godot::SoftBody3D &> {
	/// @throws exception
	static godot::SoftBody3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SoftBody3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SoftBody3D &v) noexcept {
		return Value{ ctx, std::forward<godot::SoftBody3D>(v) };
	}
};
template <>
struct js_traits<godot::SphereMesh> {
	/// @throws exception
	static godot::SphereMesh unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SphereMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SphereMesh v) noexcept {
		return Value{ ctx, std::forward<godot::SphereMesh>(v) };
	}
};
template <>
struct js_traits<godot::SphereMesh &> {
	/// @throws exception
	static godot::SphereMesh &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SphereMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SphereMesh &v) noexcept {
		return Value{ ctx, std::forward<godot::SphereMesh>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::SphereMesh>> {
	/// @throws exception
	static godot::Ref<godot::SphereMesh> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::SphereMesh>((godot::SphereMesh *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::SphereMesh> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::SphereMesh>>(v) };
	}
};
template <>
struct js_traits<godot::SphereOccluder3D> {
	/// @throws exception
	static godot::SphereOccluder3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SphereOccluder3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SphereOccluder3D v) noexcept {
		return Value{ ctx, std::forward<godot::SphereOccluder3D>(v) };
	}
};
template <>
struct js_traits<godot::SphereOccluder3D &> {
	/// @throws exception
	static godot::SphereOccluder3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SphereOccluder3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SphereOccluder3D &v) noexcept {
		return Value{ ctx, std::forward<godot::SphereOccluder3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::SphereOccluder3D>> {
	/// @throws exception
	static godot::Ref<godot::SphereOccluder3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::SphereOccluder3D>((godot::SphereOccluder3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::SphereOccluder3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::SphereOccluder3D>>(v) };
	}
};
template <>
struct js_traits<godot::SphereShape3D> {
	/// @throws exception
	static godot::SphereShape3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SphereShape3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SphereShape3D v) noexcept {
		return Value{ ctx, std::forward<godot::SphereShape3D>(v) };
	}
};
template <>
struct js_traits<godot::SphereShape3D &> {
	/// @throws exception
	static godot::SphereShape3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SphereShape3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SphereShape3D &v) noexcept {
		return Value{ ctx, std::forward<godot::SphereShape3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::SphereShape3D>> {
	/// @throws exception
	static godot::Ref<godot::SphereShape3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::SphereShape3D>((godot::SphereShape3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::SphereShape3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::SphereShape3D>>(v) };
	}
};
template <>
struct js_traits<godot::SpinBox> {
	/// @throws exception
	static godot::SpinBox unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SpinBox *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SpinBox v) noexcept {
		return Value{ ctx, std::forward<godot::SpinBox>(v) };
	}
};
template <>
struct js_traits<godot::SpinBox &> {
	/// @throws exception
	static godot::SpinBox &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SpinBox *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SpinBox &v) noexcept {
		return Value{ ctx, std::forward<godot::SpinBox>(v) };
	}
};
template <>
struct js_traits<godot::SplitContainer> {
	/// @throws exception
	static godot::SplitContainer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SplitContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SplitContainer v) noexcept {
		return Value{ ctx, std::forward<godot::SplitContainer>(v) };
	}
};
template <>
struct js_traits<godot::SplitContainer &> {
	/// @throws exception
	static godot::SplitContainer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SplitContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SplitContainer &v) noexcept {
		return Value{ ctx, std::forward<godot::SplitContainer>(v) };
	}
};
template <>
struct js_traits<godot::SpotLight3D> {
	/// @throws exception
	static godot::SpotLight3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SpotLight3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SpotLight3D v) noexcept {
		return Value{ ctx, std::forward<godot::SpotLight3D>(v) };
	}
};
template <>
struct js_traits<godot::SpotLight3D &> {
	/// @throws exception
	static godot::SpotLight3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SpotLight3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SpotLight3D &v) noexcept {
		return Value{ ctx, std::forward<godot::SpotLight3D>(v) };
	}
};
template <>
struct js_traits<godot::SpringArm3D> {
	/// @throws exception
	static godot::SpringArm3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SpringArm3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SpringArm3D v) noexcept {
		return Value{ ctx, std::forward<godot::SpringArm3D>(v) };
	}
};
template <>
struct js_traits<godot::SpringArm3D &> {
	/// @throws exception
	static godot::SpringArm3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SpringArm3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SpringArm3D &v) noexcept {
		return Value{ ctx, std::forward<godot::SpringArm3D>(v) };
	}
};
template <>
struct js_traits<godot::Sprite2D> {
	/// @throws exception
	static godot::Sprite2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Sprite2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Sprite2D v) noexcept {
		return Value{ ctx, std::forward<godot::Sprite2D>(v) };
	}
};
template <>
struct js_traits<godot::Sprite2D &> {
	/// @throws exception
	static godot::Sprite2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Sprite2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Sprite2D &v) noexcept {
		return Value{ ctx, std::forward<godot::Sprite2D>(v) };
	}
};
template <>
struct js_traits<godot::Sprite3D> {
	/// @throws exception
	static godot::Sprite3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Sprite3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Sprite3D v) noexcept {
		return Value{ ctx, std::forward<godot::Sprite3D>(v) };
	}
};
template <>
struct js_traits<godot::Sprite3D &> {
	/// @throws exception
	static godot::Sprite3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Sprite3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Sprite3D &v) noexcept {
		return Value{ ctx, std::forward<godot::Sprite3D>(v) };
	}
};
template <>
struct js_traits<godot::SpriteBase3D> {
	/// @throws exception
	static godot::SpriteBase3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SpriteBase3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SpriteBase3D v) noexcept {
		return Value{ ctx, std::forward<godot::SpriteBase3D>(v) };
	}
};
template <>
struct js_traits<godot::SpriteBase3D &> {
	/// @throws exception
	static godot::SpriteBase3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SpriteBase3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SpriteBase3D &v) noexcept {
		return Value{ ctx, std::forward<godot::SpriteBase3D>(v) };
	}
};
template <>
struct js_traits<godot::SpriteFrames> {
	/// @throws exception
	static godot::SpriteFrames unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SpriteFrames *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SpriteFrames v) noexcept {
		return Value{ ctx, std::forward<godot::SpriteFrames>(v) };
	}
};
template <>
struct js_traits<godot::SpriteFrames &> {
	/// @throws exception
	static godot::SpriteFrames &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SpriteFrames *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SpriteFrames &v) noexcept {
		return Value{ ctx, std::forward<godot::SpriteFrames>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::SpriteFrames>> {
	/// @throws exception
	static godot::Ref<godot::SpriteFrames> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::SpriteFrames>((godot::SpriteFrames *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::SpriteFrames> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::SpriteFrames>>(v) };
	}
};
template <>
struct js_traits<godot::StandardMaterial3D> {
	/// @throws exception
	static godot::StandardMaterial3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::StandardMaterial3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::StandardMaterial3D v) noexcept {
		return Value{ ctx, std::forward<godot::StandardMaterial3D>(v) };
	}
};
template <>
struct js_traits<godot::StandardMaterial3D &> {
	/// @throws exception
	static godot::StandardMaterial3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::StandardMaterial3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::StandardMaterial3D &v) noexcept {
		return Value{ ctx, std::forward<godot::StandardMaterial3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::StandardMaterial3D>> {
	/// @throws exception
	static godot::Ref<godot::StandardMaterial3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::StandardMaterial3D>((godot::StandardMaterial3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::StandardMaterial3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::StandardMaterial3D>>(v) };
	}
};
template <>
struct js_traits<godot::StaticBody2D> {
	/// @throws exception
	static godot::StaticBody2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::StaticBody2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::StaticBody2D v) noexcept {
		return Value{ ctx, std::forward<godot::StaticBody2D>(v) };
	}
};
template <>
struct js_traits<godot::StaticBody2D &> {
	/// @throws exception
	static godot::StaticBody2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::StaticBody2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::StaticBody2D &v) noexcept {
		return Value{ ctx, std::forward<godot::StaticBody2D>(v) };
	}
};
template <>
struct js_traits<godot::StaticBody3D> {
	/// @throws exception
	static godot::StaticBody3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::StaticBody3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::StaticBody3D v) noexcept {
		return Value{ ctx, std::forward<godot::StaticBody3D>(v) };
	}
};
template <>
struct js_traits<godot::StaticBody3D &> {
	/// @throws exception
	static godot::StaticBody3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::StaticBody3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::StaticBody3D &v) noexcept {
		return Value{ ctx, std::forward<godot::StaticBody3D>(v) };
	}
};
template <>
struct js_traits<godot::StreamPeer> {
	/// @throws exception
	static godot::StreamPeer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::StreamPeer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::StreamPeer v) noexcept {
		return Value{ ctx, std::forward<godot::StreamPeer>(v) };
	}
};
template <>
struct js_traits<godot::StreamPeer &> {
	/// @throws exception
	static godot::StreamPeer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::StreamPeer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::StreamPeer &v) noexcept {
		return Value{ ctx, std::forward<godot::StreamPeer>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::StreamPeer>> {
	/// @throws exception
	static godot::Ref<godot::StreamPeer> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::StreamPeer>((godot::StreamPeer *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::StreamPeer> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::StreamPeer>>(v) };
	}
};
template <>
struct js_traits<godot::StreamPeerBuffer> {
	/// @throws exception
	static godot::StreamPeerBuffer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::StreamPeerBuffer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::StreamPeerBuffer v) noexcept {
		return Value{ ctx, std::forward<godot::StreamPeerBuffer>(v) };
	}
};
template <>
struct js_traits<godot::StreamPeerBuffer &> {
	/// @throws exception
	static godot::StreamPeerBuffer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::StreamPeerBuffer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::StreamPeerBuffer &v) noexcept {
		return Value{ ctx, std::forward<godot::StreamPeerBuffer>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::StreamPeerBuffer>> {
	/// @throws exception
	static godot::Ref<godot::StreamPeerBuffer> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::StreamPeerBuffer>((godot::StreamPeerBuffer *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::StreamPeerBuffer> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::StreamPeerBuffer>>(v) };
	}
};
template <>
struct js_traits<godot::StreamPeerExtension> {
	/// @throws exception
	static godot::StreamPeerExtension unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::StreamPeerExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::StreamPeerExtension v) noexcept {
		return Value{ ctx, std::forward<godot::StreamPeerExtension>(v) };
	}
};
template <>
struct js_traits<godot::StreamPeerExtension &> {
	/// @throws exception
	static godot::StreamPeerExtension &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::StreamPeerExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::StreamPeerExtension &v) noexcept {
		return Value{ ctx, std::forward<godot::StreamPeerExtension>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::StreamPeerExtension>> {
	/// @throws exception
	static godot::Ref<godot::StreamPeerExtension> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::StreamPeerExtension>((godot::StreamPeerExtension *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::StreamPeerExtension> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::StreamPeerExtension>>(v) };
	}
};
template <>
struct js_traits<godot::StreamPeerGZIP> {
	/// @throws exception
	static godot::StreamPeerGZIP unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::StreamPeerGZIP *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::StreamPeerGZIP v) noexcept {
		return Value{ ctx, std::forward<godot::StreamPeerGZIP>(v) };
	}
};
template <>
struct js_traits<godot::StreamPeerGZIP &> {
	/// @throws exception
	static godot::StreamPeerGZIP &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::StreamPeerGZIP *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::StreamPeerGZIP &v) noexcept {
		return Value{ ctx, std::forward<godot::StreamPeerGZIP>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::StreamPeerGZIP>> {
	/// @throws exception
	static godot::Ref<godot::StreamPeerGZIP> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::StreamPeerGZIP>((godot::StreamPeerGZIP *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::StreamPeerGZIP> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::StreamPeerGZIP>>(v) };
	}
};
template <>
struct js_traits<godot::StreamPeerTCP> {
	/// @throws exception
	static godot::StreamPeerTCP unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::StreamPeerTCP *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::StreamPeerTCP v) noexcept {
		return Value{ ctx, std::forward<godot::StreamPeerTCP>(v) };
	}
};
template <>
struct js_traits<godot::StreamPeerTCP &> {
	/// @throws exception
	static godot::StreamPeerTCP &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::StreamPeerTCP *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::StreamPeerTCP &v) noexcept {
		return Value{ ctx, std::forward<godot::StreamPeerTCP>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::StreamPeerTCP>> {
	/// @throws exception
	static godot::Ref<godot::StreamPeerTCP> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::StreamPeerTCP>((godot::StreamPeerTCP *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::StreamPeerTCP> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::StreamPeerTCP>>(v) };
	}
};
template <>
struct js_traits<godot::StreamPeerTLS> {
	/// @throws exception
	static godot::StreamPeerTLS unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::StreamPeerTLS *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::StreamPeerTLS v) noexcept {
		return Value{ ctx, std::forward<godot::StreamPeerTLS>(v) };
	}
};
template <>
struct js_traits<godot::StreamPeerTLS &> {
	/// @throws exception
	static godot::StreamPeerTLS &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::StreamPeerTLS *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::StreamPeerTLS &v) noexcept {
		return Value{ ctx, std::forward<godot::StreamPeerTLS>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::StreamPeerTLS>> {
	/// @throws exception
	static godot::Ref<godot::StreamPeerTLS> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::StreamPeerTLS>((godot::StreamPeerTLS *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::StreamPeerTLS> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::StreamPeerTLS>>(v) };
	}
};
template <>
struct js_traits<godot::StyleBox> {
	/// @throws exception
	static godot::StyleBox unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::StyleBox *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::StyleBox v) noexcept {
		return Value{ ctx, std::forward<godot::StyleBox>(v) };
	}
};
template <>
struct js_traits<godot::StyleBox &> {
	/// @throws exception
	static godot::StyleBox &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::StyleBox *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::StyleBox &v) noexcept {
		return Value{ ctx, std::forward<godot::StyleBox>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::StyleBox>> {
	/// @throws exception
	static godot::Ref<godot::StyleBox> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::StyleBox>((godot::StyleBox *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::StyleBox> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::StyleBox>>(v) };
	}
};
template <>
struct js_traits<godot::StyleBoxEmpty> {
	/// @throws exception
	static godot::StyleBoxEmpty unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::StyleBoxEmpty *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::StyleBoxEmpty v) noexcept {
		return Value{ ctx, std::forward<godot::StyleBoxEmpty>(v) };
	}
};
template <>
struct js_traits<godot::StyleBoxEmpty &> {
	/// @throws exception
	static godot::StyleBoxEmpty &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::StyleBoxEmpty *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::StyleBoxEmpty &v) noexcept {
		return Value{ ctx, std::forward<godot::StyleBoxEmpty>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::StyleBoxEmpty>> {
	/// @throws exception
	static godot::Ref<godot::StyleBoxEmpty> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::StyleBoxEmpty>((godot::StyleBoxEmpty *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::StyleBoxEmpty> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::StyleBoxEmpty>>(v) };
	}
};
template <>
struct js_traits<godot::StyleBoxFlat> {
	/// @throws exception
	static godot::StyleBoxFlat unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::StyleBoxFlat *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::StyleBoxFlat v) noexcept {
		return Value{ ctx, std::forward<godot::StyleBoxFlat>(v) };
	}
};
template <>
struct js_traits<godot::StyleBoxFlat &> {
	/// @throws exception
	static godot::StyleBoxFlat &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::StyleBoxFlat *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::StyleBoxFlat &v) noexcept {
		return Value{ ctx, std::forward<godot::StyleBoxFlat>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::StyleBoxFlat>> {
	/// @throws exception
	static godot::Ref<godot::StyleBoxFlat> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::StyleBoxFlat>((godot::StyleBoxFlat *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::StyleBoxFlat> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::StyleBoxFlat>>(v) };
	}
};
template <>
struct js_traits<godot::StyleBoxLine> {
	/// @throws exception
	static godot::StyleBoxLine unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::StyleBoxLine *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::StyleBoxLine v) noexcept {
		return Value{ ctx, std::forward<godot::StyleBoxLine>(v) };
	}
};
template <>
struct js_traits<godot::StyleBoxLine &> {
	/// @throws exception
	static godot::StyleBoxLine &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::StyleBoxLine *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::StyleBoxLine &v) noexcept {
		return Value{ ctx, std::forward<godot::StyleBoxLine>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::StyleBoxLine>> {
	/// @throws exception
	static godot::Ref<godot::StyleBoxLine> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::StyleBoxLine>((godot::StyleBoxLine *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::StyleBoxLine> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::StyleBoxLine>>(v) };
	}
};
template <>
struct js_traits<godot::StyleBoxTexture> {
	/// @throws exception
	static godot::StyleBoxTexture unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::StyleBoxTexture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::StyleBoxTexture v) noexcept {
		return Value{ ctx, std::forward<godot::StyleBoxTexture>(v) };
	}
};
template <>
struct js_traits<godot::StyleBoxTexture &> {
	/// @throws exception
	static godot::StyleBoxTexture &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::StyleBoxTexture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::StyleBoxTexture &v) noexcept {
		return Value{ ctx, std::forward<godot::StyleBoxTexture>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::StyleBoxTexture>> {
	/// @throws exception
	static godot::Ref<godot::StyleBoxTexture> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::StyleBoxTexture>((godot::StyleBoxTexture *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::StyleBoxTexture> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::StyleBoxTexture>>(v) };
	}
};
template <>
struct js_traits<godot::SubViewport> {
	/// @throws exception
	static godot::SubViewport unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SubViewport *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SubViewport v) noexcept {
		return Value{ ctx, std::forward<godot::SubViewport>(v) };
	}
};
template <>
struct js_traits<godot::SubViewport &> {
	/// @throws exception
	static godot::SubViewport &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SubViewport *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SubViewport &v) noexcept {
		return Value{ ctx, std::forward<godot::SubViewport>(v) };
	}
};
template <>
struct js_traits<godot::SubViewportContainer> {
	/// @throws exception
	static godot::SubViewportContainer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SubViewportContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SubViewportContainer v) noexcept {
		return Value{ ctx, std::forward<godot::SubViewportContainer>(v) };
	}
};
template <>
struct js_traits<godot::SubViewportContainer &> {
	/// @throws exception
	static godot::SubViewportContainer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SubViewportContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SubViewportContainer &v) noexcept {
		return Value{ ctx, std::forward<godot::SubViewportContainer>(v) };
	}
};
template <>
struct js_traits<godot::SurfaceTool> {
	/// @throws exception
	static godot::SurfaceTool unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SurfaceTool *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SurfaceTool v) noexcept {
		return Value{ ctx, std::forward<godot::SurfaceTool>(v) };
	}
};
template <>
struct js_traits<godot::SurfaceTool &> {
	/// @throws exception
	static godot::SurfaceTool &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SurfaceTool *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SurfaceTool &v) noexcept {
		return Value{ ctx, std::forward<godot::SurfaceTool>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::SurfaceTool>> {
	/// @throws exception
	static godot::Ref<godot::SurfaceTool> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::SurfaceTool>((godot::SurfaceTool *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::SurfaceTool> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::SurfaceTool>>(v) };
	}
};
template <>
struct js_traits<godot::SyntaxHighlighter> {
	/// @throws exception
	static godot::SyntaxHighlighter unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SyntaxHighlighter *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SyntaxHighlighter v) noexcept {
		return Value{ ctx, std::forward<godot::SyntaxHighlighter>(v) };
	}
};
template <>
struct js_traits<godot::SyntaxHighlighter &> {
	/// @throws exception
	static godot::SyntaxHighlighter &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SyntaxHighlighter *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SyntaxHighlighter &v) noexcept {
		return Value{ ctx, std::forward<godot::SyntaxHighlighter>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::SyntaxHighlighter>> {
	/// @throws exception
	static godot::Ref<godot::SyntaxHighlighter> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::SyntaxHighlighter>((godot::SyntaxHighlighter *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::SyntaxHighlighter> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::SyntaxHighlighter>>(v) };
	}
};
template <>
struct js_traits<godot::SystemFont> {
	/// @throws exception
	static godot::SystemFont unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SystemFont *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SystemFont v) noexcept {
		return Value{ ctx, std::forward<godot::SystemFont>(v) };
	}
};
template <>
struct js_traits<godot::SystemFont &> {
	/// @throws exception
	static godot::SystemFont &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::SystemFont *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::SystemFont &v) noexcept {
		return Value{ ctx, std::forward<godot::SystemFont>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::SystemFont>> {
	/// @throws exception
	static godot::Ref<godot::SystemFont> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::SystemFont>((godot::SystemFont *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::SystemFont> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::SystemFont>>(v) };
	}
};
template <>
struct js_traits<godot::TCPServer> {
	/// @throws exception
	static godot::TCPServer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TCPServer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TCPServer v) noexcept {
		return Value{ ctx, std::forward<godot::TCPServer>(v) };
	}
};
template <>
struct js_traits<godot::TCPServer &> {
	/// @throws exception
	static godot::TCPServer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TCPServer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TCPServer &v) noexcept {
		return Value{ ctx, std::forward<godot::TCPServer>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::TCPServer>> {
	/// @throws exception
	static godot::Ref<godot::TCPServer> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::TCPServer>((godot::TCPServer *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::TCPServer> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::TCPServer>>(v) };
	}
};
template <>
struct js_traits<godot::TLSOptions> {
	/// @throws exception
	static godot::TLSOptions unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TLSOptions *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TLSOptions v) noexcept {
		return Value{ ctx, std::forward<godot::TLSOptions>(v) };
	}
};
template <>
struct js_traits<godot::TLSOptions &> {
	/// @throws exception
	static godot::TLSOptions &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TLSOptions *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TLSOptions &v) noexcept {
		return Value{ ctx, std::forward<godot::TLSOptions>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::TLSOptions>> {
	/// @throws exception
	static godot::Ref<godot::TLSOptions> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::TLSOptions>((godot::TLSOptions *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::TLSOptions> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::TLSOptions>>(v) };
	}
};
template <>
struct js_traits<godot::TabBar> {
	/// @throws exception
	static godot::TabBar unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TabBar *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TabBar v) noexcept {
		return Value{ ctx, std::forward<godot::TabBar>(v) };
	}
};
template <>
struct js_traits<godot::TabBar &> {
	/// @throws exception
	static godot::TabBar &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TabBar *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TabBar &v) noexcept {
		return Value{ ctx, std::forward<godot::TabBar>(v) };
	}
};
template <>
struct js_traits<godot::TabContainer> {
	/// @throws exception
	static godot::TabContainer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TabContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TabContainer v) noexcept {
		return Value{ ctx, std::forward<godot::TabContainer>(v) };
	}
};
template <>
struct js_traits<godot::TabContainer &> {
	/// @throws exception
	static godot::TabContainer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TabContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TabContainer &v) noexcept {
		return Value{ ctx, std::forward<godot::TabContainer>(v) };
	}
};
template <>
struct js_traits<godot::TextEdit> {
	/// @throws exception
	static godot::TextEdit unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TextEdit *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TextEdit v) noexcept {
		return Value{ ctx, std::forward<godot::TextEdit>(v) };
	}
};
template <>
struct js_traits<godot::TextEdit &> {
	/// @throws exception
	static godot::TextEdit &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TextEdit *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TextEdit &v) noexcept {
		return Value{ ctx, std::forward<godot::TextEdit>(v) };
	}
};
template <>
struct js_traits<godot::TextLine> {
	/// @throws exception
	static godot::TextLine unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TextLine *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TextLine v) noexcept {
		return Value{ ctx, std::forward<godot::TextLine>(v) };
	}
};
template <>
struct js_traits<godot::TextLine &> {
	/// @throws exception
	static godot::TextLine &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TextLine *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TextLine &v) noexcept {
		return Value{ ctx, std::forward<godot::TextLine>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::TextLine>> {
	/// @throws exception
	static godot::Ref<godot::TextLine> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::TextLine>((godot::TextLine *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::TextLine> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::TextLine>>(v) };
	}
};
template <>
struct js_traits<godot::TextMesh> {
	/// @throws exception
	static godot::TextMesh unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TextMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TextMesh v) noexcept {
		return Value{ ctx, std::forward<godot::TextMesh>(v) };
	}
};
template <>
struct js_traits<godot::TextMesh &> {
	/// @throws exception
	static godot::TextMesh &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TextMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TextMesh &v) noexcept {
		return Value{ ctx, std::forward<godot::TextMesh>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::TextMesh>> {
	/// @throws exception
	static godot::Ref<godot::TextMesh> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::TextMesh>((godot::TextMesh *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::TextMesh> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::TextMesh>>(v) };
	}
};
template <>
struct js_traits<godot::TextParagraph> {
	/// @throws exception
	static godot::TextParagraph unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TextParagraph *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TextParagraph v) noexcept {
		return Value{ ctx, std::forward<godot::TextParagraph>(v) };
	}
};
template <>
struct js_traits<godot::TextParagraph &> {
	/// @throws exception
	static godot::TextParagraph &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TextParagraph *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TextParagraph &v) noexcept {
		return Value{ ctx, std::forward<godot::TextParagraph>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::TextParagraph>> {
	/// @throws exception
	static godot::Ref<godot::TextParagraph> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::TextParagraph>((godot::TextParagraph *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::TextParagraph> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::TextParagraph>>(v) };
	}
};
template <>
struct js_traits<godot::TextServer> {
	/// @throws exception
	static godot::TextServer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TextServer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TextServer v) noexcept {
		return Value{ ctx, std::forward<godot::TextServer>(v) };
	}
};
template <>
struct js_traits<godot::TextServer &> {
	/// @throws exception
	static godot::TextServer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TextServer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TextServer &v) noexcept {
		return Value{ ctx, std::forward<godot::TextServer>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::TextServer>> {
	/// @throws exception
	static godot::Ref<godot::TextServer> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::TextServer>((godot::TextServer *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::TextServer> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::TextServer>>(v) };
	}
};
template <>
struct js_traits<godot::TextServerAdvanced> {
	/// @throws exception
	static godot::TextServerAdvanced unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TextServerAdvanced *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TextServerAdvanced v) noexcept {
		return Value{ ctx, std::forward<godot::TextServerAdvanced>(v) };
	}
};
template <>
struct js_traits<godot::TextServerAdvanced &> {
	/// @throws exception
	static godot::TextServerAdvanced &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TextServerAdvanced *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TextServerAdvanced &v) noexcept {
		return Value{ ctx, std::forward<godot::TextServerAdvanced>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::TextServerAdvanced>> {
	/// @throws exception
	static godot::Ref<godot::TextServerAdvanced> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::TextServerAdvanced>((godot::TextServerAdvanced *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::TextServerAdvanced> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::TextServerAdvanced>>(v) };
	}
};
template <>
struct js_traits<godot::TextServerDummy> {
	/// @throws exception
	static godot::TextServerDummy unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TextServerDummy *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TextServerDummy v) noexcept {
		return Value{ ctx, std::forward<godot::TextServerDummy>(v) };
	}
};
template <>
struct js_traits<godot::TextServerDummy &> {
	/// @throws exception
	static godot::TextServerDummy &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TextServerDummy *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TextServerDummy &v) noexcept {
		return Value{ ctx, std::forward<godot::TextServerDummy>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::TextServerDummy>> {
	/// @throws exception
	static godot::Ref<godot::TextServerDummy> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::TextServerDummy>((godot::TextServerDummy *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::TextServerDummy> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::TextServerDummy>>(v) };
	}
};
template <>
struct js_traits<godot::TextServerExtension> {
	/// @throws exception
	static godot::TextServerExtension unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TextServerExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TextServerExtension v) noexcept {
		return Value{ ctx, std::forward<godot::TextServerExtension>(v) };
	}
};
template <>
struct js_traits<godot::TextServerExtension &> {
	/// @throws exception
	static godot::TextServerExtension &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TextServerExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TextServerExtension &v) noexcept {
		return Value{ ctx, std::forward<godot::TextServerExtension>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::TextServerExtension>> {
	/// @throws exception
	static godot::Ref<godot::TextServerExtension> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::TextServerExtension>((godot::TextServerExtension *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::TextServerExtension> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::TextServerExtension>>(v) };
	}
};
template <>
struct js_traits<godot::TextServerManager> {
	/// @throws exception
	static godot::TextServerManager unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TextServerManager *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TextServerManager v) noexcept {
		return Value{ ctx, std::forward<godot::TextServerManager>(v) };
	}
};
template <>
struct js_traits<godot::TextServerManager &> {
	/// @throws exception
	static godot::TextServerManager &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TextServerManager *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TextServerManager &v) noexcept {
		return Value{ ctx, std::forward<godot::TextServerManager>(v) };
	}
};
template <>
struct js_traits<godot::Texture> {
	/// @throws exception
	static godot::Texture unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Texture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Texture v) noexcept {
		return Value{ ctx, std::forward<godot::Texture>(v) };
	}
};
template <>
struct js_traits<godot::Texture &> {
	/// @throws exception
	static godot::Texture &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Texture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Texture &v) noexcept {
		return Value{ ctx, std::forward<godot::Texture>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Texture>> {
	/// @throws exception
	static godot::Ref<godot::Texture> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Texture>((godot::Texture *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Texture> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Texture>>(v) };
	}
};
template <>
struct js_traits<godot::Texture2D> {
	/// @throws exception
	static godot::Texture2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Texture2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Texture2D v) noexcept {
		return Value{ ctx, std::forward<godot::Texture2D>(v) };
	}
};
template <>
struct js_traits<godot::Texture2D &> {
	/// @throws exception
	static godot::Texture2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Texture2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Texture2D &v) noexcept {
		return Value{ ctx, std::forward<godot::Texture2D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Texture2D>> {
	/// @throws exception
	static godot::Ref<godot::Texture2D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Texture2D>((godot::Texture2D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Texture2D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Texture2D>>(v) };
	}
};
template <>
struct js_traits<godot::Texture2DArray> {
	/// @throws exception
	static godot::Texture2DArray unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Texture2DArray *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Texture2DArray v) noexcept {
		return Value{ ctx, std::forward<godot::Texture2DArray>(v) };
	}
};
template <>
struct js_traits<godot::Texture2DArray &> {
	/// @throws exception
	static godot::Texture2DArray &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Texture2DArray *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Texture2DArray &v) noexcept {
		return Value{ ctx, std::forward<godot::Texture2DArray>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Texture2DArray>> {
	/// @throws exception
	static godot::Ref<godot::Texture2DArray> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Texture2DArray>((godot::Texture2DArray *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Texture2DArray> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Texture2DArray>>(v) };
	}
};
template <>
struct js_traits<godot::Texture2DArrayRD> {
	/// @throws exception
	static godot::Texture2DArrayRD unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Texture2DArrayRD *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Texture2DArrayRD v) noexcept {
		return Value{ ctx, std::forward<godot::Texture2DArrayRD>(v) };
	}
};
template <>
struct js_traits<godot::Texture2DArrayRD &> {
	/// @throws exception
	static godot::Texture2DArrayRD &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Texture2DArrayRD *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Texture2DArrayRD &v) noexcept {
		return Value{ ctx, std::forward<godot::Texture2DArrayRD>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Texture2DArrayRD>> {
	/// @throws exception
	static godot::Ref<godot::Texture2DArrayRD> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Texture2DArrayRD>((godot::Texture2DArrayRD *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Texture2DArrayRD> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Texture2DArrayRD>>(v) };
	}
};
template <>
struct js_traits<godot::Texture2DRD> {
	/// @throws exception
	static godot::Texture2DRD unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Texture2DRD *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Texture2DRD v) noexcept {
		return Value{ ctx, std::forward<godot::Texture2DRD>(v) };
	}
};
template <>
struct js_traits<godot::Texture2DRD &> {
	/// @throws exception
	static godot::Texture2DRD &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Texture2DRD *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Texture2DRD &v) noexcept {
		return Value{ ctx, std::forward<godot::Texture2DRD>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Texture2DRD>> {
	/// @throws exception
	static godot::Ref<godot::Texture2DRD> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Texture2DRD>((godot::Texture2DRD *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Texture2DRD> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Texture2DRD>>(v) };
	}
};
template <>
struct js_traits<godot::Texture3D> {
	/// @throws exception
	static godot::Texture3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Texture3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Texture3D v) noexcept {
		return Value{ ctx, std::forward<godot::Texture3D>(v) };
	}
};
template <>
struct js_traits<godot::Texture3D &> {
	/// @throws exception
	static godot::Texture3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Texture3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Texture3D &v) noexcept {
		return Value{ ctx, std::forward<godot::Texture3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Texture3D>> {
	/// @throws exception
	static godot::Ref<godot::Texture3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Texture3D>((godot::Texture3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Texture3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Texture3D>>(v) };
	}
};
template <>
struct js_traits<godot::Texture3DRD> {
	/// @throws exception
	static godot::Texture3DRD unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Texture3DRD *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Texture3DRD v) noexcept {
		return Value{ ctx, std::forward<godot::Texture3DRD>(v) };
	}
};
template <>
struct js_traits<godot::Texture3DRD &> {
	/// @throws exception
	static godot::Texture3DRD &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Texture3DRD *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Texture3DRD &v) noexcept {
		return Value{ ctx, std::forward<godot::Texture3DRD>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Texture3DRD>> {
	/// @throws exception
	static godot::Ref<godot::Texture3DRD> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Texture3DRD>((godot::Texture3DRD *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Texture3DRD> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Texture3DRD>>(v) };
	}
};
template <>
struct js_traits<godot::TextureButton> {
	/// @throws exception
	static godot::TextureButton unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TextureButton *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TextureButton v) noexcept {
		return Value{ ctx, std::forward<godot::TextureButton>(v) };
	}
};
template <>
struct js_traits<godot::TextureButton &> {
	/// @throws exception
	static godot::TextureButton &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TextureButton *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TextureButton &v) noexcept {
		return Value{ ctx, std::forward<godot::TextureButton>(v) };
	}
};
template <>
struct js_traits<godot::TextureCubemapArrayRD> {
	/// @throws exception
	static godot::TextureCubemapArrayRD unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TextureCubemapArrayRD *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TextureCubemapArrayRD v) noexcept {
		return Value{ ctx, std::forward<godot::TextureCubemapArrayRD>(v) };
	}
};
template <>
struct js_traits<godot::TextureCubemapArrayRD &> {
	/// @throws exception
	static godot::TextureCubemapArrayRD &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TextureCubemapArrayRD *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TextureCubemapArrayRD &v) noexcept {
		return Value{ ctx, std::forward<godot::TextureCubemapArrayRD>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::TextureCubemapArrayRD>> {
	/// @throws exception
	static godot::Ref<godot::TextureCubemapArrayRD> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::TextureCubemapArrayRD>((godot::TextureCubemapArrayRD *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::TextureCubemapArrayRD> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::TextureCubemapArrayRD>>(v) };
	}
};
template <>
struct js_traits<godot::TextureCubemapRD> {
	/// @throws exception
	static godot::TextureCubemapRD unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TextureCubemapRD *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TextureCubemapRD v) noexcept {
		return Value{ ctx, std::forward<godot::TextureCubemapRD>(v) };
	}
};
template <>
struct js_traits<godot::TextureCubemapRD &> {
	/// @throws exception
	static godot::TextureCubemapRD &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TextureCubemapRD *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TextureCubemapRD &v) noexcept {
		return Value{ ctx, std::forward<godot::TextureCubemapRD>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::TextureCubemapRD>> {
	/// @throws exception
	static godot::Ref<godot::TextureCubemapRD> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::TextureCubemapRD>((godot::TextureCubemapRD *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::TextureCubemapRD> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::TextureCubemapRD>>(v) };
	}
};
template <>
struct js_traits<godot::TextureLayered> {
	/// @throws exception
	static godot::TextureLayered unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TextureLayered *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TextureLayered v) noexcept {
		return Value{ ctx, std::forward<godot::TextureLayered>(v) };
	}
};
template <>
struct js_traits<godot::TextureLayered &> {
	/// @throws exception
	static godot::TextureLayered &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TextureLayered *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TextureLayered &v) noexcept {
		return Value{ ctx, std::forward<godot::TextureLayered>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::TextureLayered>> {
	/// @throws exception
	static godot::Ref<godot::TextureLayered> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::TextureLayered>((godot::TextureLayered *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::TextureLayered> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::TextureLayered>>(v) };
	}
};
template <>
struct js_traits<godot::TextureLayeredRD> {
	/// @throws exception
	static godot::TextureLayeredRD unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TextureLayeredRD *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TextureLayeredRD v) noexcept {
		return Value{ ctx, std::forward<godot::TextureLayeredRD>(v) };
	}
};
template <>
struct js_traits<godot::TextureLayeredRD &> {
	/// @throws exception
	static godot::TextureLayeredRD &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TextureLayeredRD *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TextureLayeredRD &v) noexcept {
		return Value{ ctx, std::forward<godot::TextureLayeredRD>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::TextureLayeredRD>> {
	/// @throws exception
	static godot::Ref<godot::TextureLayeredRD> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::TextureLayeredRD>((godot::TextureLayeredRD *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::TextureLayeredRD> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::TextureLayeredRD>>(v) };
	}
};
template <>
struct js_traits<godot::TextureProgressBar> {
	/// @throws exception
	static godot::TextureProgressBar unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TextureProgressBar *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TextureProgressBar v) noexcept {
		return Value{ ctx, std::forward<godot::TextureProgressBar>(v) };
	}
};
template <>
struct js_traits<godot::TextureProgressBar &> {
	/// @throws exception
	static godot::TextureProgressBar &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TextureProgressBar *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TextureProgressBar &v) noexcept {
		return Value{ ctx, std::forward<godot::TextureProgressBar>(v) };
	}
};
template <>
struct js_traits<godot::TextureRect> {
	/// @throws exception
	static godot::TextureRect unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TextureRect *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TextureRect v) noexcept {
		return Value{ ctx, std::forward<godot::TextureRect>(v) };
	}
};
template <>
struct js_traits<godot::TextureRect &> {
	/// @throws exception
	static godot::TextureRect &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TextureRect *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TextureRect &v) noexcept {
		return Value{ ctx, std::forward<godot::TextureRect>(v) };
	}
};
template <>
struct js_traits<godot::Theme> {
	/// @throws exception
	static godot::Theme unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Theme *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Theme v) noexcept {
		return Value{ ctx, std::forward<godot::Theme>(v) };
	}
};
template <>
struct js_traits<godot::Theme &> {
	/// @throws exception
	static godot::Theme &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Theme *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Theme &v) noexcept {
		return Value{ ctx, std::forward<godot::Theme>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Theme>> {
	/// @throws exception
	static godot::Ref<godot::Theme> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Theme>((godot::Theme *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Theme> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Theme>>(v) };
	}
};
template <>
struct js_traits<godot::ThemeDB> {
	/// @throws exception
	static godot::ThemeDB unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ThemeDB *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ThemeDB v) noexcept {
		return Value{ ctx, std::forward<godot::ThemeDB>(v) };
	}
};
template <>
struct js_traits<godot::ThemeDB &> {
	/// @throws exception
	static godot::ThemeDB &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ThemeDB *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ThemeDB &v) noexcept {
		return Value{ ctx, std::forward<godot::ThemeDB>(v) };
	}
};
template <>
struct js_traits<godot::Thread> {
	/// @throws exception
	static godot::Thread unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Thread *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Thread v) noexcept {
		return Value{ ctx, std::forward<godot::Thread>(v) };
	}
};
template <>
struct js_traits<godot::Thread &> {
	/// @throws exception
	static godot::Thread &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Thread *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Thread &v) noexcept {
		return Value{ ctx, std::forward<godot::Thread>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Thread>> {
	/// @throws exception
	static godot::Ref<godot::Thread> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Thread>((godot::Thread *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Thread> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Thread>>(v) };
	}
};
template <>
struct js_traits<godot::TileData> {
	/// @throws exception
	static godot::TileData unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TileData *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TileData v) noexcept {
		return Value{ ctx, std::forward<godot::TileData>(v) };
	}
};
template <>
struct js_traits<godot::TileData &> {
	/// @throws exception
	static godot::TileData &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TileData *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TileData &v) noexcept {
		return Value{ ctx, std::forward<godot::TileData>(v) };
	}
};
template <>
struct js_traits<godot::TileMap> {
	/// @throws exception
	static godot::TileMap unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TileMap *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TileMap v) noexcept {
		return Value{ ctx, std::forward<godot::TileMap>(v) };
	}
};
template <>
struct js_traits<godot::TileMap &> {
	/// @throws exception
	static godot::TileMap &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TileMap *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TileMap &v) noexcept {
		return Value{ ctx, std::forward<godot::TileMap>(v) };
	}
};
template <>
struct js_traits<godot::TileMapPattern> {
	/// @throws exception
	static godot::TileMapPattern unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TileMapPattern *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TileMapPattern v) noexcept {
		return Value{ ctx, std::forward<godot::TileMapPattern>(v) };
	}
};
template <>
struct js_traits<godot::TileMapPattern &> {
	/// @throws exception
	static godot::TileMapPattern &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TileMapPattern *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TileMapPattern &v) noexcept {
		return Value{ ctx, std::forward<godot::TileMapPattern>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::TileMapPattern>> {
	/// @throws exception
	static godot::Ref<godot::TileMapPattern> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::TileMapPattern>((godot::TileMapPattern *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::TileMapPattern> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::TileMapPattern>>(v) };
	}
};
template <>
struct js_traits<godot::TileSet> {
	/// @throws exception
	static godot::TileSet unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TileSet *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TileSet v) noexcept {
		return Value{ ctx, std::forward<godot::TileSet>(v) };
	}
};
template <>
struct js_traits<godot::TileSet &> {
	/// @throws exception
	static godot::TileSet &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TileSet *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TileSet &v) noexcept {
		return Value{ ctx, std::forward<godot::TileSet>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::TileSet>> {
	/// @throws exception
	static godot::Ref<godot::TileSet> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::TileSet>((godot::TileSet *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::TileSet> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::TileSet>>(v) };
	}
};
template <>
struct js_traits<godot::TileSetAtlasSource> {
	/// @throws exception
	static godot::TileSetAtlasSource unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TileSetAtlasSource *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TileSetAtlasSource v) noexcept {
		return Value{ ctx, std::forward<godot::TileSetAtlasSource>(v) };
	}
};
template <>
struct js_traits<godot::TileSetAtlasSource &> {
	/// @throws exception
	static godot::TileSetAtlasSource &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TileSetAtlasSource *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TileSetAtlasSource &v) noexcept {
		return Value{ ctx, std::forward<godot::TileSetAtlasSource>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::TileSetAtlasSource>> {
	/// @throws exception
	static godot::Ref<godot::TileSetAtlasSource> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::TileSetAtlasSource>((godot::TileSetAtlasSource *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::TileSetAtlasSource> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::TileSetAtlasSource>>(v) };
	}
};
template <>
struct js_traits<godot::TileSetScenesCollectionSource> {
	/// @throws exception
	static godot::TileSetScenesCollectionSource unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TileSetScenesCollectionSource *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TileSetScenesCollectionSource v) noexcept {
		return Value{ ctx, std::forward<godot::TileSetScenesCollectionSource>(v) };
	}
};
template <>
struct js_traits<godot::TileSetScenesCollectionSource &> {
	/// @throws exception
	static godot::TileSetScenesCollectionSource &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TileSetScenesCollectionSource *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TileSetScenesCollectionSource &v) noexcept {
		return Value{ ctx, std::forward<godot::TileSetScenesCollectionSource>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::TileSetScenesCollectionSource>> {
	/// @throws exception
	static godot::Ref<godot::TileSetScenesCollectionSource> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::TileSetScenesCollectionSource>((godot::TileSetScenesCollectionSource *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::TileSetScenesCollectionSource> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::TileSetScenesCollectionSource>>(v) };
	}
};
template <>
struct js_traits<godot::TileSetSource> {
	/// @throws exception
	static godot::TileSetSource unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TileSetSource *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TileSetSource v) noexcept {
		return Value{ ctx, std::forward<godot::TileSetSource>(v) };
	}
};
template <>
struct js_traits<godot::TileSetSource &> {
	/// @throws exception
	static godot::TileSetSource &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TileSetSource *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TileSetSource &v) noexcept {
		return Value{ ctx, std::forward<godot::TileSetSource>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::TileSetSource>> {
	/// @throws exception
	static godot::Ref<godot::TileSetSource> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::TileSetSource>((godot::TileSetSource *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::TileSetSource> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::TileSetSource>>(v) };
	}
};
template <>
struct js_traits<godot::Time> {
	/// @throws exception
	static godot::Time unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Time *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Time v) noexcept {
		return Value{ ctx, std::forward<godot::Time>(v) };
	}
};
template <>
struct js_traits<godot::Time &> {
	/// @throws exception
	static godot::Time &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Time *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Time &v) noexcept {
		return Value{ ctx, std::forward<godot::Time>(v) };
	}
};
template <>
struct js_traits<godot::Timer> {
	/// @throws exception
	static godot::Timer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Timer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Timer v) noexcept {
		return Value{ ctx, std::forward<godot::Timer>(v) };
	}
};
template <>
struct js_traits<godot::Timer &> {
	/// @throws exception
	static godot::Timer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Timer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Timer &v) noexcept {
		return Value{ ctx, std::forward<godot::Timer>(v) };
	}
};
template <>
struct js_traits<godot::TorusMesh> {
	/// @throws exception
	static godot::TorusMesh unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TorusMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TorusMesh v) noexcept {
		return Value{ ctx, std::forward<godot::TorusMesh>(v) };
	}
};
template <>
struct js_traits<godot::TorusMesh &> {
	/// @throws exception
	static godot::TorusMesh &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TorusMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TorusMesh &v) noexcept {
		return Value{ ctx, std::forward<godot::TorusMesh>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::TorusMesh>> {
	/// @throws exception
	static godot::Ref<godot::TorusMesh> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::TorusMesh>((godot::TorusMesh *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::TorusMesh> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::TorusMesh>>(v) };
	}
};
template <>
struct js_traits<godot::TouchScreenButton> {
	/// @throws exception
	static godot::TouchScreenButton unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TouchScreenButton *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TouchScreenButton v) noexcept {
		return Value{ ctx, std::forward<godot::TouchScreenButton>(v) };
	}
};
template <>
struct js_traits<godot::TouchScreenButton &> {
	/// @throws exception
	static godot::TouchScreenButton &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TouchScreenButton *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TouchScreenButton &v) noexcept {
		return Value{ ctx, std::forward<godot::TouchScreenButton>(v) };
	}
};
template <>
struct js_traits<godot::Translation> {
	/// @throws exception
	static godot::Translation unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Translation *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Translation v) noexcept {
		return Value{ ctx, std::forward<godot::Translation>(v) };
	}
};
template <>
struct js_traits<godot::Translation &> {
	/// @throws exception
	static godot::Translation &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Translation *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Translation &v) noexcept {
		return Value{ ctx, std::forward<godot::Translation>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Translation>> {
	/// @throws exception
	static godot::Ref<godot::Translation> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Translation>((godot::Translation *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Translation> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Translation>>(v) };
	}
};
template <>
struct js_traits<godot::TranslationServer> {
	/// @throws exception
	static godot::TranslationServer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TranslationServer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TranslationServer v) noexcept {
		return Value{ ctx, std::forward<godot::TranslationServer>(v) };
	}
};
template <>
struct js_traits<godot::TranslationServer &> {
	/// @throws exception
	static godot::TranslationServer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TranslationServer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TranslationServer &v) noexcept {
		return Value{ ctx, std::forward<godot::TranslationServer>(v) };
	}
};
template <>
struct js_traits<godot::Tree> {
	/// @throws exception
	static godot::Tree unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Tree *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Tree v) noexcept {
		return Value{ ctx, std::forward<godot::Tree>(v) };
	}
};
template <>
struct js_traits<godot::Tree &> {
	/// @throws exception
	static godot::Tree &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Tree *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Tree &v) noexcept {
		return Value{ ctx, std::forward<godot::Tree>(v) };
	}
};
template <>
struct js_traits<godot::TreeItem> {
	/// @throws exception
	static godot::TreeItem unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TreeItem *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TreeItem v) noexcept {
		return Value{ ctx, std::forward<godot::TreeItem>(v) };
	}
};
template <>
struct js_traits<godot::TreeItem &> {
	/// @throws exception
	static godot::TreeItem &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TreeItem *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TreeItem &v) noexcept {
		return Value{ ctx, std::forward<godot::TreeItem>(v) };
	}
};
template <>
struct js_traits<godot::TriangleMesh> {
	/// @throws exception
	static godot::TriangleMesh unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TriangleMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TriangleMesh v) noexcept {
		return Value{ ctx, std::forward<godot::TriangleMesh>(v) };
	}
};
template <>
struct js_traits<godot::TriangleMesh &> {
	/// @throws exception
	static godot::TriangleMesh &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TriangleMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TriangleMesh &v) noexcept {
		return Value{ ctx, std::forward<godot::TriangleMesh>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::TriangleMesh>> {
	/// @throws exception
	static godot::Ref<godot::TriangleMesh> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::TriangleMesh>((godot::TriangleMesh *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::TriangleMesh> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::TriangleMesh>>(v) };
	}
};
template <>
struct js_traits<godot::TubeTrailMesh> {
	/// @throws exception
	static godot::TubeTrailMesh unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TubeTrailMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TubeTrailMesh v) noexcept {
		return Value{ ctx, std::forward<godot::TubeTrailMesh>(v) };
	}
};
template <>
struct js_traits<godot::TubeTrailMesh &> {
	/// @throws exception
	static godot::TubeTrailMesh &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TubeTrailMesh *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TubeTrailMesh &v) noexcept {
		return Value{ ctx, std::forward<godot::TubeTrailMesh>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::TubeTrailMesh>> {
	/// @throws exception
	static godot::Ref<godot::TubeTrailMesh> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::TubeTrailMesh>((godot::TubeTrailMesh *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::TubeTrailMesh> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::TubeTrailMesh>>(v) };
	}
};
template <>
struct js_traits<godot::Tween> {
	/// @throws exception
	static godot::Tween unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Tween *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Tween v) noexcept {
		return Value{ ctx, std::forward<godot::Tween>(v) };
	}
};
template <>
struct js_traits<godot::Tween &> {
	/// @throws exception
	static godot::Tween &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Tween *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Tween &v) noexcept {
		return Value{ ctx, std::forward<godot::Tween>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Tween>> {
	/// @throws exception
	static godot::Ref<godot::Tween> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Tween>((godot::Tween *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Tween> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Tween>>(v) };
	}
};
template <>
struct js_traits<godot::Tweener> {
	/// @throws exception
	static godot::Tweener unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Tweener *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Tweener v) noexcept {
		return Value{ ctx, std::forward<godot::Tweener>(v) };
	}
};
template <>
struct js_traits<godot::Tweener &> {
	/// @throws exception
	static godot::Tweener &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Tweener *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Tweener &v) noexcept {
		return Value{ ctx, std::forward<godot::Tweener>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::Tweener>> {
	/// @throws exception
	static godot::Ref<godot::Tweener> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::Tweener>((godot::Tweener *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::Tweener> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::Tweener>>(v) };
	}
};
template <>
struct js_traits<godot::UDPServer> {
	/// @throws exception
	static godot::UDPServer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::UDPServer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::UDPServer v) noexcept {
		return Value{ ctx, std::forward<godot::UDPServer>(v) };
	}
};
template <>
struct js_traits<godot::UDPServer &> {
	/// @throws exception
	static godot::UDPServer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::UDPServer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::UDPServer &v) noexcept {
		return Value{ ctx, std::forward<godot::UDPServer>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::UDPServer>> {
	/// @throws exception
	static godot::Ref<godot::UDPServer> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::UDPServer>((godot::UDPServer *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::UDPServer> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::UDPServer>>(v) };
	}
};
template <>
struct js_traits<godot::UPNP> {
	/// @throws exception
	static godot::UPNP unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::UPNP *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::UPNP v) noexcept {
		return Value{ ctx, std::forward<godot::UPNP>(v) };
	}
};
template <>
struct js_traits<godot::UPNP &> {
	/// @throws exception
	static godot::UPNP &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::UPNP *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::UPNP &v) noexcept {
		return Value{ ctx, std::forward<godot::UPNP>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::UPNP>> {
	/// @throws exception
	static godot::Ref<godot::UPNP> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::UPNP>((godot::UPNP *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::UPNP> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::UPNP>>(v) };
	}
};
template <>
struct js_traits<godot::UPNPDevice> {
	/// @throws exception
	static godot::UPNPDevice unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::UPNPDevice *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::UPNPDevice v) noexcept {
		return Value{ ctx, std::forward<godot::UPNPDevice>(v) };
	}
};
template <>
struct js_traits<godot::UPNPDevice &> {
	/// @throws exception
	static godot::UPNPDevice &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::UPNPDevice *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::UPNPDevice &v) noexcept {
		return Value{ ctx, std::forward<godot::UPNPDevice>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::UPNPDevice>> {
	/// @throws exception
	static godot::Ref<godot::UPNPDevice> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::UPNPDevice>((godot::UPNPDevice *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::UPNPDevice> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::UPNPDevice>>(v) };
	}
};
template <>
struct js_traits<godot::UndoRedo> {
	/// @throws exception
	static godot::UndoRedo unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::UndoRedo *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::UndoRedo v) noexcept {
		return Value{ ctx, std::forward<godot::UndoRedo>(v) };
	}
};
template <>
struct js_traits<godot::UndoRedo &> {
	/// @throws exception
	static godot::UndoRedo &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::UndoRedo *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::UndoRedo &v) noexcept {
		return Value{ ctx, std::forward<godot::UndoRedo>(v) };
	}
};
template <>
struct js_traits<godot::VBoxContainer> {
	/// @throws exception
	static godot::VBoxContainer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VBoxContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VBoxContainer v) noexcept {
		return Value{ ctx, std::forward<godot::VBoxContainer>(v) };
	}
};
template <>
struct js_traits<godot::VBoxContainer &> {
	/// @throws exception
	static godot::VBoxContainer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VBoxContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VBoxContainer &v) noexcept {
		return Value{ ctx, std::forward<godot::VBoxContainer>(v) };
	}
};
template <>
struct js_traits<godot::VFlowContainer> {
	/// @throws exception
	static godot::VFlowContainer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VFlowContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VFlowContainer v) noexcept {
		return Value{ ctx, std::forward<godot::VFlowContainer>(v) };
	}
};
template <>
struct js_traits<godot::VFlowContainer &> {
	/// @throws exception
	static godot::VFlowContainer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VFlowContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VFlowContainer &v) noexcept {
		return Value{ ctx, std::forward<godot::VFlowContainer>(v) };
	}
};
template <>
struct js_traits<godot::VScrollBar> {
	/// @throws exception
	static godot::VScrollBar unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VScrollBar *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VScrollBar v) noexcept {
		return Value{ ctx, std::forward<godot::VScrollBar>(v) };
	}
};
template <>
struct js_traits<godot::VScrollBar &> {
	/// @throws exception
	static godot::VScrollBar &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VScrollBar *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VScrollBar &v) noexcept {
		return Value{ ctx, std::forward<godot::VScrollBar>(v) };
	}
};
template <>
struct js_traits<godot::VSeparator> {
	/// @throws exception
	static godot::VSeparator unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VSeparator *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VSeparator v) noexcept {
		return Value{ ctx, std::forward<godot::VSeparator>(v) };
	}
};
template <>
struct js_traits<godot::VSeparator &> {
	/// @throws exception
	static godot::VSeparator &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VSeparator *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VSeparator &v) noexcept {
		return Value{ ctx, std::forward<godot::VSeparator>(v) };
	}
};
template <>
struct js_traits<godot::VSlider> {
	/// @throws exception
	static godot::VSlider unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VSlider *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VSlider v) noexcept {
		return Value{ ctx, std::forward<godot::VSlider>(v) };
	}
};
template <>
struct js_traits<godot::VSlider &> {
	/// @throws exception
	static godot::VSlider &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VSlider *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VSlider &v) noexcept {
		return Value{ ctx, std::forward<godot::VSlider>(v) };
	}
};
template <>
struct js_traits<godot::VSplitContainer> {
	/// @throws exception
	static godot::VSplitContainer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VSplitContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VSplitContainer v) noexcept {
		return Value{ ctx, std::forward<godot::VSplitContainer>(v) };
	}
};
template <>
struct js_traits<godot::VSplitContainer &> {
	/// @throws exception
	static godot::VSplitContainer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VSplitContainer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VSplitContainer &v) noexcept {
		return Value{ ctx, std::forward<godot::VSplitContainer>(v) };
	}
};
template <>
struct js_traits<godot::VehicleBody3D> {
	/// @throws exception
	static godot::VehicleBody3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VehicleBody3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VehicleBody3D v) noexcept {
		return Value{ ctx, std::forward<godot::VehicleBody3D>(v) };
	}
};
template <>
struct js_traits<godot::VehicleBody3D &> {
	/// @throws exception
	static godot::VehicleBody3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VehicleBody3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VehicleBody3D &v) noexcept {
		return Value{ ctx, std::forward<godot::VehicleBody3D>(v) };
	}
};
template <>
struct js_traits<godot::VehicleWheel3D> {
	/// @throws exception
	static godot::VehicleWheel3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VehicleWheel3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VehicleWheel3D v) noexcept {
		return Value{ ctx, std::forward<godot::VehicleWheel3D>(v) };
	}
};
template <>
struct js_traits<godot::VehicleWheel3D &> {
	/// @throws exception
	static godot::VehicleWheel3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VehicleWheel3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VehicleWheel3D &v) noexcept {
		return Value{ ctx, std::forward<godot::VehicleWheel3D>(v) };
	}
};
template <>
struct js_traits<godot::VideoStream> {
	/// @throws exception
	static godot::VideoStream unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VideoStream *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VideoStream v) noexcept {
		return Value{ ctx, std::forward<godot::VideoStream>(v) };
	}
};
template <>
struct js_traits<godot::VideoStream &> {
	/// @throws exception
	static godot::VideoStream &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VideoStream *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VideoStream &v) noexcept {
		return Value{ ctx, std::forward<godot::VideoStream>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::VideoStream>> {
	/// @throws exception
	static godot::Ref<godot::VideoStream> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::VideoStream>((godot::VideoStream *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::VideoStream> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::VideoStream>>(v) };
	}
};
template <>
struct js_traits<godot::VideoStreamPlayback> {
	/// @throws exception
	static godot::VideoStreamPlayback unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VideoStreamPlayback *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VideoStreamPlayback v) noexcept {
		return Value{ ctx, std::forward<godot::VideoStreamPlayback>(v) };
	}
};
template <>
struct js_traits<godot::VideoStreamPlayback &> {
	/// @throws exception
	static godot::VideoStreamPlayback &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VideoStreamPlayback *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VideoStreamPlayback &v) noexcept {
		return Value{ ctx, std::forward<godot::VideoStreamPlayback>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::VideoStreamPlayback>> {
	/// @throws exception
	static godot::Ref<godot::VideoStreamPlayback> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::VideoStreamPlayback>((godot::VideoStreamPlayback *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::VideoStreamPlayback> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::VideoStreamPlayback>>(v) };
	}
};
template <>
struct js_traits<godot::VideoStreamPlayer> {
	/// @throws exception
	static godot::VideoStreamPlayer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VideoStreamPlayer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VideoStreamPlayer v) noexcept {
		return Value{ ctx, std::forward<godot::VideoStreamPlayer>(v) };
	}
};
template <>
struct js_traits<godot::VideoStreamPlayer &> {
	/// @throws exception
	static godot::VideoStreamPlayer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VideoStreamPlayer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VideoStreamPlayer &v) noexcept {
		return Value{ ctx, std::forward<godot::VideoStreamPlayer>(v) };
	}
};
template <>
struct js_traits<godot::VideoStreamTheora> {
	/// @throws exception
	static godot::VideoStreamTheora unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VideoStreamTheora *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VideoStreamTheora v) noexcept {
		return Value{ ctx, std::forward<godot::VideoStreamTheora>(v) };
	}
};
template <>
struct js_traits<godot::VideoStreamTheora &> {
	/// @throws exception
	static godot::VideoStreamTheora &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VideoStreamTheora *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VideoStreamTheora &v) noexcept {
		return Value{ ctx, std::forward<godot::VideoStreamTheora>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::VideoStreamTheora>> {
	/// @throws exception
	static godot::Ref<godot::VideoStreamTheora> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::VideoStreamTheora>((godot::VideoStreamTheora *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::VideoStreamTheora> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::VideoStreamTheora>>(v) };
	}
};
template <>
struct js_traits<godot::Viewport> {
	/// @throws exception
	static godot::Viewport unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Viewport *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Viewport v) noexcept {
		return Value{ ctx, std::forward<godot::Viewport>(v) };
	}
};
template <>
struct js_traits<godot::Viewport &> {
	/// @throws exception
	static godot::Viewport &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Viewport *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Viewport &v) noexcept {
		return Value{ ctx, std::forward<godot::Viewport>(v) };
	}
};
template <>
struct js_traits<godot::ViewportTexture> {
	/// @throws exception
	static godot::ViewportTexture unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ViewportTexture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ViewportTexture v) noexcept {
		return Value{ ctx, std::forward<godot::ViewportTexture>(v) };
	}
};
template <>
struct js_traits<godot::ViewportTexture &> {
	/// @throws exception
	static godot::ViewportTexture &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ViewportTexture *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ViewportTexture &v) noexcept {
		return Value{ ctx, std::forward<godot::ViewportTexture>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ViewportTexture>> {
	/// @throws exception
	static godot::Ref<godot::ViewportTexture> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ViewportTexture>((godot::ViewportTexture *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ViewportTexture> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ViewportTexture>>(v) };
	}
};
template <>
struct js_traits<godot::VisibleOnScreenEnabler2D> {
	/// @throws exception
	static godot::VisibleOnScreenEnabler2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VisibleOnScreenEnabler2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VisibleOnScreenEnabler2D v) noexcept {
		return Value{ ctx, std::forward<godot::VisibleOnScreenEnabler2D>(v) };
	}
};
template <>
struct js_traits<godot::VisibleOnScreenEnabler2D &> {
	/// @throws exception
	static godot::VisibleOnScreenEnabler2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VisibleOnScreenEnabler2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VisibleOnScreenEnabler2D &v) noexcept {
		return Value{ ctx, std::forward<godot::VisibleOnScreenEnabler2D>(v) };
	}
};
template <>
struct js_traits<godot::VisibleOnScreenEnabler3D> {
	/// @throws exception
	static godot::VisibleOnScreenEnabler3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VisibleOnScreenEnabler3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VisibleOnScreenEnabler3D v) noexcept {
		return Value{ ctx, std::forward<godot::VisibleOnScreenEnabler3D>(v) };
	}
};
template <>
struct js_traits<godot::VisibleOnScreenEnabler3D &> {
	/// @throws exception
	static godot::VisibleOnScreenEnabler3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VisibleOnScreenEnabler3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VisibleOnScreenEnabler3D &v) noexcept {
		return Value{ ctx, std::forward<godot::VisibleOnScreenEnabler3D>(v) };
	}
};
template <>
struct js_traits<godot::VisibleOnScreenNotifier2D> {
	/// @throws exception
	static godot::VisibleOnScreenNotifier2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VisibleOnScreenNotifier2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VisibleOnScreenNotifier2D v) noexcept {
		return Value{ ctx, std::forward<godot::VisibleOnScreenNotifier2D>(v) };
	}
};
template <>
struct js_traits<godot::VisibleOnScreenNotifier2D &> {
	/// @throws exception
	static godot::VisibleOnScreenNotifier2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VisibleOnScreenNotifier2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VisibleOnScreenNotifier2D &v) noexcept {
		return Value{ ctx, std::forward<godot::VisibleOnScreenNotifier2D>(v) };
	}
};
template <>
struct js_traits<godot::VisibleOnScreenNotifier3D> {
	/// @throws exception
	static godot::VisibleOnScreenNotifier3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VisibleOnScreenNotifier3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VisibleOnScreenNotifier3D v) noexcept {
		return Value{ ctx, std::forward<godot::VisibleOnScreenNotifier3D>(v) };
	}
};
template <>
struct js_traits<godot::VisibleOnScreenNotifier3D &> {
	/// @throws exception
	static godot::VisibleOnScreenNotifier3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VisibleOnScreenNotifier3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VisibleOnScreenNotifier3D &v) noexcept {
		return Value{ ctx, std::forward<godot::VisibleOnScreenNotifier3D>(v) };
	}
};
template <>
struct js_traits<godot::VisualInstance3D> {
	/// @throws exception
	static godot::VisualInstance3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VisualInstance3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VisualInstance3D v) noexcept {
		return Value{ ctx, std::forward<godot::VisualInstance3D>(v) };
	}
};
template <>
struct js_traits<godot::VisualInstance3D &> {
	/// @throws exception
	static godot::VisualInstance3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VisualInstance3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VisualInstance3D &v) noexcept {
		return Value{ ctx, std::forward<godot::VisualInstance3D>(v) };
	}
};
template <>
struct js_traits<godot::VisualShader> {
	/// @throws exception
	static godot::VisualShader unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VisualShader *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VisualShader v) noexcept {
		return Value{ ctx, std::forward<godot::VisualShader>(v) };
	}
};
template <>
struct js_traits<godot::VisualShader &> {
	/// @throws exception
	static godot::VisualShader &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VisualShader *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VisualShader &v) noexcept {
		return Value{ ctx, std::forward<godot::VisualShader>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::VisualShader>> {
	/// @throws exception
	static godot::Ref<godot::VisualShader> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::VisualShader>((godot::VisualShader *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::VisualShader> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::VisualShader>>(v) };
	}
};
template <>
struct js_traits<godot::VoxelGI> {
	/// @throws exception
	static godot::VoxelGI unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VoxelGI *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VoxelGI v) noexcept {
		return Value{ ctx, std::forward<godot::VoxelGI>(v) };
	}
};
template <>
struct js_traits<godot::VoxelGI &> {
	/// @throws exception
	static godot::VoxelGI &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VoxelGI *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VoxelGI &v) noexcept {
		return Value{ ctx, std::forward<godot::VoxelGI>(v) };
	}
};
template <>
struct js_traits<godot::VoxelGIData> {
	/// @throws exception
	static godot::VoxelGIData unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VoxelGIData *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VoxelGIData v) noexcept {
		return Value{ ctx, std::forward<godot::VoxelGIData>(v) };
	}
};
template <>
struct js_traits<godot::VoxelGIData &> {
	/// @throws exception
	static godot::VoxelGIData &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::VoxelGIData *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::VoxelGIData &v) noexcept {
		return Value{ ctx, std::forward<godot::VoxelGIData>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::VoxelGIData>> {
	/// @throws exception
	static godot::Ref<godot::VoxelGIData> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::VoxelGIData>((godot::VoxelGIData *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::VoxelGIData> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::VoxelGIData>>(v) };
	}
};
template <>
struct js_traits<godot::WeakRef> {
	/// @throws exception
	static godot::WeakRef unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::WeakRef *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::WeakRef v) noexcept {
		return Value{ ctx, std::forward<godot::WeakRef>(v) };
	}
};
template <>
struct js_traits<godot::WeakRef &> {
	/// @throws exception
	static godot::WeakRef &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::WeakRef *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::WeakRef &v) noexcept {
		return Value{ ctx, std::forward<godot::WeakRef>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::WeakRef>> {
	/// @throws exception
	static godot::Ref<godot::WeakRef> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::WeakRef>((godot::WeakRef *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::WeakRef> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::WeakRef>>(v) };
	}
};
template <>
struct js_traits<godot::WebRTCDataChannel> {
	/// @throws exception
	static godot::WebRTCDataChannel unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::WebRTCDataChannel *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::WebRTCDataChannel v) noexcept {
		return Value{ ctx, std::forward<godot::WebRTCDataChannel>(v) };
	}
};
template <>
struct js_traits<godot::WebRTCDataChannel &> {
	/// @throws exception
	static godot::WebRTCDataChannel &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::WebRTCDataChannel *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::WebRTCDataChannel &v) noexcept {
		return Value{ ctx, std::forward<godot::WebRTCDataChannel>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::WebRTCDataChannel>> {
	/// @throws exception
	static godot::Ref<godot::WebRTCDataChannel> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::WebRTCDataChannel>((godot::WebRTCDataChannel *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::WebRTCDataChannel> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::WebRTCDataChannel>>(v) };
	}
};
template <>
struct js_traits<godot::WebRTCDataChannelExtension> {
	/// @throws exception
	static godot::WebRTCDataChannelExtension unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::WebRTCDataChannelExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::WebRTCDataChannelExtension v) noexcept {
		return Value{ ctx, std::forward<godot::WebRTCDataChannelExtension>(v) };
	}
};
template <>
struct js_traits<godot::WebRTCDataChannelExtension &> {
	/// @throws exception
	static godot::WebRTCDataChannelExtension &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::WebRTCDataChannelExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::WebRTCDataChannelExtension &v) noexcept {
		return Value{ ctx, std::forward<godot::WebRTCDataChannelExtension>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::WebRTCDataChannelExtension>> {
	/// @throws exception
	static godot::Ref<godot::WebRTCDataChannelExtension> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::WebRTCDataChannelExtension>((godot::WebRTCDataChannelExtension *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::WebRTCDataChannelExtension> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::WebRTCDataChannelExtension>>(v) };
	}
};
template <>
struct js_traits<godot::WebRTCMultiplayerPeer> {
	/// @throws exception
	static godot::WebRTCMultiplayerPeer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::WebRTCMultiplayerPeer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::WebRTCMultiplayerPeer v) noexcept {
		return Value{ ctx, std::forward<godot::WebRTCMultiplayerPeer>(v) };
	}
};
template <>
struct js_traits<godot::WebRTCMultiplayerPeer &> {
	/// @throws exception
	static godot::WebRTCMultiplayerPeer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::WebRTCMultiplayerPeer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::WebRTCMultiplayerPeer &v) noexcept {
		return Value{ ctx, std::forward<godot::WebRTCMultiplayerPeer>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::WebRTCMultiplayerPeer>> {
	/// @throws exception
	static godot::Ref<godot::WebRTCMultiplayerPeer> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::WebRTCMultiplayerPeer>((godot::WebRTCMultiplayerPeer *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::WebRTCMultiplayerPeer> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::WebRTCMultiplayerPeer>>(v) };
	}
};
template <>
struct js_traits<godot::WebRTCPeerConnection> {
	/// @throws exception
	static godot::WebRTCPeerConnection unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::WebRTCPeerConnection *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::WebRTCPeerConnection v) noexcept {
		return Value{ ctx, std::forward<godot::WebRTCPeerConnection>(v) };
	}
};
template <>
struct js_traits<godot::WebRTCPeerConnection &> {
	/// @throws exception
	static godot::WebRTCPeerConnection &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::WebRTCPeerConnection *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::WebRTCPeerConnection &v) noexcept {
		return Value{ ctx, std::forward<godot::WebRTCPeerConnection>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::WebRTCPeerConnection>> {
	/// @throws exception
	static godot::Ref<godot::WebRTCPeerConnection> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::WebRTCPeerConnection>((godot::WebRTCPeerConnection *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::WebRTCPeerConnection> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::WebRTCPeerConnection>>(v) };
	}
};
template <>
struct js_traits<godot::WebRTCPeerConnectionExtension> {
	/// @throws exception
	static godot::WebRTCPeerConnectionExtension unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::WebRTCPeerConnectionExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::WebRTCPeerConnectionExtension v) noexcept {
		return Value{ ctx, std::forward<godot::WebRTCPeerConnectionExtension>(v) };
	}
};
template <>
struct js_traits<godot::WebRTCPeerConnectionExtension &> {
	/// @throws exception
	static godot::WebRTCPeerConnectionExtension &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::WebRTCPeerConnectionExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::WebRTCPeerConnectionExtension &v) noexcept {
		return Value{ ctx, std::forward<godot::WebRTCPeerConnectionExtension>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::WebRTCPeerConnectionExtension>> {
	/// @throws exception
	static godot::Ref<godot::WebRTCPeerConnectionExtension> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::WebRTCPeerConnectionExtension>((godot::WebRTCPeerConnectionExtension *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::WebRTCPeerConnectionExtension> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::WebRTCPeerConnectionExtension>>(v) };
	}
};
template <>
struct js_traits<godot::WebSocketMultiplayerPeer> {
	/// @throws exception
	static godot::WebSocketMultiplayerPeer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::WebSocketMultiplayerPeer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::WebSocketMultiplayerPeer v) noexcept {
		return Value{ ctx, std::forward<godot::WebSocketMultiplayerPeer>(v) };
	}
};
template <>
struct js_traits<godot::WebSocketMultiplayerPeer &> {
	/// @throws exception
	static godot::WebSocketMultiplayerPeer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::WebSocketMultiplayerPeer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::WebSocketMultiplayerPeer &v) noexcept {
		return Value{ ctx, std::forward<godot::WebSocketMultiplayerPeer>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::WebSocketMultiplayerPeer>> {
	/// @throws exception
	static godot::Ref<godot::WebSocketMultiplayerPeer> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::WebSocketMultiplayerPeer>((godot::WebSocketMultiplayerPeer *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::WebSocketMultiplayerPeer> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::WebSocketMultiplayerPeer>>(v) };
	}
};
template <>
struct js_traits<godot::WebSocketPeer> {
	/// @throws exception
	static godot::WebSocketPeer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::WebSocketPeer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::WebSocketPeer v) noexcept {
		return Value{ ctx, std::forward<godot::WebSocketPeer>(v) };
	}
};
template <>
struct js_traits<godot::WebSocketPeer &> {
	/// @throws exception
	static godot::WebSocketPeer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::WebSocketPeer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::WebSocketPeer &v) noexcept {
		return Value{ ctx, std::forward<godot::WebSocketPeer>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::WebSocketPeer>> {
	/// @throws exception
	static godot::Ref<godot::WebSocketPeer> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::WebSocketPeer>((godot::WebSocketPeer *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::WebSocketPeer> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::WebSocketPeer>>(v) };
	}
};
template <>
struct js_traits<godot::WebXRInterface> {
	/// @throws exception
	static godot::WebXRInterface unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::WebXRInterface *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::WebXRInterface v) noexcept {
		return Value{ ctx, std::forward<godot::WebXRInterface>(v) };
	}
};
template <>
struct js_traits<godot::WebXRInterface &> {
	/// @throws exception
	static godot::WebXRInterface &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::WebXRInterface *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::WebXRInterface &v) noexcept {
		return Value{ ctx, std::forward<godot::WebXRInterface>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::WebXRInterface>> {
	/// @throws exception
	static godot::Ref<godot::WebXRInterface> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::WebXRInterface>((godot::WebXRInterface *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::WebXRInterface> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::WebXRInterface>>(v) };
	}
};
template <>
struct js_traits<godot::Window> {
	/// @throws exception
	static godot::Window unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Window *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Window v) noexcept {
		return Value{ ctx, std::forward<godot::Window>(v) };
	}
};
template <>
struct js_traits<godot::Window &> {
	/// @throws exception
	static godot::Window &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Window *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Window &v) noexcept {
		return Value{ ctx, std::forward<godot::Window>(v) };
	}
};
template <>
struct js_traits<godot::WorkerThreadPool> {
	/// @throws exception
	static godot::WorkerThreadPool unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::WorkerThreadPool *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::WorkerThreadPool v) noexcept {
		return Value{ ctx, std::forward<godot::WorkerThreadPool>(v) };
	}
};
template <>
struct js_traits<godot::WorkerThreadPool &> {
	/// @throws exception
	static godot::WorkerThreadPool &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::WorkerThreadPool *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::WorkerThreadPool &v) noexcept {
		return Value{ ctx, std::forward<godot::WorkerThreadPool>(v) };
	}
};
template <>
struct js_traits<godot::World2D> {
	/// @throws exception
	static godot::World2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::World2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::World2D v) noexcept {
		return Value{ ctx, std::forward<godot::World2D>(v) };
	}
};
template <>
struct js_traits<godot::World2D &> {
	/// @throws exception
	static godot::World2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::World2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::World2D &v) noexcept {
		return Value{ ctx, std::forward<godot::World2D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::World2D>> {
	/// @throws exception
	static godot::Ref<godot::World2D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::World2D>((godot::World2D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::World2D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::World2D>>(v) };
	}
};
template <>
struct js_traits<godot::World3D> {
	/// @throws exception
	static godot::World3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::World3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::World3D v) noexcept {
		return Value{ ctx, std::forward<godot::World3D>(v) };
	}
};
template <>
struct js_traits<godot::World3D &> {
	/// @throws exception
	static godot::World3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::World3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::World3D &v) noexcept {
		return Value{ ctx, std::forward<godot::World3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::World3D>> {
	/// @throws exception
	static godot::Ref<godot::World3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::World3D>((godot::World3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::World3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::World3D>>(v) };
	}
};
template <>
struct js_traits<godot::WorldBoundaryShape2D> {
	/// @throws exception
	static godot::WorldBoundaryShape2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::WorldBoundaryShape2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::WorldBoundaryShape2D v) noexcept {
		return Value{ ctx, std::forward<godot::WorldBoundaryShape2D>(v) };
	}
};
template <>
struct js_traits<godot::WorldBoundaryShape2D &> {
	/// @throws exception
	static godot::WorldBoundaryShape2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::WorldBoundaryShape2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::WorldBoundaryShape2D &v) noexcept {
		return Value{ ctx, std::forward<godot::WorldBoundaryShape2D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::WorldBoundaryShape2D>> {
	/// @throws exception
	static godot::Ref<godot::WorldBoundaryShape2D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::WorldBoundaryShape2D>((godot::WorldBoundaryShape2D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::WorldBoundaryShape2D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::WorldBoundaryShape2D>>(v) };
	}
};
template <>
struct js_traits<godot::WorldBoundaryShape3D> {
	/// @throws exception
	static godot::WorldBoundaryShape3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::WorldBoundaryShape3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::WorldBoundaryShape3D v) noexcept {
		return Value{ ctx, std::forward<godot::WorldBoundaryShape3D>(v) };
	}
};
template <>
struct js_traits<godot::WorldBoundaryShape3D &> {
	/// @throws exception
	static godot::WorldBoundaryShape3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::WorldBoundaryShape3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::WorldBoundaryShape3D &v) noexcept {
		return Value{ ctx, std::forward<godot::WorldBoundaryShape3D>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::WorldBoundaryShape3D>> {
	/// @throws exception
	static godot::Ref<godot::WorldBoundaryShape3D> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::WorldBoundaryShape3D>((godot::WorldBoundaryShape3D *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::WorldBoundaryShape3D> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::WorldBoundaryShape3D>>(v) };
	}
};
template <>
struct js_traits<godot::WorldEnvironment> {
	/// @throws exception
	static godot::WorldEnvironment unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::WorldEnvironment *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::WorldEnvironment v) noexcept {
		return Value{ ctx, std::forward<godot::WorldEnvironment>(v) };
	}
};
template <>
struct js_traits<godot::WorldEnvironment &> {
	/// @throws exception
	static godot::WorldEnvironment &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::WorldEnvironment *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::WorldEnvironment &v) noexcept {
		return Value{ ctx, std::forward<godot::WorldEnvironment>(v) };
	}
};
template <>
struct js_traits<godot::X509Certificate> {
	/// @throws exception
	static godot::X509Certificate unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::X509Certificate *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::X509Certificate v) noexcept {
		return Value{ ctx, std::forward<godot::X509Certificate>(v) };
	}
};
template <>
struct js_traits<godot::X509Certificate &> {
	/// @throws exception
	static godot::X509Certificate &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::X509Certificate *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::X509Certificate &v) noexcept {
		return Value{ ctx, std::forward<godot::X509Certificate>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::X509Certificate>> {
	/// @throws exception
	static godot::Ref<godot::X509Certificate> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::X509Certificate>((godot::X509Certificate *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::X509Certificate> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::X509Certificate>>(v) };
	}
};
template <>
struct js_traits<godot::XMLParser> {
	/// @throws exception
	static godot::XMLParser unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::XMLParser *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::XMLParser v) noexcept {
		return Value{ ctx, std::forward<godot::XMLParser>(v) };
	}
};
template <>
struct js_traits<godot::XMLParser &> {
	/// @throws exception
	static godot::XMLParser &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::XMLParser *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::XMLParser &v) noexcept {
		return Value{ ctx, std::forward<godot::XMLParser>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::XMLParser>> {
	/// @throws exception
	static godot::Ref<godot::XMLParser> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::XMLParser>((godot::XMLParser *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::XMLParser> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::XMLParser>>(v) };
	}
};
template <>
struct js_traits<godot::XRAnchor3D> {
	/// @throws exception
	static godot::XRAnchor3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::XRAnchor3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::XRAnchor3D v) noexcept {
		return Value{ ctx, std::forward<godot::XRAnchor3D>(v) };
	}
};
template <>
struct js_traits<godot::XRAnchor3D &> {
	/// @throws exception
	static godot::XRAnchor3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::XRAnchor3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::XRAnchor3D &v) noexcept {
		return Value{ ctx, std::forward<godot::XRAnchor3D>(v) };
	}
};
template <>
struct js_traits<godot::XRCamera3D> {
	/// @throws exception
	static godot::XRCamera3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::XRCamera3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::XRCamera3D v) noexcept {
		return Value{ ctx, std::forward<godot::XRCamera3D>(v) };
	}
};
template <>
struct js_traits<godot::XRCamera3D &> {
	/// @throws exception
	static godot::XRCamera3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::XRCamera3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::XRCamera3D &v) noexcept {
		return Value{ ctx, std::forward<godot::XRCamera3D>(v) };
	}
};
template <>
struct js_traits<godot::XRController3D> {
	/// @throws exception
	static godot::XRController3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::XRController3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::XRController3D v) noexcept {
		return Value{ ctx, std::forward<godot::XRController3D>(v) };
	}
};
template <>
struct js_traits<godot::XRController3D &> {
	/// @throws exception
	static godot::XRController3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::XRController3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::XRController3D &v) noexcept {
		return Value{ ctx, std::forward<godot::XRController3D>(v) };
	}
};
template <>
struct js_traits<godot::XRInterface> {
	/// @throws exception
	static godot::XRInterface unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::XRInterface *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::XRInterface v) noexcept {
		return Value{ ctx, std::forward<godot::XRInterface>(v) };
	}
};
template <>
struct js_traits<godot::XRInterface &> {
	/// @throws exception
	static godot::XRInterface &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::XRInterface *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::XRInterface &v) noexcept {
		return Value{ ctx, std::forward<godot::XRInterface>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::XRInterface>> {
	/// @throws exception
	static godot::Ref<godot::XRInterface> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::XRInterface>((godot::XRInterface *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::XRInterface> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::XRInterface>>(v) };
	}
};
template <>
struct js_traits<godot::XRInterfaceExtension> {
	/// @throws exception
	static godot::XRInterfaceExtension unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::XRInterfaceExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::XRInterfaceExtension v) noexcept {
		return Value{ ctx, std::forward<godot::XRInterfaceExtension>(v) };
	}
};
template <>
struct js_traits<godot::XRInterfaceExtension &> {
	/// @throws exception
	static godot::XRInterfaceExtension &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::XRInterfaceExtension *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::XRInterfaceExtension &v) noexcept {
		return Value{ ctx, std::forward<godot::XRInterfaceExtension>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::XRInterfaceExtension>> {
	/// @throws exception
	static godot::Ref<godot::XRInterfaceExtension> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::XRInterfaceExtension>((godot::XRInterfaceExtension *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::XRInterfaceExtension> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::XRInterfaceExtension>>(v) };
	}
};
template <>
struct js_traits<godot::XRNode3D> {
	/// @throws exception
	static godot::XRNode3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::XRNode3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::XRNode3D v) noexcept {
		return Value{ ctx, std::forward<godot::XRNode3D>(v) };
	}
};
template <>
struct js_traits<godot::XRNode3D &> {
	/// @throws exception
	static godot::XRNode3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::XRNode3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::XRNode3D &v) noexcept {
		return Value{ ctx, std::forward<godot::XRNode3D>(v) };
	}
};
template <>
struct js_traits<godot::XROrigin3D> {
	/// @throws exception
	static godot::XROrigin3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::XROrigin3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::XROrigin3D v) noexcept {
		return Value{ ctx, std::forward<godot::XROrigin3D>(v) };
	}
};
template <>
struct js_traits<godot::XROrigin3D &> {
	/// @throws exception
	static godot::XROrigin3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::XROrigin3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::XROrigin3D &v) noexcept {
		return Value{ ctx, std::forward<godot::XROrigin3D>(v) };
	}
};
template <>
struct js_traits<godot::XRPose> {
	/// @throws exception
	static godot::XRPose unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::XRPose *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::XRPose v) noexcept {
		return Value{ ctx, std::forward<godot::XRPose>(v) };
	}
};
template <>
struct js_traits<godot::XRPose &> {
	/// @throws exception
	static godot::XRPose &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::XRPose *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::XRPose &v) noexcept {
		return Value{ ctx, std::forward<godot::XRPose>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::XRPose>> {
	/// @throws exception
	static godot::Ref<godot::XRPose> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::XRPose>((godot::XRPose *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::XRPose> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::XRPose>>(v) };
	}
};
template <>
struct js_traits<godot::XRPositionalTracker> {
	/// @throws exception
	static godot::XRPositionalTracker unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::XRPositionalTracker *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::XRPositionalTracker v) noexcept {
		return Value{ ctx, std::forward<godot::XRPositionalTracker>(v) };
	}
};
template <>
struct js_traits<godot::XRPositionalTracker &> {
	/// @throws exception
	static godot::XRPositionalTracker &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::XRPositionalTracker *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::XRPositionalTracker &v) noexcept {
		return Value{ ctx, std::forward<godot::XRPositionalTracker>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::XRPositionalTracker>> {
	/// @throws exception
	static godot::Ref<godot::XRPositionalTracker> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::XRPositionalTracker>((godot::XRPositionalTracker *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::XRPositionalTracker> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::XRPositionalTracker>>(v) };
	}
};
template <>
struct js_traits<godot::XRServer> {
	/// @throws exception
	static godot::XRServer unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::XRServer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::XRServer v) noexcept {
		return Value{ ctx, std::forward<godot::XRServer>(v) };
	}
};
template <>
struct js_traits<godot::XRServer &> {
	/// @throws exception
	static godot::XRServer &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::XRServer *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::XRServer &v) noexcept {
		return Value{ ctx, std::forward<godot::XRServer>(v) };
	}
};
template <>
struct js_traits<godot::ZIPPacker> {
	/// @throws exception
	static godot::ZIPPacker unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ZIPPacker *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ZIPPacker v) noexcept {
		return Value{ ctx, std::forward<godot::ZIPPacker>(v) };
	}
};
template <>
struct js_traits<godot::ZIPPacker &> {
	/// @throws exception
	static godot::ZIPPacker &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ZIPPacker *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ZIPPacker &v) noexcept {
		return Value{ ctx, std::forward<godot::ZIPPacker>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ZIPPacker>> {
	/// @throws exception
	static godot::Ref<godot::ZIPPacker> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ZIPPacker>((godot::ZIPPacker *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ZIPPacker> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ZIPPacker>>(v) };
	}
};
template <>
struct js_traits<godot::ZIPReader> {
	/// @throws exception
	static godot::ZIPReader unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ZIPReader *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ZIPReader v) noexcept {
		return Value{ ctx, std::forward<godot::ZIPReader>(v) };
	}
};
template <>
struct js_traits<godot::ZIPReader &> {
	/// @throws exception
	static godot::ZIPReader &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::ZIPReader *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::ZIPReader &v) noexcept {
		return Value{ ctx, std::forward<godot::ZIPReader>(v) };
	}
};
template <>
struct js_traits<godot::Ref<godot::ZIPReader>> {
	/// @throws exception
	static godot::Ref<godot::ZIPReader> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return godot::Ref<godot::ZIPReader>((godot::ZIPReader *)ptr);
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Ref<godot::ZIPReader> v) noexcept {
		return Value{ ctx, std::forward<godot::Ref<godot::ZIPReader>>(v) };
	}
};

template <>
struct js_traits<godot::RID> {
	/// @throws exception
	static godot::RID unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RID *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RID rid) noexcept {
		return Value{ ctx, std::forward<godot::RID>(rid) };
	}
};

template <>
struct js_traits<godot::RID &> {
	/// @throws exception
	static godot::RID &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::RID *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::RID &v) noexcept {
		return Value{ ctx, std::forward<godot::RID &>(v) };
	}
};
template <>
struct js_traits<godot::Callable> {
	/// @throws exception
	static godot::Callable unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Callable *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Callable rid) noexcept {
		return Value{ ctx, std::forward<godot::Callable>(rid) };
	}
};

template <>
struct js_traits<godot::Callable &> {
	/// @throws exception
	static godot::Callable &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Callable *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Callable &v) noexcept {
		return Value{ ctx, std::forward<godot::Callable &>(v) };
	}
};
template <>
struct js_traits<godot::String> {
	/// @throws exception
	static godot::String unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::String *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::String rid) noexcept {
		return Value{ ctx, std::forward<godot::String>(rid) };
	}
};

template <>
struct js_traits<godot::String &> {
	/// @throws exception
	static godot::String &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::String *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::String &v) noexcept {
		return Value{ ctx, std::forward<godot::String &>(v) };
	}
};
template <>
struct js_traits<godot::Vector2> {
	/// @throws exception
	static godot::Vector2 unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Vector2 *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Vector2 rid) noexcept {
		return Value{ ctx, std::forward<godot::Vector2>(rid) };
	}
};

template <>
struct js_traits<godot::Vector2 &> {
	/// @throws exception
	static godot::Vector2 &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Vector2 *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Vector2 &v) noexcept {
		return Value{ ctx, std::forward<godot::Vector2 &>(v) };
	}
};
template <>
struct js_traits<godot::Vector2i> {
	/// @throws exception
	static godot::Vector2i unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Vector2i *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Vector2i rid) noexcept {
		return Value{ ctx, std::forward<godot::Vector2i>(rid) };
	}
};

template <>
struct js_traits<godot::Vector2i &> {
	/// @throws exception
	static godot::Vector2i &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Vector2i *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Vector2i &v) noexcept {
		return Value{ ctx, std::forward<godot::Vector2i &>(v) };
	}
};
template <>
struct js_traits<godot::Rect2> {
	/// @throws exception
	static godot::Rect2 unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Rect2 *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Rect2 rid) noexcept {
		return Value{ ctx, std::forward<godot::Rect2>(rid) };
	}
};

template <>
struct js_traits<godot::Rect2 &> {
	/// @throws exception
	static godot::Rect2 &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Rect2 *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Rect2 &v) noexcept {
		return Value{ ctx, std::forward<godot::Rect2 &>(v) };
	}
};
template <>
struct js_traits<godot::Rect2i> {
	/// @throws exception
	static godot::Rect2i unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Rect2i *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Rect2i rid) noexcept {
		return Value{ ctx, std::forward<godot::Rect2i>(rid) };
	}
};

template <>
struct js_traits<godot::Rect2i &> {
	/// @throws exception
	static godot::Rect2i &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Rect2i *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Rect2i &v) noexcept {
		return Value{ ctx, std::forward<godot::Rect2i &>(v) };
	}
};
template <>
struct js_traits<godot::Vector3> {
	/// @throws exception
	static godot::Vector3 unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Vector3 *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Vector3 rid) noexcept {
		return Value{ ctx, std::forward<godot::Vector3>(rid) };
	}
};

template <>
struct js_traits<godot::Vector3 &> {
	/// @throws exception
	static godot::Vector3 &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Vector3 *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Vector3 &v) noexcept {
		return Value{ ctx, std::forward<godot::Vector3 &>(v) };
	}
};
template <>
struct js_traits<godot::Vector3i> {
	/// @throws exception
	static godot::Vector3i unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Vector3i *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Vector3i rid) noexcept {
		return Value{ ctx, std::forward<godot::Vector3i>(rid) };
	}
};

template <>
struct js_traits<godot::Vector3i &> {
	/// @throws exception
	static godot::Vector3i &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Vector3i *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Vector3i &v) noexcept {
		return Value{ ctx, std::forward<godot::Vector3i &>(v) };
	}
};
template <>
struct js_traits<godot::Transform2D> {
	/// @throws exception
	static godot::Transform2D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Transform2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Transform2D rid) noexcept {
		return Value{ ctx, std::forward<godot::Transform2D>(rid) };
	}
};

template <>
struct js_traits<godot::Transform2D &> {
	/// @throws exception
	static godot::Transform2D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Transform2D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Transform2D &v) noexcept {
		return Value{ ctx, std::forward<godot::Transform2D &>(v) };
	}
};
template <>
struct js_traits<godot::Vector4> {
	/// @throws exception
	static godot::Vector4 unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Vector4 *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Vector4 rid) noexcept {
		return Value{ ctx, std::forward<godot::Vector4>(rid) };
	}
};

template <>
struct js_traits<godot::Vector4 &> {
	/// @throws exception
	static godot::Vector4 &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Vector4 *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Vector4 &v) noexcept {
		return Value{ ctx, std::forward<godot::Vector4 &>(v) };
	}
};
template <>
struct js_traits<godot::Vector4i> {
	/// @throws exception
	static godot::Vector4i unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Vector4i *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Vector4i rid) noexcept {
		return Value{ ctx, std::forward<godot::Vector4i>(rid) };
	}
};

template <>
struct js_traits<godot::Vector4i &> {
	/// @throws exception
	static godot::Vector4i &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Vector4i *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Vector4i &v) noexcept {
		return Value{ ctx, std::forward<godot::Vector4i &>(v) };
	}
};
template <>
struct js_traits<godot::Plane> {
	/// @throws exception
	static godot::Plane unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Plane *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Plane rid) noexcept {
		return Value{ ctx, std::forward<godot::Plane>(rid) };
	}
};

template <>
struct js_traits<godot::Plane &> {
	/// @throws exception
	static godot::Plane &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Plane *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Plane &v) noexcept {
		return Value{ ctx, std::forward<godot::Plane &>(v) };
	}
};
template <>
struct js_traits<godot::Quaternion> {
	/// @throws exception
	static godot::Quaternion unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Quaternion *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Quaternion rid) noexcept {
		return Value{ ctx, std::forward<godot::Quaternion>(rid) };
	}
};

template <>
struct js_traits<godot::Quaternion &> {
	/// @throws exception
	static godot::Quaternion &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Quaternion *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Quaternion &v) noexcept {
		return Value{ ctx, std::forward<godot::Quaternion &>(v) };
	}
};
template <>
struct js_traits<godot::AABB> {
	/// @throws exception
	static godot::AABB unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AABB *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AABB rid) noexcept {
		return Value{ ctx, std::forward<godot::AABB>(rid) };
	}
};

template <>
struct js_traits<godot::AABB &> {
	/// @throws exception
	static godot::AABB &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::AABB *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::AABB &v) noexcept {
		return Value{ ctx, std::forward<godot::AABB &>(v) };
	}
};
template <>
struct js_traits<godot::Basis> {
	/// @throws exception
	static godot::Basis unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Basis *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Basis rid) noexcept {
		return Value{ ctx, std::forward<godot::Basis>(rid) };
	}
};

template <>
struct js_traits<godot::Basis &> {
	/// @throws exception
	static godot::Basis &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Basis *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Basis &v) noexcept {
		return Value{ ctx, std::forward<godot::Basis &>(v) };
	}
};
template <>
struct js_traits<godot::Transform3D> {
	/// @throws exception
	static godot::Transform3D unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Transform3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Transform3D rid) noexcept {
		return Value{ ctx, std::forward<godot::Transform3D>(rid) };
	}
};

template <>
struct js_traits<godot::Transform3D &> {
	/// @throws exception
	static godot::Transform3D &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Transform3D *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Transform3D &v) noexcept {
		return Value{ ctx, std::forward<godot::Transform3D &>(v) };
	}
};
template <>
struct js_traits<godot::Projection> {
	/// @throws exception
	static godot::Projection unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Projection *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Projection rid) noexcept {
		return Value{ ctx, std::forward<godot::Projection>(rid) };
	}
};

template <>
struct js_traits<godot::Projection &> {
	/// @throws exception
	static godot::Projection &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Projection *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Projection &v) noexcept {
		return Value{ ctx, std::forward<godot::Projection &>(v) };
	}
};
template <>
struct js_traits<godot::Color> {
	/// @throws exception
	static godot::Color unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Color *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Color rid) noexcept {
		return Value{ ctx, std::forward<godot::Color>(rid) };
	}
};

template <>
struct js_traits<godot::Color &> {
	/// @throws exception
	static godot::Color &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Color *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Color &v) noexcept {
		return Value{ ctx, std::forward<godot::Color &>(v) };
	}
};
template <>
struct js_traits<godot::StringName> {
	/// @throws exception
	static godot::StringName unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::StringName *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::StringName rid) noexcept {
		return Value{ ctx, std::forward<godot::StringName>(rid) };
	}
};

template <>
struct js_traits<godot::StringName &> {
	/// @throws exception
	static godot::StringName &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::StringName *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::StringName &v) noexcept {
		return Value{ ctx, std::forward<godot::StringName &>(v) };
	}
};
template <>
struct js_traits<godot::NodePath> {
	/// @throws exception
	static godot::NodePath unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NodePath *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NodePath rid) noexcept {
		return Value{ ctx, std::forward<godot::NodePath>(rid) };
	}
};

template <>
struct js_traits<godot::NodePath &> {
	/// @throws exception
	static godot::NodePath &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::NodePath *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::NodePath &v) noexcept {
		return Value{ ctx, std::forward<godot::NodePath &>(v) };
	}
};
template <>
struct js_traits<godot::Signal> {
	/// @throws exception
	static godot::Signal unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Signal *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Signal rid) noexcept {
		return Value{ ctx, std::forward<godot::Signal>(rid) };
	}
};

template <>
struct js_traits<godot::Signal &> {
	/// @throws exception
	static godot::Signal &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Signal *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Signal &v) noexcept {
		return Value{ ctx, std::forward<godot::Signal &>(v) };
	}
};
template <>
struct js_traits<godot::Dictionary> {
	/// @throws exception
	static godot::Dictionary unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Dictionary *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Dictionary rid) noexcept {
		return Value{ ctx, std::forward<godot::Dictionary>(rid) };
	}
};

template <>
struct js_traits<godot::Dictionary &> {
	/// @throws exception
	static godot::Dictionary &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::Dictionary *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Dictionary &v) noexcept {
		return Value{ ctx, std::forward<godot::Dictionary &>(v) };
	}
};
template <>
struct js_traits<godot::Array> {
	/// @throws exception
	static godot::Array unwrap(JSContext *ctx, JSValueConst v) {
		godot::Array gd_arr;
		if (JS_IsArray(ctx, v)) {
			Value jsarray{ ctx, JS_DupValue(ctx, v) };
			for (uint32_t i = 0; i < static_cast<uint32_t>(jsarray["length"]); i++) {
				gd_arr.append(godot::Variant(jsarray[i]));
			}
			return gd_arr;
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::Array gd_arr) noexcept {
		JSValue buff = JS_NewArrayBuffer(ctx, (uint8_t *)gd_arr._native_ptr(), gd_arr.size(), nullptr, nullptr, false);
		JSValue js_arr = JS_NewArray(ctx);
		for (int i = 0; i < gd_arr.size(); i++) {
			JS_SetPropertyUint32(ctx, js_arr, i, JS_GetPropertyUint32(ctx, buff, i));
		}
		return js_arr;
	}
};

template <>
struct js_traits<godot::PackedByteArray> {
	/// @throws exception
	static godot::PackedByteArray unwrap(JSContext *ctx, JSValueConst v) {
		godot::PackedByteArray gd_arr;
		if (JS_IsArray(ctx, v) || JS_IsArrayInt8(ctx, v)) {
			Value jsarray{ ctx, JS_DupValue(ctx, v) };
			for (int32_t i = 0; i < static_cast<uint32_t>(jsarray["length"]); i++) {
				gd_arr.append(static_cast<int8_t>(jsarray[i]));
			}
			return gd_arr;
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PackedByteArray gd_arr) noexcept {
		JSValue buff = JS_NewArrayBuffer(ctx, (uint8_t *)gd_arr._native_ptr(), gd_arr.size(), nullptr, nullptr, false);
		JSValue js_arr = JS_NewTypedArray(ctx, gd_arr.size(), &buff, JSTypedArrayEnum::JS_TYPED_ARRAY_INT8);
		return js_arr;
	}
};
template <>
struct js_traits<godot::PackedInt32Array> {
	/// @throws exception
	static godot::PackedInt32Array unwrap(JSContext *ctx, JSValueConst v) {
		godot::PackedInt32Array gd_arr;
		if (JS_IsArray(ctx, v) || JS_IsArrayInt8(ctx, v)) {
			Value jsarray{ ctx, JS_DupValue(ctx, v) };
			for (int32_t i = 0; i < static_cast<uint32_t>(jsarray["length"]); i++) {
				gd_arr.append(static_cast<int32_t>(jsarray[i]));
			}
			return gd_arr;
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PackedInt32Array gd_arr) noexcept {
		JSValue buff = JS_NewArrayBuffer(ctx, (uint8_t *)gd_arr._native_ptr(), gd_arr.size(), nullptr, nullptr, false);
		JSValue js_arr = JS_NewTypedArray(ctx, gd_arr.size(), &buff, JSTypedArrayEnum::JS_TYPED_ARRAY_INT32);
		return js_arr;
	}
};
template <>
struct js_traits<godot::PackedInt64Array> {
	/// @throws exception
	static godot::PackedInt64Array unwrap(JSContext *ctx, JSValueConst v) {
		godot::PackedInt64Array gd_arr;
		if (JS_IsArray(ctx, v) || JS_IsArrayInt8(ctx, v)) {
			Value jsarray{ ctx, JS_DupValue(ctx, v) };
			for (int32_t i = 0; i < static_cast<uint32_t>(jsarray["length"]); i++) {
				gd_arr.append(static_cast<int64_t>(jsarray[i]));
			}
			return gd_arr;
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PackedInt64Array gd_arr) noexcept {
		JSValue buff = JS_NewArrayBuffer(ctx, (uint8_t *)gd_arr._native_ptr(), gd_arr.size(), nullptr, nullptr, false);
		JSValue js_arr = JS_NewTypedArray(ctx, gd_arr.size(), &buff, JSTypedArrayEnum::JS_TYPED_ARRAY_BIG_INT64);
		return js_arr;
	}
};
template <>
struct js_traits<godot::PackedFloat32Array> {
	/// @throws exception
	static godot::PackedFloat32Array unwrap(JSContext *ctx, JSValueConst v) {
		godot::PackedFloat32Array gd_arr;
		if (JS_IsArray(ctx, v) || JS_IsArrayInt8(ctx, v)) {
			Value jsarray{ ctx, JS_DupValue(ctx, v) };
			for (int32_t i = 0; i < static_cast<uint32_t>(jsarray["length"]); i++) {
				gd_arr.append(static_cast<float_t>(jsarray[i]));
			}
			return gd_arr;
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PackedFloat32Array gd_arr) noexcept {
		JSValue buff = JS_NewArrayBuffer(ctx, (uint8_t *)gd_arr._native_ptr(), gd_arr.size(), nullptr, nullptr, false);
		JSValue js_arr = JS_NewTypedArray(ctx, gd_arr.size(), &buff, JSTypedArrayEnum::JS_TYPED_ARRAY_FLOAT32);
		return js_arr;
	}
};
template <>
struct js_traits<godot::PackedFloat64Array> {
	/// @throws exception
	static godot::PackedFloat64Array unwrap(JSContext *ctx, JSValueConst v) {
		godot::PackedFloat64Array gd_arr;
		if (JS_IsArray(ctx, v) || JS_IsArrayInt8(ctx, v)) {
			Value jsarray{ ctx, JS_DupValue(ctx, v) };
			for (int32_t i = 0; i < static_cast<uint32_t>(jsarray["length"]); i++) {
				gd_arr.append(static_cast<float>(jsarray[i]));
			}
			return gd_arr;
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PackedFloat64Array gd_arr) noexcept {
		JSValue buff = JS_NewArrayBuffer(ctx, (uint8_t *)gd_arr._native_ptr(), gd_arr.size(), nullptr, nullptr, false);
		JSValue js_arr = JS_NewTypedArray(ctx, gd_arr.size(), &buff, JSTypedArrayEnum::JS_TYPED_ARRAY_FLOAT64);
		return js_arr;
	}
};
template <>
struct js_traits<godot::PackedStringArray> {
	/// @throws exception
	static godot::PackedStringArray unwrap(JSContext *ctx, JSValueConst v) {
		godot::PackedStringArray gd_arr;
		if (JS_IsArray(ctx, v) || JS_IsArrayInt8(ctx, v)) {
			Value jsarray{ ctx, JS_DupValue(ctx, v) };
			for (int32_t i = 0; i < static_cast<uint32_t>(jsarray["length"]); i++) {
				gd_arr.append(static_cast<char *>(jsarray[i]));
			}
			return gd_arr;
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PackedStringArray gd_arr) noexcept {
		JSValue buff = JS_NewArrayBuffer(ctx, (uint8_t *)gd_arr._native_ptr(), gd_arr.size(), nullptr, nullptr, false);
		JSValue js_arr = JS_NewTypedArray(ctx, gd_arr.size(), &buff, JSTypedArrayEnum::JS_TYPED_ARRAY_UINT8C);
		return js_arr;
	}
};
template <>
struct js_traits<godot::PackedVector2Array> {
	/// @throws exception
	static godot::PackedVector2Array unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PackedVector2Array *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PackedVector2Array v) noexcept {
		return Value{ ctx, std::forward<godot::PackedVector2Array>(v) };
	}
};
template <>
struct js_traits<godot::PackedVector3Array> {
	/// @throws exception
	static godot::PackedVector3Array unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PackedVector3Array *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PackedVector3Array v) noexcept {
		return Value{ ctx, std::forward<godot::PackedVector3Array>(v) };
	}
};
template <>
struct js_traits<godot::PackedColorArray> {
	/// @throws exception
	static godot::PackedColorArray unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::PackedColorArray *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::PackedColorArray v) noexcept {
		return Value{ ctx, std::forward<godot::PackedColorArray>(v) };
	}
};
template <typename T>
struct js_traits<godot::TypedArray<T>> {
	/// @throws exception
	static godot::TypedArray<T> unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TypedArray<T> *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TypedArray<T> rid) noexcept {
		return Value{ ctx, std::forward<godot::TypedArray<T>>(rid) };
	}
};
template <typename T>
struct js_traits<godot::TypedArray<T> &> {
	/// @throws exception
	static godot::TypedArray<T> &unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(godot::TypedArray<T> *)ptr;
			}
		}
		JS_ThrowInternalError(ctx, "Value type error");
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::TypedArray<T> &v) noexcept {
		return Value{ ctx, std::forward<godot::TypedArray<T>>(v) };
	}
};

/** Conversion traits for Value.
 */
template <>
struct js_traits<Value> {
	static Value unwrap(JSContext *ctx, JSValueConst v) {
		return Value{ ctx, JS_DupValue(ctx, v) };
	}

	static JSValue wrap(JSContext *ctx, Value v) noexcept {
		assert(JS_GetRuntime(ctx) == JS_GetRuntime(v.ctx));
		return v.release();
	}
};

template <typename E>
struct js_traits<godot::BitField<E>, std::enable_if_t<std::is_enum_v<E>>> {
	/// @throws exception
	static E unwrap(JSContext *ctx, JSValueConst v) {
		if (JS_IsObject(v)) {
			void *ptr = JS_GetOpaque(v, JS_GetClassID(v));
			if (ptr) {
				return *(E *)ptr;
			}
		}
		throw exception{ ctx };
	}

	static JSValue wrap(JSContext *ctx, godot::BitField<E> v) noexcept {
		return qjs::Value{ ctx, std::move(v) };
	}
};

/** Convert to/from std::function. Actually accepts/returns callable object that is compatible with function<R (Args...)>.
 * @tparam R return type
 * @tparam Args argument types
 */
template <typename R, typename... Args>
struct js_traits<std::function<R(Args...)>, int> {
	static auto unwrap(JSContext *ctx, JSValueConst fun_obj) {
		const int argc = sizeof...(Args);
		if constexpr (argc == 0) {
			return [jsfun_obj = Value{ ctx, JS_DupValue(ctx, fun_obj) }]() -> R {
				JSValue result = JS_Call(jsfun_obj.ctx, jsfun_obj.v, JS_UNDEFINED, 0, nullptr);
				if (JS_IsException(result))
					throw exception{ jsfun_obj.ctx };
				return detail::unwrap_free<R>(jsfun_obj.ctx, result);
			};
		} else {
			return [jsfun_obj = Value{ ctx, JS_DupValue(ctx, fun_obj) }](Args... args) -> R {
				const int argc = sizeof...(Args);
				JSValue argv[argc];
				detail::wrap_args(jsfun_obj.ctx, argv, std::forward<Args>(args)...);
				JSValue result = JS_Call(jsfun_obj.ctx, jsfun_obj.v, JS_UNDEFINED, argc,
						const_cast<JSValueConst *>(argv));
				for (int i = 0; i < argc; i++)
					JS_FreeValue(jsfun_obj.ctx, argv[i]);
				if (JS_IsException(result))
					throw exception{ jsfun_obj.ctx };
				return detail::unwrap_free<R>(jsfun_obj.ctx, result);
			};
		}
	}

	/** Convert from function object functor to JSValue.
	 * Uses detail::function for type-erasure.
	 */
	template <typename Functor>
	static JSValue wrap(JSContext *ctx, Functor &&functor) noexcept {
		using detail::function;
		assert(js_traits<function>::QJSClassId);
		auto obj = JS_NewObjectClass(ctx, js_traits<function>::QJSClassId);
		if (JS_IsException(obj))
			return obj;
		try {
			auto fptr = function::create(JS_GetRuntime(ctx), std::forward<Functor>(functor));
			fptr->invoker = [](function *self, JSContext *ctx, JSValueConst this_value, int argc,
									JSValueConst *argv) {
				assert(self);
				auto f = reinterpret_cast<std::decay_t<Functor> *>(&self->functor);
				return detail::wrap_call<R, Args...>(ctx, *f, argc, argv);
			};
			JS_SetOpaque(obj, fptr);
			return obj;
		} catch (const std::exception &e) {
			JS_ThrowInternalError(ctx, "%s", e.what());
			return JS_EXCEPTION;
		} catch (...) {
			JS_ThrowInternalError(ctx, "Unknown errror");
			return JS_EXCEPTION;
		}
	}
};

namespace detail {

template <typename T, typename = void>
struct is_callable : std::is_function<T> {
};

template <typename T>
struct is_callable<T, std::enable_if_t<std::is_same_v<decltype(void(&T::operator())), void>>> : std::true_type {
};

template <typename T>
inline constexpr bool is_callable_v = is_callable<T>::value;

} //namespace detail

template <typename Function>
struct js_traits<Function, std::enable_if_t<detail::is_callable_v<Function>>> {
	static auto unwrap(JSContext *ctx, JSValueConst fun_obj) {
		return js_traits<
				decltype(std::function{ std::declval<Function>() }),
				int>::unwrap(ctx, fun_obj);
	}

	template <typename Functor>
	static JSValue wrap(JSContext *ctx, Functor &&functor) {
		return js_traits<
				decltype(std::function{ std::declval<Function>() }),
				int>::wrap(ctx, std::forward<Functor>(functor));
	}
};

/** Convert from std::vector<T> to Array and vice-versa. If Array holds objects that are non-convertible to T throws qjs::exception */
template <class T>
struct js_traits<std::vector<T>> {
	static JSValue wrap(JSContext *ctx, const std::vector<T> &arr) noexcept {
		try {
			auto jsarray = Value{ ctx, JS_NewArray(ctx) };
			for (uint32_t i = 0; i < (uint32_t)arr.size(); i++)
				jsarray[i] = arr[i];
			return jsarray.release();
		} catch (exception) {
			return JS_EXCEPTION;
		} catch (std::exception const &err) {
			JS_ThrowInternalError(ctx, "%s", err.what());
			return JS_EXCEPTION;
		} catch (...) {
			JS_ThrowInternalError(ctx, "Unknown error");
			return JS_EXCEPTION;
		}
	}

	static std::vector<T> unwrap(JSContext *ctx, JSValueConst jsarr) {
		int e = JS_IsArray(ctx, jsarr);
		if (e == 0)
			JS_ThrowTypeError(ctx, "js_traits<std::vector<T>>::unwrap expects array");
		if (e <= 0)
			throw exception{ ctx };
		Value jsarray{ ctx, JS_DupValue(ctx, jsarr) };
		std::vector<T> arr;
		auto len = static_cast<int32_t>(jsarray["length"]);
		arr.reserve((uint32_t)len);
		for (uint32_t i = 0; i < (uint32_t)len; i++)
			arr.push_back(static_cast<T>(jsarray[i]));
		return arr;
	}
};

template <typename U, typename V>
struct js_traits<std::pair<U, V>> {
	static JSValue wrap(JSContext *ctx, std::pair<U, V> obj) noexcept {
		try {
			auto jsarray = Value{ ctx, JS_NewArray(ctx) };
			jsarray[uint32_t(0)] = std::move(obj.first);
			jsarray[uint32_t(1)] = std::move(obj.second);
			return jsarray.release();
		} catch (exception) {
			return JS_EXCEPTION;
		} catch (std::exception const &err) {
			JS_ThrowInternalError(ctx, "%s", err.what());
			return JS_EXCEPTION;
		} catch (...) {
			JS_ThrowInternalError(ctx, "Unknown error");
			return JS_EXCEPTION;
		}
	}

	static std::pair<U, V> unwrap(JSContext *ctx, JSValueConst jsarr) {
		int e = JS_IsArray(ctx, jsarr);
		if (e == 0)
			JS_ThrowTypeError(ctx, "js_traits<%s>::unwrap expects array", QJSPP_TYPENAME(std::pair<U, V>));
		if (e <= 0)
			throw exception{ ctx };
		Value jsarray{ ctx, JS_DupValue(ctx, jsarr) };
		const auto len = static_cast<uint32_t>(jsarray["length"]);
		if (len != 2) {
			JS_ThrowTypeError(ctx, "js_traits<%s>::unwrap expected array of length 2, got length %d",
					QJSPP_TYPENAME(std::pair<U, V>), len);
			throw exception{ ctx };
		}
		return std::pair<U, V>{
			static_cast<U>(jsarray[uint32_t(0)]),
			static_cast<V>(jsarray[uint32_t(1)])
		};
	}
};

/** Conversions for std::optional.
 * Unlike other types does not throw on unwrap but returns nullopt.
 * Converts std::nullopt to null.
 */
template <typename T>
struct js_traits<std::optional<T>> {
	/** Wraps T or null. */
	static JSValue wrap(JSContext *ctx, std::optional<T> obj) noexcept {
		if (obj)
			return js_traits<std::decay_t<T>>::wrap(ctx, *obj);
		return JS_NULL;
	}

	/** If conversion to T fails returns std::nullopt. */
	static auto unwrap(JSContext *ctx, JSValueConst v) noexcept -> std::optional<decltype(js_traits<std::decay_t<T>>::unwrap(ctx, v))> {
		try {
			if (JS_IsNull(v))
				return std::nullopt;
			return js_traits<std::decay_t<T>>::unwrap(ctx, v);
		} catch (exception) {
			// ignore and clear exception
			JS_FreeValue(ctx, JS_GetException(ctx));
		}
		return std::nullopt;
	}
};

namespace detail {
template <typename Key>
property_proxy<Key>::operator Value() const {
	return as<Value>();
}
} //namespace detail

template <typename Function>
void Context::enqueueJob(Function &&job) {
	JSValue job_val = js_traits<std::function<void()>>::wrap(ctx, std::forward<Function>(job));
	JSValueConst arg = job_val;
	int err = JS_EnqueueJob(ctx, [](JSContext *ctx, int argc, JSValueConst *argv) {
        try
        {
            assert(argc >= 1);
            js_traits<std::function<void()>>::unwrap(ctx, argv[0])();
        }
        catch (exception)
        {
            return JS_EXCEPTION;
        }
        catch (std::exception const & err)
        {
            JS_ThrowInternalError(ctx, "%s", err.what());
            return JS_EXCEPTION;
        }
        catch (...)
        {
            JS_ThrowInternalError(ctx, "Unknown error");
            return JS_EXCEPTION;
        }
        return JS_UNDEFINED; }, 1, &arg);
	JS_FreeValue(ctx, job_val);
	if (err < 0)
		throw exception{ ctx };
}

inline Context &exception::context() const {
	return Context::get(ctx);
}

inline Value exception::get() {
	return context().getException();
}

inline void Runtime::promise_unhandled_rejection_tracker(JSContext *ctx, JSValueConst promise,
		JSValueConst reason, JS_BOOL is_handled, void *opaque) {
	auto &context = Context::get(ctx);
	if (context.onUnhandledPromiseRejection) {
		context.onUnhandledPromiseRejection(context.newValue(JS_DupValue(ctx, reason)));
	}
}

inline JSModuleDef *Runtime::module_loader(JSContext *ctx,
		const char *module_name, void *opaque) {
	Context::ModuleData data;
	auto &context = Context::get(ctx);

	try {
		if (context.moduleLoader)
			data = context.moduleLoader(module_name);

		if (!data.source) {
			JS_ThrowReferenceError(ctx, "could not load module filename '%s'", module_name);
			return NULL;
		}

		if (!data.url)
			data.url = module_name;

		// compile the module
		auto func_val = context.eval(*data.source, module_name, JS_EVAL_TYPE_MODULE | JS_EVAL_FLAG_COMPILE_ONLY);
		assert(JS_VALUE_GET_TAG(func_val.v) == JS_TAG_MODULE);
		JSModuleDef *m = reinterpret_cast<JSModuleDef *>(JS_VALUE_GET_PTR(func_val.v));

		// set import.meta
		auto meta = context.newValue(JS_GetImportMeta(ctx, m));
		meta["url"] = *data.url;
		meta["main"] = false;

		return m;
	} catch (exception) {
		return NULL;
	} catch (std::exception const &err) {
		JS_ThrowInternalError(ctx, "%s", err.what());
		return NULL;
	} catch (...) {
		JS_ThrowInternalError(ctx, "Unknown error");
		return NULL;
	}
}

inline Context *Runtime::executePendingJob() {
	JSContext *ctx;
	auto err = JS_ExecutePendingJob(rt, &ctx);
	if (err == 0) {
		// There was no job to run
		return nullptr;
	} else if (err < 0) {
		throw exception{ ctx };
	}
	return &Context::get(ctx);
}

} // namespace qjs